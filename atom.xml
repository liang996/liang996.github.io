<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灯@塔</title>
  
  <subtitle>灯火阑珊</subtitle>
  <link href="https://liang996.github.io/atom.xml" rel="self"/>
  
  <link href="https://liang996.github.io/"/>
  <updated>2023-07-30T05:00:26.977Z</updated>
  <id>https://liang996.github.io/</id>
  
  <author>
    <name>BiLiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023年面试总结</title>
    <link href="https://liang996.github.io/2023/07306554.html"/>
    <id>https://liang996.github.io/2023/07306554.html</id>
    <published>2023-07-30T04:09:15.000Z</published>
    <updated>2023-07-30T05:00:26.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h2><p>React Hooks 是从 React 16.8 版本推出的新特性，目的是解决 React 的状态共享以及组件生命周期管理混乱的问题，Hooks 是对 React function 组件的一种扩展，通过一些特殊的函数，让无状态组件拥有状态组件才拥有的能力</p><pre class=" language-js"><code class="language-js"><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="useEffect-用法"><a href="#useEffect-用法" class="headerlink" title="useEffect 用法"></a>useEffect 用法</h2><p>useEffect 钩子是 react 钩子 API 的一部分。如果你熟悉 react 生命周期，useEffect 钩子相当于生命周期方法 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的组合。<code>useEffect</code> 是一个接受<code>两</code>个参数的函数。传递给 useEffect 的第一个参数是一个名为 effect 的函数（你可以猜到为什么这个钩子叫 useEffect），第二个参数（是可选的）是一个存储依赖关系的数组。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。 HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。 具体而言，高阶组件是参数为组件，返回值为新组件的函数。<br>高阶组件不是组件，是增强函数，可以输入一个元组件，输出一个新的增强组件<br>高阶组件的主要作用是代码复用，操作状态和参数</p><h2 id="react-性能优化的方法"><a href="#react-性能优化的方法" class="headerlink" title="react 性能优化的方法"></a>react 性能优化的方法</h2><p>1.使用 React.Memo 来缓存组件</p><p>2.使用 useMemo 缓存大量的计算</p><p>3.使用 React.PureComponent , shouldComponentUpdate</p><p>4.使用 React.Fragment 避免添加额外的 DOM</p><h2 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h2><p>简单的说，事件循环（eventLoop）是单线程的 JavaScript 在处理异步事件时进行的一种循环过程，具体来讲，对于异步事件它会先加入到事件队列中挂起，等主线程空闲时会去执行事件队列中的事件。</p><p>主线程任务——&gt;微任务——&gt;宏任务 如果宏任务里还有微任就继续执行宏任务里的微任务，如果宏任务中的微任务中还有宏任务就在依次进行<br>主线程任务——&gt;微任务——&gt;宏任务——&gt;宏任务里的微任务——&gt;宏任务里的微任务中的宏任务——&gt;直到任务全部完成 我的理解是在同级下，微任务要优先于宏任务执行</p><p>在同一轮任务队列中，同一个微任务产生的微任务会放在这一轮微任务的后面，产生的宏任务会放在这一轮的宏任务后面<br>在同一轮任务队列中，同一个宏任务产生的微任务会马上执行，产生的宏任务会放在这一轮的宏任务后面</p><p>它不停检查 Call Stack 中是否有任务（也叫栈帧）需要执行，如果没有，就检查 Event Queue，从中弹出一个任务，放入 Call Stack 中，如此往复循环。</p><h2 id="项目是怎么部署的"><a href="#项目是怎么部署的" class="headerlink" title="项目是怎么部署的"></a>项目是怎么部署的</h2><p>1.Jenkins</p><p>2.webpack</p><h2 id="hooks-和类组件的区别"><a href="#hooks-和类组件的区别" class="headerlink" title="hooks 和类组件的区别"></a>hooks 和类组件的区别</h2><p>区别：</p><p>1、hooks 的写法比 class 简洁；</p><p>2、hooks 的业务代码比 class 更加聚合；</p><p>3、class 组件的逻辑复用通常用 render props 以及 HOC 两种方式，而 react hooks 提供了自定义 hooks 来复用逻辑。</p><h2 id="useeffects-模仿类组件生命周期"><a href="#useeffects-模仿类组件生命周期" class="headerlink" title="useeffects 模仿类组件生命周期"></a>useeffects 模仿类组件生命周期</h2><p>useEffect 钩子是 react 钩子 API 的一部分。如果你熟悉 react 生命周期，useEffect 钩子相当于生命周期方法 componentDidMount、componentDidUpdate 和 componentWillUnmount 的组合。</p><h2 id="ts-泛型了解吗"><a href="#ts-泛型了解吗" class="headerlink" title="ts 泛型了解吗"></a>ts 泛型了解吗</h2><pre><code>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性，使接口，函数或类更加通用</code></pre><h2 id="webpack-你常用的-loader-plugin-，有做过-webpack-优化吗"><a href="#webpack-你常用的-loader-plugin-，有做过-webpack-优化吗" class="headerlink" title="webpack 你常用的 loader plugin ，有做过 webpack 优化吗"></a>webpack 你常用的 loader plugin ，有做过 webpack 优化吗</h2><p><code>常用 loader</code></p><p>（1）babel-loader：把 es6 转成 es5；</p><p>（2）css-loader：加载 css，支持模块化，压缩，文件导入等特性；</p><p>（3）style-loader：把 css 代码注入到 js 中，通过 dom 操作去加载 css；</p><p>（4）eslint-loader：通过 Eslint 检查 js 代码；</p><p>（5）image-loader：加载并且压缩图片晚间；</p><p>（6）file-loader：文件输出到一个文件夹中，在代码中通过相对 url 去引用输出的文件；</p><p>（7）url-loader：和 file-loader 类似，文件很小的时候可以 base64 方式吧文件内容注入到代码中。</p><p>（8）source-map-loader：加载额外的 source map 文件，方便调试。</p><p><code>常用 plugin</code></p><p>（1）uglifyjs-webpack-plugin：通过 UglifyJS 去压缩 js 代码；</p><p>（2）commons-chunk-plugin：提取公共代码；</p><p>（3）define-plugin：定义环境变量。</p><h2 id="webpack-原理"><a href="#webpack-原理" class="headerlink" title="webpack 原理"></a>webpack 原理</h2><p>webpack 是一个打包模块化 js 的工具，可以通过 loader 转换文件，通过 plugin 扩展功能。</p><h2 id="封装过哪些组件，怎么封装的"><a href="#封装过哪些组件，怎么封装的" class="headerlink" title="封装过哪些组件，怎么封装的"></a>封装过哪些组件，怎么封装的</h2><p>封装时考虑的因素</p><p>1.我们需要考虑到未来的可维护性和复用性，这时就需要抽象出通用的逻辑或者功能，以便在不同的项目中使用</p><p>2.在开发组件时，需要将组件内部的数据和展示进行分离，以便组件的复用性和可维护性更高。通过 props 属性将外部的数据传递给组件，以便组件可以根据外部的数据进行展示。</p><p>3.抽象组件样式：在进行组件封装时，我们需要考虑到组件的样式问题</p><h2 id="路由守卫做过吗，怎么实现的"><a href="#路由守卫做过吗，怎么实现的" class="headerlink" title="路由守卫做过吗，怎么实现的"></a>路由守卫做过吗，怎么实现的</h2><p>路由守卫是什么<br>React Router 路由守卫（Route Guard）可以用来在进入或离开某个路由时进行验证和控制，以实现路由的权限管理、用户登录验证等功能。 React Router 提供了多种路由守卫的实现方式，包括使用高阶组件、使用函数组件和使用 render 属性等方式。</p><p>与 vue 不同，vue 直接使用 beforeEach 即可实现全局路由守卫等功能。<br>react 要实现路由守卫得自己配置。<br>实现该功能的前提是你需要先掌握 react 的高阶组件的使用</p><p>需要配置一张路由表。<br>需要使用高阶组件。</p><h2 id="空值合并运算符（-）与逻辑或运算符（-）区别"><a href="#空值合并运算符（-）与逻辑或运算符（-）区别" class="headerlink" title="空值合并运算符（??）与逻辑或运算符（||）区别"></a>空值合并运算符（??）与逻辑或运算符（||）区别</h2><p>空值合并运算符（nullish coalescing operator）的写法为两个问号 ??。</p><p>我们可以使用我们已知的运算符重写 <code>result = a ?? b</code>，像这样：</p><pre class=" language-js"><code class="language-js">result <span class="token operator">=</span> a <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">!==</span> undefined <span class="token operator">?</span> a <span class="token punctuation">:</span> b<span class="token punctuation">;</span></code></pre><p>例如，在这里，如果 user 的值不为 null/undefined 则显示 user，否则显示 匿名：</p><p>let user;</p><p>alert(user ?? “匿名”); // 匿名（user 未定义）</p><h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="?.(可选链操作符)"></a>?.(可选链操作符)</h2><p>?.表示：可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每 个引用是否有效。操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值</p><p>?.的个人理解 打个比方就是判断对象的某个属性是否存在，如果存在那么就返回整个属性的值，否则返回 undefined</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  getName<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"123"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> result1 <span class="token operator">=</span> a<span class="token operator">?</span><span class="token punctuation">.</span>getName<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123</span><span class="token keyword">let</span> result2 <span class="token operator">=</span> a<span class="token operator">?</span><span class="token punctuation">.</span>setName<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>与函数调用一起使用时，如果给定的函数不存在，则返回 undefined，不会报错</p><p>注意： 如果被当作方法调用的是一个属性，使用?.还是会报错</p><h2 id="了解过-fiber-吗-（用于解决渲染复杂组件时产生的卡顿问题）"><a href="#了解过-fiber-吗-（用于解决渲染复杂组件时产生的卡顿问题）" class="headerlink" title="了解过 fiber 吗 （用于解决渲染复杂组件时产生的卡顿问题）"></a>了解过 fiber 吗 （用于解决渲染复杂组件时产生的卡顿问题）</h2><p>React 更新视图的原理：通过 setState 改变数据从而触发虚拟 DOM 去进行对比，对比结束后将再进行 DOM 更新。当对比少的节点时使用这种方法时比较合理的，但是当我们一次更新有几百个甚至更多组件需要进行对比时，由于 Diff 是一个同步的方法，在进行对比时，由于 JS 单线程的原因，导致其他的事件都无法响应。<br>当在这个 Diff 的过程中如果有有通过 Input 输入信息，那么他将得不到响应，显然这样体验会非常不好。</p><p>针对这样的问题，React 16+中首次引入了 React Fiber，就是用于解决渲染复杂组件时产生的卡顿问题。</p><h2 id="css-动画结束后触发一个事件怎么做"><a href="#css-动画结束后触发一个事件怎么做" class="headerlink" title="css 动画结束后触发一个事件怎么做"></a>css 动画结束后触发一个事件怎么做</h2><p>第一种方法：<br>用计时器，设定一个和动画时长一样的 time，过 time 事件去执行这个函数。</p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二种方法：</p><p>当-webkit-animation 动画结束时有一个 webkitAnimationEnd 事件，只要监听这个事件就可以了。</p><p>不同浏览器的 AnimationEnd 写法</p><pre><code>(webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend)</code></pre><h2 id="判断类型的方法"><a href="#判断类型的方法" class="headerlink" title="判断类型的方法"></a>判断类型的方法</h2><p>判断类型有四种方法（不全但是相对来说挺全了，而且也够用了）</p><p>1.typeof</p><p>2.instanceof</p><p>3.constructor</p><p>4.Object.prototypy.tostring.call()</p><h2 id="ts-和-js-区别"><a href="#ts-和-js-区别" class="headerlink" title="ts 和 js 区别"></a>ts 和 js 区别</h2><p>TS 和 JS 是两种不同的编程语言。<br>JS（JavaScript）是一种流行的脚本语言，它通常用于在 Web 页面上实现交互和动态效果。它是一种动态类型语言，这意味着在编译时无需指定变量类型。</p><p>TS（TypeScript）是一种由 Microsoft 开发的开源编程语言，它是 JavaScript 的超集。TS 增加了类型注释、类、接口、枚举和其他面向对象编程的特性，这使得它更适合于大型项目。与 JS 不同的是，TS 编译器会在编译时检查类型错误，并提供更好的代码补全和文档。这些特性可以提高开发效率和代码质量。</p><p>总的来说，TS 在类型检查、面向对象编程和开发效率方面有明显的优势。但是，它也需要一些额外的学习和配置成本。对于小型项目或初学者来说，使用 JS 可能更为方便，而对于大型项目或需要更高质量保障的企业应用，则使用 TS 更为合适。</p><h2 id="http2-特点"><a href="#http2-特点" class="headerlink" title="http2 特点"></a>http2 特点</h2><p>http2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p><h2 id="map-和-weakmap"><a href="#map-和-weakmap" class="headerlink" title="map 和 weakmap"></a>map 和 weakmap</h2><p>在 ES6 中 新增了 Map 和 WeakMap 这俩个类</p><p>Map 用来存储映射关系键值对的，在普通对象在存储时，key 值只能为字符串或 Symbol 类型</p><p>Map 储存时就可以把对象或者其他类型作为一个对象的 key 值</p><p>Map 和 WeakMap 的区别：</p><p>Map 在储存时可以把任何类型作为对象的 key 值，并且它的内存引用为强引用</p><p>WeakMap 在储存时只能使用对象类型作为对象的 key 值，他的内存引用为弱引用，且不能被迭代</p><h2 id="css-中-align-content-和-align-items-区别"><a href="#css-中-align-content-和-align-items-区别" class="headerlink" title="css 中 align-content 和 align-items 区别"></a>css 中 align-content 和 align-items 区别</h2><p>1：共同点：它们对齐方向为交叉轴</p><p>2：不同点：align-content 应用于为 多行 而 align-items:应用于单行。</p><h2 id="css-中-padding-和-margin-区别"><a href="#css-中-padding-和-margin-区别" class="headerlink" title="css 中 padding 和 margin 区别"></a>css 中 padding 和 margin 区别</h2><p>margin 是用来隔开元素与元素的间距；<br>padding 是用来隔开元素与内容的间隔。<br>margin 用于布局分开元素使元素与元素互不相干；<br>padding 用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”。</p><h2 id="css-中图片旋转-90-度用哪个属性"><a href="#css-中图片旋转-90-度用哪个属性" class="headerlink" title="css 中图片旋转 90 度用哪个属性"></a>css 中图片旋转 90 度用哪个属性</h2><p>让图片旋转 90 度的方法：利用 transform 属性来进行图片旋转，如<code>transform:rotate(90deg)</code>。</p><p><code>transform</code>属性用于元素的 2D 或 3D 转换，该属性允许我们将元素旋转、缩放、移动、倾斜。</p><h2 id="避免重复渲染的方式-function-组件和-class-组件两种"><a href="#避免重复渲染的方式-function-组件和-class-组件两种" class="headerlink" title="避免重复渲染的方式 function 组件和 class 组件两种"></a>避免重复渲染的方式 function 组件和 class 组件两种</h2><p>避免重新渲染的思想其实也是对比 Props 的引用。决定是否渲染！</p><p>1.React.memo 的使用</p><p>2.使用 memo, useMemo, useCallback</p><h2 id="webpack-的原理"><a href="#webpack-的原理" class="headerlink" title="webpack 的原理"></a>webpack 的原理</h2><p>本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。</p><p>Webpack 是一个现代化的 JavaScript 应用程序打包工具，它的主要功能是将多个 JavaScript 文件打包成 一个或多个文件，以便于在浏览器中加载和运行。Webpack 的原理是将所有的模块打包成个或多个 bundle 文件，这些文件可以是 JavaScript、CSS、图片等资源文件</p><p>Webpack 的工作原理可以分为四个步骤:入口、输出、加载器和插件。</p><p>Webpack 需要指定一个或多个入口文件，这些文件是 Webpack 打包的起点。Webpack 会从入口文件开始递归地查找所有的依赖模块，直到找到所有的模块为止。</p><p>Webpack 需要指定一个或多个输出文件，这些文件是 Webpack 包后生成的文件。Webpack 会将所有的模块打包成一个或多个 bundle 文件，并将这些文件输出到指定的日录中</p><p>第二，Webpack 需要使用加载器来处理不同类型的文件。加载器是个转换器，它可以将不同类型的文件转换成 JavaScript 模块 Webpack 支持多种类型的加载器，包括 CSS 加载器、图片加载器、字体加载器等。<br>Webpack 还支持插件，浙件可以扩展 Webpack 的功能。Webpack 的插件可以用来压缩代码、优化资源、生成 HTML 文件等</p><p>总的来说，Webpack 的原理是将所有的模块打包成一个或多个 bundle 文件，并将这些文件输出到指定的目录中。Webpack 通过入口、输出、加载器和插件四个步骤来实现这个过程。Webpack 的工作原理非常灵活，可以根据不同的需求进行配置，使得 Webpack 成为一个非常强大的 JavaScript 应用程序打包工具。</p><h2 id="跨域怎么解决"><a href="#跨域怎么解决" class="headerlink" title="跨域怎么解决"></a>跨域怎么解决</h2><p>跨域就是当在页面上发送 ajax 请求时，由于浏览器同源策略的限制，要求当前页面和服务端必须同源，也就是协议、域名和端口号必须一致。如果协议、域名和端口号中有其中一个不一致，则浏览器视为跨域，进行拦截。</p><p>常见解决跨域手段</p><p>JSONP</p><p>CORS</p><p>搭建 Node 代理服务器</p><p>Nginx 反向代理</p><p>postMessage</p><p>Websocket</p><h2 id="git-如何做指定版本回退"><a href="#git-如何做指定版本回退" class="headerlink" title="git 如何做指定版本回退"></a>git 如何做指定版本回退</h2><p>1.回滚到指定版本</p><p>首先进入项目根目录下，使用 <code>git log</code> 命令，找到需要返回的 <code>commit id</code> 号，使用 <code>git reset --hard</code> 后跟你需要的 <code>commit id</code> 号，这样你就回到了指定的版本，注意 <code>git reset --hard</code> 与 <code>git reset --soft</code> 的区别：</p><p>git reset –-soft：回退到某个版本，只回退了 commit 的信息，不会恢复到 index file 一级。通常使用在当你 git commit -m “注释”提交了你修改的内容，但内容有点问题想撤销，又还要提交，就使用 soft，相当于软着路；</p><p>git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的 commit 中所包含的更改被冲掉，相当于硬着路，回滚最彻底。</p><p>2.返回到最新版本</p><p>当你发现需要回滚到最新版本时，可以采用以下指今步骤</p><p>git log：查看历史提交</p><p>git reflog：查看每一次命令记录</p><p>通过 git reflog 命令查看到之后，我们再利用 git reset 来返回到相应的版本即可，HEAD 前面的一串字符为我们简写的 ID，所以最后输入</p><p>git reset –hard ca936c3 即回滚到了最新的版本号了</p><h2 id="怎么改-this-指向"><a href="#怎么改-this-指向" class="headerlink" title="怎么改 this 指向"></a>怎么改 this 指向</h2><p>主要有三种方法：<code>call</code>、<code>apply</code>、<code>bind</code></p><h2 id="父组件怎么调用子组件的方法"><a href="#父组件怎么调用子组件的方法" class="headerlink" title="父组件怎么调用子组件的方法"></a>父组件怎么调用子组件的方法</h2><p>父组件调子组件函数有两种情况<br>子组件无 HOC 嵌套：推荐使用 ref 直接调用<br>有 HOC 嵌套：推荐使用自定义 props 的方式</p><h2 id="flex-布局怎么改主轴方向-（flex-direction）"><a href="#flex-布局怎么改主轴方向-（flex-direction）" class="headerlink" title="flex 布局怎么改主轴方向 （flex-direction）"></a>flex 布局怎么改主轴方向 （flex-direction）</h2><p>设置主轴方向<br>主轴默认是水平方向, 侧轴默认是垂直方向</p><p>修改主轴方向属性: <code>flex-direction</code></p><h2 id="promise-then-的参数"><a href="#promise-then-的参数" class="headerlink" title="promise .then 的参数"></a>promise .then 的参数</h2><p>then 方法是 Promise 对象中最重要的一个方法。它接收两个参数，一个是成功时的回调函数，一个是失败时的回调函数。在调用了 then 方法后，它将返回一个新的 Promise 对象，这个新 Promise 对象的状态和值是由当前 Promise 对象所完成的操作结果决定的。</p><h2 id="动画旋转"><a href="#动画旋转" class="headerlink" title="动画旋转"></a>动画旋转</h2><p><code>anmimation</code>（动画离不开的）</p><h2 id="ts-联合类型怎么写"><a href="#ts-联合类型怎么写" class="headerlink" title="ts 联合类型怎么写"></a>ts 联合类型怎么写</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。联合类型使用 <code>|</code> 分隔每个类型。</p><h2 id="ts-type-与-interface-的区别"><a href="#ts-type-与-interface-的区别" class="headerlink" title="ts type 与 interface 的区别"></a>ts type 与 interface 的区别</h2><p><code>interface</code> 和 <code>type</code> 都可以用来定义对象类型，那么在开发中时到底选择哪一个呢？</p><p>如果是定义非对象类型，通常推荐使用 type。<br>如果是定义对象类型，那么他们有区别的：</p><p>interface 可以重复的对某个接口来定义属性和方法；</p><p>而 type 定义的是别名，不能重复。</p><h2 id="usememo-和-usecallback-的区别"><a href="#usememo-和-usecallback-的区别" class="headerlink" title="usememo 和 usecallback 的区别"></a>usememo 和 usecallback 的区别</h2><p><code>useMemo</code> 和 <code>useCallback</code> 都是 reactHook 提供的两个 API，用于缓存数据，优化性能；两者接收的参数都是一样的，第一个参数表示一个回调函数，第二个表示依赖的数据。</p><p>共同作用<br>在依赖数据发生变化的时候，才会调用传进去的回调函数去重新计算结果，起到一个缓存的作用</p><p>两者的区别<br>useMemo 缓存的结果是回调函数中 return 回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态<br>useCallback 缓存的结果是函数，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个 state 发生变化，会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费；另外还需要注意的是，useCallback 应该和 React.memo 配套使用，缺了一个都可能导致性能不升反而下降。</p><h2 id="父组件获取子组件的方法"><a href="#父组件获取子组件的方法" class="headerlink" title="父组件获取子组件的方法"></a>父组件获取子组件的方法</h2><p>调用方法：<br>1、类组件中的调用可以利用 React.createRef()、ref 的函数式声明或 props 自定义 onRef 属性来实现；</p><p>2、函数组件、Hook 组件中的调用可以利用 useImperativeHandle 或 forwardRef 抛出子组件 ref 来实现。</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>1.同源策略</p><p>2.xss 攻击</p><p>3.HTTPS</p><p>3.CSRF</p><h2 id="高阶组件-1"><a href="#高阶组件-1" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p><p>具体而言，高阶组件是参数为组件，返回值为新组件的函数。</p><h2 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h2><p>一般首屏加载速度慢得原因可能如下几点：</p><p>1.网络延时问题，</p><p>2.资源文件体积是否过大，</p><p>3.资源是否重复发送请求去加载了</p><p>4.加载脚本的时候，渲染内容堵塞了</p><p><code>常见的 SPA 优化方式解决方案</code></p><p>1.减小入口文件体积，</p><p>2.静态资源本地缓存，</p><p>3.UI 框架按需引入，</p><p>4.图片资源的压缩，</p><p>5.组件重复打包，</p><p>6.开启 GZip 打包，</p><p>7.开启 SSR</p><p>8.去除 loading</p><h2 id="useeffect-跟-uselayouteffect-的区别"><a href="#useeffect-跟-uselayouteffect-的区别" class="headerlink" title="useeffect 跟 uselayouteffect 的区别"></a>useeffect 跟 uselayouteffect 的区别</h2><p>这两个函数的使用方式其实非常简单，他们都接受一个函数一个数组，只有在数组里面的值改变的情况下才会再次执行 effect。<br>差异：<br>useEffect 是异步执行的，而 useLayoutEffect 是同步执行的。<br>useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。</p><h2 id="父组件怎么使用子组件的方法"><a href="#父组件怎么使用子组件的方法" class="headerlink" title="父组件怎么使用子组件的方法"></a>父组件怎么使用子组件的方法</h2><p>1.子组件是类组件，使用 Refs</p><p>2.子组件是函数组件，使用 Refs 转发</p><p>2.1① 使用 forwardRef 转发 Refs 到 DOM 组件，就是将 父组件的 ref 向下传递给子组件。</p><p>2.2② forwardRef 结合 useImperativeHandle 使用，自定义暴露给父组件的实例值。</p><p>2.3③ 在高阶组件(HOC)中转发 Refs</p><h2 id="首页渲染做过哪些优化"><a href="#首页渲染做过哪些优化" class="headerlink" title="首页渲染做过哪些优化"></a>首页渲染做过哪些优化</h2><p>前端优化大概可以有以下几个方向：</p><p>网络优化</p><p>页面渲染优化</p><p>JS 优化</p><p>图片优化</p><p>webpack 打包优化</p><p>React 优化</p><p>Vue 优化</p><p>网络优化</p><h2 id="setstate-怎么同步拿数据"><a href="#setstate-怎么同步拿数据" class="headerlink" title="setstate 怎么同步拿数据"></a>setstate 怎么同步拿数据</h2><p>setState({})去更新状态时,发现更新后拿到的状态不是最新的,还是更新前的,所以 setState 是异步更新,如果想在状态更新页面完成渲染后立即做一些事情,那么这时我们就要用到 setState 的第二个参数</p><h2 id="css-页面顶部底部固定，中间自适应几种方法"><a href="#css-页面顶部底部固定，中间自适应几种方法" class="headerlink" title="css 页面顶部底部固定，中间自适应几种方法"></a>css 页面顶部底部固定，中间自适应几种方法</h2><p>1，使用相对定位和绝对定位</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* // 第一种方式 */</span><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* // 使用子绝父相 */</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f1f3f4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">header,main,footer </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* // 设置绝对定位 */</span><span class="token selector">footer </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f9cc9d</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#c3d08b</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#2b93f5</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>2，使用 flex 弹性布局，将 footer 的 margin-top 设置为 auto</p><p>注意：在浏览器中，100vh 的高度包括了底部的工具栏，而我们真实需要的高度其实是浏览器的可视高度也就是 100%；<br>在使用 100vh 的时候，手机浏览器底部的操作栏可能会遮挡底部按钮；<br>所以这时页面的高度应该使用 100%；</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f1f3f4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">header,main,footer </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">footer </span><span class="token punctuation">{</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-HTML"><code class="language-HTML">        <div class="container">            <header style="background: #f9cc9d">Header</header>            <main style="background: #c3d08b">Content</main>            <footer style="background: #2b93f5">Footer</footer>        </div></code></pre><p>3，通过 css 内置函数 calc()动态计算内容的高度</p><p>min-height: calc(100vh - 130px); 130 其实就是 header 和 footer 的高度；</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">header,main,footer </span><span class="token punctuation">{</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">header </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">footer </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main </span><span class="token punctuation">{</span>  <span class="token property">min-height</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">100</span>vh - <span class="token number">130</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-HTML"><code class="language-HTML">    <div class="container">        <header style="background: #f9cc9d">Header</header>        <main style="background: #c3d08b">Content</main>        <footer style="background: #2b93f5">Footer</footer>    </div></code></pre><h2 id="文字超出部分变成省略号的三种方式"><a href="#文字超出部分变成省略号的三种方式" class="headerlink" title="文字超出部分变成省略号的三种方式"></a>文字超出部分变成省略号的三种方式</h2><p>1.单行文本溢出显示省略号</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/*强制文本在一行内显示*/</span>  <span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.多行文本溢出显示省略号</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 将对象作为弹性伸缩盒子模型显示 */</span>  <span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 限制在一个块元素显示的文本的行数 */</span>  <span class="token comment" spellcheck="true">/* -webkit-line-clamp 其实是一个不规范属性，使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；*/</span>  <span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span>  <span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>js 方法实现</p><p>第一种方法用到的是 substring(from, to )方法，括号内第一个参数是索引起始值，第二个参数是索引的结束值。substring()从字符串中抽取一个子串，然后赋值给 textCon，最后再用 concat()连接省略号。需要注意的是 substring()的返回值是它本身（抽取的值），字符串的第一个索引值是 0。</p><pre class=" language-js"><code class="language-js">textCon <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>textEnd <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二种方法的思路是：先用 split(“”)将字符串转化为数组，split(separator)将字符串分割成数组，默认用逗号分隔，对本身字符串没有产生影响；转成数组后我们再用 splice(开始的索引, 要删除的个数, 插入的元素)对后面多余的文本进行删除；最后用 join(“”)把数组连接成字符串，后面加上 concat(“……”)。这里需要注意的是 splice()的返回值是改变后的数组。</p><pre class=" language-js"><code class="language-js">textCon <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将字符串转化为数组</span>textCon <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span> textCon<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>textEnd <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>text<span class="token punctuation">.</span>innerText <span class="token operator">=</span> textEnd<span class="token punctuation">;</span></code></pre><p>第三种则是用到 replace()字符串替换方法，它的思路很简单，就是把后面多余的文本字符串替换为空。这里需要注意的地方是：用 for 语句进行循环，每将一个字符替换为空后，它后面的字符就会自动往前移，所以我们只要在某个固定的位置将字符替换为空，后面的字符就会顶上来，就像流水线一样。这是三种方法里面最简单的一种。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> textCon<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  textCon <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>textCon<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>textEnd <span class="token operator">=</span> textCon<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>text<span class="token punctuation">.</span>innerText <span class="token operator">=</span> textEnd<span class="token punctuation">;</span></code></pre><h2 id="实现字符串反转"><a href="#实现字符串反转" class="headerlink" title="实现字符串反转"></a>实现字符串反转</h2><p>使用数组的 reverse()方法</p><p>步骤如下：</p><p>将字符串转为数组<br>使用数组的 reverse()方法进行反转<br>使用数组的 join()方法将数组转化为字符串<br>示例代码如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span><span class="token keyword">const</span> reversedStr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reversedStr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：'!dlroW olleH'</span></code></pre><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>1.使用 replace()方法.</p><p>replace()方法用于在字符串中查找并替换指定的子串。它接受两个参数：第一个参数是需要替换的子串或用于匹配子串的正则表达式，第二个参数是需要替换成的字符串。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hello javascript</span></code></pre><p>2.使用正则表达式替换</p><p>如果需要使用正则表达式进行替换，可以使用 replace()方法的第一个参数传入一个正则表达式。例如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">"2022-02-22"</span><span class="token punctuation">;</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/-/g</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2022/02/22</span></code></pre><p>3.使用 replaceAll()方法</p><p>从 ECMAScript 2021 规范开始，JavaScript 原生支持了 replaceAll()方法。它也是用于在字符串中替换指定的子串，但是相比于 replace()方法，它可以直接替换所有匹配的子串，而不需要使用正则表达式。</p><p>例如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">,</span> <span class="token string">"O"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hellO wOrld</span></code></pre><p>注意，由于 replaceAll()方法目前还不是所有浏览器都支持，因此在实际开发中需要进行兼容性处理。</p><h2 id="async-里面多个-await，如何优化"><a href="#async-里面多个-await，如何优化" class="headerlink" title="async 里面多个 await，如何优化"></a>async 里面多个 await，如何优化</h2><pre class=" language-JS"><code class="language-JS"> async initData() {    const cache = await this.cachePromise;  // 出错了    const cache2 = await this.cachePromise2;  //不执行    const cache3 = await this.cachePromise3;  //不执行    const cache4 = await this.cachePromise4;  //不执行  }// 修改后 async initData() {    try {       const cache = await this.cachePromise;  // 出错了       const cache2 = await this.cachePromise2;  //执行       const cache3 = await this.cachePromise3;  //执行       const cache4 = await this.cachePromise4;  //执行     } catch(err) {       console.log(err)     }  }</code></pre><h2 id="使用-promise-封装-Ajax-请求"><a href="#使用-promise-封装-Ajax-请求" class="headerlink" title="使用 promise 封装 Ajax 请求"></a>使用 promise 封装 Ajax 请求</h2><pre class=" language-JS"><code class="language-JS">function myaxios(url) {    var p1 = new Promise(function (n1, n2) {        var xhr = new XMLHttpRequest() || new ActiveXObject("Microsoft.XMLHTTP")        xhr.open("GET", url, true)        xhr.send()        xhr.onreadystatechange = function () {            if (xhr.readyState == 4 && xhr.status == 200) {                n1(xhr.responseText)            } else if (xhr.readyState == 4 && xhr.status == 404) {                n2(xhr.responseText)            }        }    })    return p1}</code></pre><p>调用时的方法：</p><pre class=" language-JS"><code class="language-JS"><button onclick="fn()">ajax请求</button>    <script>        function fn() {            var url = "http://192.168.0.114:8081/ajax1" //要请求的目标网址            myaxios(url).then((res) => {                console.log(res);            })        }    </script></code></pre><h2 id="实现瀑布流-瀑布流布局常见场景用于展示照片"><a href="#实现瀑布流-瀑布流布局常见场景用于展示照片" class="headerlink" title="实现瀑布流 (瀑布流布局常见场景用于展示照片)"></a>实现瀑布流 (瀑布流布局常见场景用于展示照片)</h2><p>瀑布流布局是一种新型的布局方式，可以将大小不一的图片完整的显示在页面上，并且在杂乱的布局中保持着一定的美感，</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>con<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../img/1.jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../img/2.jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../img/3.jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../img/4.jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../img/5.jpeg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>1.CSS 布局<br>使用 column-count 属性</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">column-count</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 想要排成的列数 */</span>  <span class="token property">column-gap</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.item</span> img </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.使用 flex 布局</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 需要指定高度 */</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">25%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.item</span> img </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="小程序的登录流程"><a href="#小程序的登录流程" class="headerlink" title="小程序的登录流程"></a>小程序的登录流程</h2><p>1.通过 wx.login() 获取到用户的 code 判断用户是否授权读取用户信息，调用 wx.getUserInfo 读取用户数据。</p><p>2.由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息。</p><p>3.通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。<br>appid 和 appsecret 都是微信提供的，可以在管理员后台找到。</p><p>4.微信服务器返回了 openid 及本次登录的会话密钥 session_key。</p><p>5.后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走。</p><p>6.session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。</p><p>7.然后生成 session 并返回给小程序。</p><p>8.小程序把 session 存到 storage 里面。</p><p>9.下次请求时，先从 storage 里面读取，然后带给服务端。</p><p>10.服务端对比 session 对应的记录，然后校验有效期。</p><p>登录逻辑： 1.调用 wx.login() 获取 临时登录凭证 code，有效期为 5 分钟；（临时登录凭证 code 只能使用一次）</p><p>2.将临时 code 传到我们的后端，后端调用 auth.code2Session 接口，换取用户唯一标识 OpenID 和 会话密钥 session_key；（ openid 是用户唯一标识，session_key 能保证当前用户进行会话操作的有效性）</p><p>注意：获取 session_key 出于安全性的考虑，要在后端调用。如果我们在前端通过 request 调用此接口，就不可避免的需要将我们小程序的 appid 、secret 和服务端下发的 session_key 暴露在外部，会给我们的业务安全带来极大的风险。<br>session_key 拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者需要调用 wx.checkSession 接口检测当前用户登录态是否有效。</p><p>3.后端自定义新的密钥并关联返回的 session_key 和 openid，将新的密钥返给前端，前端将其存储在 storage 中。（会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥，所以要定义新的密钥）。<br>之所以存在 storage 中，是因为小程序没有 cookie，相应的后端 set-cookie 在小程序中不起作用。</p><p>4.前端发送请求的时候，带着密钥，后端根据密钥识别用户身份，返回数据。</p><h2 id="bff-项目来处理什么问题"><a href="#bff-项目来处理什么问题" class="headerlink" title="bff 项目来处理什么问题"></a>bff 项目来处理什么问题</h2><p>BFF（Backend-for-Frontend）中间层是一种架构模式，主要用于解决前后端协作和微服务架构中的数据聚合问题。在这种架构下，前端应用程序不直接与后端服务通信，而是通过一个专门为前端定制的 BFF 中间层与后端服务交互。BFF 中间层负责与多个后端服务进行通信，聚合数据，并将结果返回给前端应用程序。</p><p>BFF 中间层的主要作用是：</p><p>为前端应用程序提供一个统一的 API 接口，简化前端应用程序的开发和维护。</p><p>负责与多个后端服务进行通信，聚合数据，降低前端应用程序的复杂度。<br>提供负载均衡、服务发现、缓存、错误处理和重试策略等功能，提高系统的性能和可用性。</p><h2 id="空值合并运算符-‘-’与’-’运算符区别"><a href="#空值合并运算符-‘-’与’-’运算符区别" class="headerlink" title="空值合并运算符 ‘??’与’||’运算符区别"></a>空值合并运算符 ‘??’与’||’运算符区别</h2><p>||运算符和??运算符在链式使用方法中有相同的地方，例如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">let</span> secon <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">let</span> third <span class="token operator">=</span> <span class="token string">"Beautiful Girl"</span><span class="token punctuation">;</span><span class="token keyword">let</span> r1 <span class="token operator">=</span> first <span class="token operator">?</span><span class="token operator">?</span> secon <span class="token operator">?</span><span class="token operator">?</span> third <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"undefined"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//(1)</span><span class="token keyword">let</span> r2 <span class="token operator">=</span> first <span class="token operator">||</span> secon <span class="token operator">||</span> thrid <span class="token operator">||</span> <span class="token string">"undefined"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//(2)</span></code></pre><p>上述代码中，(1)(2)两行的作用是完全相同的，但是相对于共同点，二者的区别更大。</p><p>从定义上：</p><p>||返回表达式中的第一个真值；<br>??返回表达式中的第一个已定义值；<br>二者的区别就在于真值和已定义值的区别上：</p><p>||无法区分 0、false、””和 null/undefined，对于||而言，它们都是一样的。</p><p>??可以区分 null/undefined 和其他值的区别。</p><p>所以，在处理代码时，分真假用||，分有无用??。</p><h2 id="微前端的理解"><a href="#微前端的理解" class="headerlink" title="微前端的理解"></a>微前端的理解</h2><p>概念：微前端是一种类似于微服务的架构。它使得各个前端应用可以独立运行、独立开发、独立部署，微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用（微前端的核心在于拆，拆完之后再合）</p><p>技术框架：目前常用的微前端技术框架有 single-spa 以及基于 single-spa 开发的微前端实现库 qiankun</p><p>使用场景：</p><p>1.我们需要兼容遗留的系统时</p><p>2.当项目需要聚合应用时</p><p>3.当不同的团队开发同一个应用，所选技术栈不同时</p><h2 id="HTML-lt-iframe-gt-标签"><a href="#HTML-lt-iframe-gt-标签" class="headerlink" title="HTML <iframe>标签"></a>HTML <code>&lt;iframe&gt;</code>标签</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。所有浏览器都支持 <code>&lt;iframe&gt;</code> 标签。您可以把需要的文本放置在 <code>&lt;iframe&gt;</code> 和 <code>&lt;/iframe&gt;</code> 之间，这样就可以应对无法理解 iframe 的浏览器。使用 iframe，可以配置不同的 src 加载不同的子应用页面</p><h2 id="js-中的-set-与-map"><a href="#js-中的-set-与-map" class="headerlink" title="js 中的 set 与 map"></a>js 中的 set 与 map</h2><p>简述：Set 和 Map 主要的应用场景在于 数据重组 和 数据储存。Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。</p><p>Set：<br>成员唯一、无序且不重复。<br>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）。<br>可以遍历，方法有：add、delete、has。</p><p>Map：<br>本质上是键值对的集合，类似集合。<br>可以遍历，方法很多可以跟各种数据格式转换。</p><h2 id="组件封装如何做的？封装时考虑的因素？"><a href="#组件封装如何做的？封装时考虑的因素？" class="headerlink" title="组件封装如何做的？封装时考虑的因素？"></a>组件封装如何做的？封装时考虑的因素？</h2><p>一般步骤如下： 1.创建一个新的 Vue 单文件组件（.vue 文件），并命名为你的组件名，例如 MyComponent.vue。</p><p>2 在组件文件中，使用 <code>&lt;template&gt;</code> 标签定义组件的模板结构，使用 <code>&lt;script&gt;</code> 标签定义组件的逻辑，使用 <code>&lt;style&gt;</code> 标签定义组件的样式。</p><p>3 在 <code>&lt;script&gt;</code> 标签中，使用 export default 导出一个 Vue 组件对象。</p><p>4 在组件对象中，定义组件的属性（props），数据（data），方法（methods），生命周期钩子（lifecycle hooks）等。</p><p>5 如果需要，可以在组件中引入其他的子组件或插件。</p><p>6 在需要使用该组件的地方，使用 import 语句导入该组件，然后在父组件的模板中使用该组件的标签。</p><p>封装时考虑的因素</p><p>1.我们需要考虑到未来的可维护性和复用性，这时就需要抽象出通用的逻辑或者功能，以便在不同的项目中使用</p><p>2.在开发组件时，需要将组件内部的数据和展示进行分离，以便组件的复用性和可维护性更高。通过 props 属性将外部的数据传递给组件，以便组件可以根据外部的数据进行展示。</p><p>3.抽象组件样式：在进行组件封装时，我们需要考虑到组件的样式问题</p><h2 id="http-常见状态码有哪些？"><a href="#http-常见状态码有哪些？" class="headerlink" title="http 常见状态码有哪些？"></a>http 常见状态码有哪些？</h2><p>一、1 开头的状态码(信息类)</p><p>100，接受的请求正在处理，信息类状态码</p><p>二、2 开头的状态码(成功类)</p><p>2xx(成功)表示成功处理了请求的状态码<br>200(成功)服务器已成功处理了请求。</p><p>三、3 开头的状态码(重定向)</p><p>3xx(重定向)表示要完成请求，需要进一步操作。通常这些状态代码用来重定向。<br>301，永久性重定向，表示资源已被分配了新的 URL<br>302，临时性重定向，表示资源临时被分配了新的 URL<br>303，表示资源存在另一个 URL，用 GET 方法获取资源<br>304，(未修改)自从上次请求后，请求网页未修改过。服务器返回此响应时，不会返回网页内容</p><p>四、4 开头的状态码(客户端错误)</p><p>4xx(请求错误)这些状态码表示请求可能出错，妨碍了服务器的处理<br>400(错误请求)服务器不理解请求的语法<br>401 表示发送的请求需要有通过 HTTP 认证的认证信息<br>403(禁止)服务器拒绝请求<br>404(未找到)服务器找不到请求网页</p><p>五、5 开头的状态码(服务器错误)</p><p>5xx(服务器错误)这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误<br>500，(服务器内部错误)服务器遇到错误，无法完成请求<br>503，表示服务器处于停机维护或超负载，无法处理请求</p><h2 id="flex-1-和-flex-auto-的区别，flex-是哪些属性的缩写？"><a href="#flex-1-和-flex-auto-的区别，flex-是哪些属性的缩写？" class="headerlink" title="flex:1 和 flex:auto 的区别，flex 是哪些属性的缩写？"></a>flex:1 和 flex:auto 的区别，flex 是哪些属性的缩写？</h2><p>flex:1 和 flex:auto 区别：规则基准使用值不同、子元素不同、包裹块不同。</p><p>flex: 1=== flex: 1 1 0;</p><p>在说 flex:1 和 flex:auto 区别之前先回顾 flex:0 1 atuo;</p><p>从默认值上可以看出它有三个属性，分别是 flex-grow、flex-shrink、flex-basis</p><p>flex-grow:项目的放大比例，默认为 0，如果存在剩余空间，不放大</p><p>flex-shrink:项目的缩小比例，默认为 1，如果空间不足，会适当缩小</p><p>flex-basis:在分配空间之前，项目的主轴空间，相当于我们设置的 width，</p><h2 id="Vue-的生命周期有哪些？created-和-mounted-区别？"><a href="#Vue-的生命周期有哪些？created-和-mounted-区别？" class="headerlink" title="Vue 的生命周期有哪些？created 和 mounted 区别？"></a>Vue 的生命周期有哪些？created 和 mounted 区别？</h2><p>beforeCreate( 创建前 )：el 和 data 并未初始化，因此无法访问 methods， data， computed 等上的方法和数据，无法使用 this。</p><p>created ( 创建后 ）：完成了 data 数据的初始化，el 没有。 主要用来初始化一些数据。</p><p>beforeMount：完成了 el 和 data 初始化，$el 属性已存在，是虚拟 dom，只是数据未挂载到模板中（没有挂在 html 到页面上）。</p><p>mounted：dom 操作在此时能正常进行。此时一般可以做一些 ajax 操作，mounted 只会执行一次。Dom 操作一般是在 mounted 钩子函数中进行的</p><p>beforeUpdate （更新前）：在数据更新之前被调用，此时数据是新的，页面依旧还是旧的</p><p>updated （更新后）：此时组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作</p><p>beforeDestrioy （销毁前）：在实例销毁之前调用，实例仍然完全可用,一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的 dom 事件<br>destroyed（销毁后）:执行 destroy 方法后，对 data 的改变不会再触发周期函数，此时的 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。</p><p>区别：</p><p>created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。</p><p>mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。</p><h2 id="Vue3-的生命周期钩子函数的变化-（6-个）"><a href="#Vue3-的生命周期钩子函数的变化-（6-个）" class="headerlink" title="Vue3 的生命周期钩子函数的变化 （6 个）"></a>Vue3 的生命周期钩子函数的变化 （6 个）</h2><p>在 Vue3 中，一些常见的钩子函数发生了变化。例如，vue2 中的 created 和 beforeCreate 钩子函数被替换为了 setup()，并且 setup()在二者之前执行。beforeMount 和 mounted 函数被替换成了 onBeforeMount 和 onMounted。beforeUpdate 和 update 被替换为 onBeforeUpdate 和 onupdate。beforeDestroy 和 destroyed 被替换为 beforeUnmount 和 unmounted。这些钩子函数的执行顺序与 Vue2 的版本相同，但是有所不同的是，在 Vue3 中，它们是使用 ES6 类定义的。</p><h2 id="写一个对象，这个对象还得包含一个取消定时器的方法，-需要从-0-100-依次定时打印出来"><a href="#写一个对象，这个对象还得包含一个取消定时器的方法，-需要从-0-100-依次定时打印出来" class="headerlink" title="写一个对象，这个对象还得包含一个取消定时器的方法， 需要从 0-100 依次定时打印出来"></a>写一个对象，这个对象还得包含一个取消定时器的方法， 需要从 0-100 依次定时打印出来</h2><pre class=" language-JS"><code class="language-JS">let i=0let timer=setInterval(() => {    console.log('当前值为 :>> ', i++);    if(i>100){        clearInterval(i)    }}, 1000);</code></pre><h2 id="数组的去重，排序，倒叙"><a href="#数组的去重，排序，倒叙" class="headerlink" title="数组的去重，排序，倒叙"></a>数组的去重，排序，倒叙</h2><p>数组的去重 1.使用 set 结构去重</p><p>2.使用 for+indexOf 方法去重</p><p>3.使用 for+includes 方法去重</p><p>排序：sort</p><pre class=" language-JS"><code class="language-JS">var arr2 = [20,13,11,8,0,11];</code></pre><p>按升序排列，前减后</p><pre class=" language-JS"><code class="language-JS">arr2.sort(function(a,b){    //a,b表示相邻的两个元素    //若返回值>0,数组元素将按升序排列    //若返回值<0,数组元素将按降序排列    return a-b;});console.log(arr2); //[0,8,11,11,13,20]; 新数组按升序排列</code></pre><p>按降序排列，后减前</p><pre class=" language-JS"><code class="language-JS">arr2.sort(function(a,b){    //a,b表示相邻的两个元素    //若返回值>0,数组元素将按升序排列    //若返回值<0,数组元素将按降序排列    return b-a;});console.log(arr2); //[20,13,11,11,8,0]; 新数组按降序排列</code></pre><p>css 样式，同一行中三个元素平均分布</p><p>采用父盒子设置弹性盒布局，子盒子则 flex:1,等比均分</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.son</span> </span><span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="css-九宫格布局"><a href="#css-九宫格布局" class="headerlink" title="css 九宫格布局"></a>css 九宫格布局</h2><pre class=" language-HTML"><code class="language-HTML"><div class="box">  <ul>    <li>1</li>    <li>2</li>    <li>3</li>    <li>4</li>    <li>5</li>    <li>6</li>    <li>7</li>    <li>8</li>    <li>9</li>  </ul></div>公共样式：<style>ul {    padding: 0;}li {    list-style: none;      text-align: center;    border-radius: 5px;    background: skyblue;}</style></code></pre><p>flex 实现</p><pre class=" language-css"><code class="language-css"><span class="token selector">ul </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">li </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">30%</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">30%</span><span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">5%</span><span class="token punctuation">;</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">5%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">li<span class="token pseudo-class">:nth-of-type(3n)</span> </span><span class="token punctuation">{</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">li<span class="token pseudo-class">:nth-of-type(n + 7)</span> </span><span class="token punctuation">{</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>（2）grid 实现<br>grid 布局相对于 flex 布局来说，实现九宫格就更加容易了，只需要设置几个属性即可：</p><pre class=" language-css"><code class="language-css"><span class="token selector">ul </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token number">30%</span> <span class="token number">30%</span> <span class="token number">30%</span><span class="token punctuation">;</span>  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token number">30%</span> <span class="token number">30%</span> <span class="token number">30%</span><span class="token punctuation">;</span>  <span class="token property">grid-gap</span><span class="token punctuation">:</span> <span class="token number">5%</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="浏览器打开两个标签页-cookie-是否一样"><a href="#浏览器打开两个标签页-cookie-是否一样" class="headerlink" title="浏览器打开两个标签页,cookie 是否一样"></a>浏览器打开两个标签页,cookie 是否一样</h2><p>两个页签中保存的 cookie 都是一样的,cookie 在一个浏览器下同一个域名下是全部共享一致的，和页签没任何关系的。</p><h2 id="同一个浏览器的两个页面是一个-session-吗-不一定"><a href="#同一个浏览器的两个页面是一个-session-吗-不一定" class="headerlink" title="同一个浏览器的两个页面是一个 session 吗? 不一定"></a>同一个浏览器的两个页面是一个 session 吗? 不一定</h2><p>同一个浏览器的两个页面是不一定是一个 session 的。如果是在同一个浏览器内打开两个标签，那么这两个标签的页面是一个 session，但是用同一个浏览器打开两个不同的窗口页面的话，那么两个页面不是一个 session。</p><h2 id="浏览器打开两个标签页-localstorage-是否一样"><a href="#浏览器打开两个标签页-localstorage-是否一样" class="headerlink" title="浏览器打开两个标签页,localstorage 是否一样"></a>浏览器打开两个标签页,localstorage 是否一样</h2><p>IE、Edge localstorage 两个页签的值不一致的问题</p><p>localstorage 本是浏览器的属性，chrome 下会多个页签共享该属性值，一个变更，其他页签下取值也会取得变更后的最新值</p><p>IE、Edge 下两个页签，一个发生了变化，另外一个没有同步，经查找，需要手动对 localstorage 对象触发 change 事件，随便给某个属性设置一个值，原来的属性值也会跟着更新<br>localStorage.setItem(**,);<br>随意设置变量，只要触发 localStorge 对象就可以</p><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><p>1.用处：该方法是用来监测数据类型的一种好方法</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Undefined]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Null]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Date]</span></code></pre><p>检测原理：</p><p>Object 对象本身就有一个 toString()方法，返回的是当前对象的字符串形式，原型上的 toString()返回的才是我们真正需要的包含对象数据类型的字符串。至于 call，就是改变对象的 this 指向，当一个对象想调用另一个对象的方法，可以通过 call 或者 apply 改变其 this 指向，将其 this 指向拥有此方法的对象，就可以调用该方法了。</p><h2 id="vue-响应式原理"><a href="#vue-响应式原理" class="headerlink" title="vue 响应式原理"></a>vue 响应式原理</h2><p>vue 响应式也叫作数据双向绑定，大致原理阐述：</p><p>​ 首先我们需要通过 Object.defineProperty()方法把数据(data)设置为 getter 和 setter 的访问形式，这样我们就可以在数据被修改时在 setter 方法设置监视修改页面信息，也就是说每当数据被修改，就会触发对应的 set 方法，然后我们可以在 set 方法中去调用操作 dom 的方法。</p><p>​ 此外，如果页面有 input 用 v-model 绑定数据，我们需要在这种绑定了 data 的 input 元素上添加监听，添加 input 事件监听，每当 input 事件被触发时，就修改对应的 data。</p><h2 id="map-和-object-的区别"><a href="#map-和-object-的区别" class="headerlink" title="map 和 object 的区别"></a>map 和 object 的区别</h2><p>区别：<br>1、Map 的键可以是任意值，而 Object 的键必须是一个 String 或是 Symbol。</p><p>2、Map 中的 key 是有序的，而 Object 的键是无序的。</p><p>3、Map 的键值对个数可以轻易地通过 size 属性获取，而 Object 的键值对个数只能手动计算。</p><p>4、Map 可以直接被迭代，而 Object 不可以直接被迭代。</p><p>5、Map 在频繁增删键值对的场景下表现更好，而 Object 的效率比较差。</p><h2 id="Promise-大致的工作流程是"><a href="#Promise-大致的工作流程是" class="headerlink" title="Promise 大致的工作流程是"></a>Promise 大致的工作流程是</h2><p>创建 Promise 对象 =&gt; 进入等待处理阶段 Pending</p><p>处理完成后，切换到 Fulfilled 状态／ Rejected 状态</p><p>根据状态，执行 then 方法／执行 catch 方法 内的回调函数</p><h2 id="pinia-和-vuex-区别"><a href="#pinia-和-vuex-区别" class="headerlink" title="pinia 和 vuex 区别"></a>pinia 和 vuex 区别</h2><p>Vuex 和 Pinia 都是 Vue.js 中常用的状态管理库，用于在项目中实现集中式的状态管理。</p><p>虽然两者都可以实现对状态的管理，但是在使用上还是有一些区别：</p><p>代码规模：vuex 可以轻松地处理大型应用程序的状态管理，而是 pinia 则是更专注于小型中型的项目。</p><p>状态访问方式：在 vuex 中，我们可以通过 mapState、mapGetters、mapMutations 和 mapActions 方便地将 store 中的状态映射到组件的计算属性和方法中，而在 pinia 中，我们使用内部提供的 useStore hook 来获取 store 实例，并直接访问 store 中的状态和操作函数</p><p>API 设计：vuex 遵循了 Flux 模式中的单向数据流理念，其中包括 state（状态）、mutations（变更）和 actions（行为）等概念；pinia 则采用了更加简化 API 设计，主要包含 state 跟 getters、actions 和 mutations 这三部分内容，同时也大力推广 Typescript 使用，并且底层采用了 proxy 来优化性能</p><p>运行依赖：vuex 依赖于 vue 本身，需要引入 Vue.use(Vuex)才能在项目中使用它；而 pinia 是完全独立于 vue 的，不需要再进行任何额外操作就可以安装和使用它。</p><p>综上所述，Vuex 更适用于大型应用程序的状态管理，而 Pinia 更适用于小型中型项目，同时在 API 设计上也有着不少的差异。但两者都可以为 Vue.js 中的状态管理提供便利，并根据个人需求和喜好进行选择。</p><h2 id="什么是事件循环？"><a href="#什么是事件循环？" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h2><p>事件循环是 JavaScript 中一种异步执行机制，它的作用是协调和管理各种异步任务的执行顺序，保证 JavaScript 代码的执行顺序和预期一致。</p><p>整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；</p><p>同步任务会直接进入主线程依次执行；</p><p>异步任务会再分为宏任务(进入宏任务队列) 和 微任务(进入微任务队列)。</p><p>当主线程内的任务执行完毕（主线程为空时），会检查微任务的任务队列，如果有任务，就进入主线程全部执行，如果没有就从宏任务队列读取下一个宏任务执行；</p><p>每执行完一个宏任务就清空一次微任务队列，此过程会不断重复，这就是 Event Loop；</p><p>宏任务</p><pre class=" language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ajax<span class="token punctuation">;</span></code></pre><p>事件绑定</p><pre class=" language-js"><code class="language-js">微任务<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>后的then与<span class="token keyword">catch</span>函数<span class="token keyword">new</span> <span class="token class-name">MutaionObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span>nextTick（Nodejs）</code></pre><p>微任务和宏任务的执行顺序是先执行同步任务，先执行同步后异步，异步分为宏任务和微任务两种，异步遇到微任务先执行微任务，执行完后如果没有微任务，就执行下一个宏任务。</p><h2 id="ES6-的新特性"><a href="#ES6-的新特性" class="headerlink" title="ES6 的新特性"></a>ES6 的新特性</h2><p>1.let 和 const 声明变量的方式，取代了 var 关键字。</p><p>2.箭头函数（Arrow Function），简化了函数的书写方式。</p><p>3.模板字符串（Template String），允许在字符串中使用变量和表达式，而不需要使用字符串连接符号。</p><p>4.解构赋值（Destructuring Assignment），允许从数组和对象中提取值并赋值给变量。</p><p>5.默认参数（Default Parameter），在定义函数时可以给参数设置默认值。</p><p>6.扩展操作符（Spread Operator），可以在函数调用时展开数组或对象。</p><p>7.类（Class），引入了面向对象编程中类的概念。</p><p>8.模块化（Module），提供了一种组织代码的方式，可以将代码分割成独立的模块，方便重用和维护。</p><p>9.Promise，用于处理异步操作，避免回调地狱的问题。</p><p>10.for…of 循环，用于遍历可迭代对象（如数组、Map 和 Set）中的元素。</p><p>11.Symbol，引入了一种新的数据类型，用于创建唯一的属性键。</p><p>12.Map 和 Set，引入了两种新的数据结构，分别用于存储键值对和唯一值。</p><p>13.Proxy，允许在对象和函数调用等操作前后添加自定义的行为。</p><p>14.Reflect，提供了一组可以操作对象的内置方法，可以替代一些对象方法（如 Object.defineProperty）的实现。</p><p>Promise.allSettled，用于处理多个 Promise 的状态并返回一个包含每个 Promise 状态的数组。</p><h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>1、外形不同：箭头函数使用箭头定义，普通函数中没有。</p><p>2、 箭头函数全都是匿名函数：普通函数可以有匿名函数，也可以有具名函数</p><p>3、箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。</p><p>4、箭头函数中 this 的指向不同：在普通函数中，this 总是指向调用它的对象，如果用作构造函数，它指向创建的对象实例。</p><p>5、箭头函数不具有 arguments 对象：每一个普通函数调用后都具有一个<br>arguments 对象，用来存储实际传递的参数。但是箭头函数并没有此对象。</p><p>6、其他区别：箭头函数不具有 prototype 原型对象。箭头函数不具有 super。</p><p>箭头函数不具有 new.target</p><h2 id="vue-实现-tab-组件，使用双向数据绑定"><a href="#vue-实现-tab-组件，使用双向数据绑定" class="headerlink" title="vue 实现 tab 组件，使用双向数据绑定"></a>vue 实现 tab 组件，使用双向数据绑定</h2><p>父组件</p><pre class=" language-vue"><code class="language-vue"><template>  <my-tab v-model="activeValue" :tabList="tabList" @onTabChange="changeTab">  </my-tab></template><script>export default {  name: "fatherTab",  data() {    return {      tabList: [        { label: "标签1", value: 1 },        { label: "标签2", value: 2 },        { label: "标签3", value: 3 },      ],      activeValue: 1,    };  },  methods: {    changeTab(data) {      console.log("object :>> ", data);    },  },};</script></code></pre><p>子组件</p><pre class=" language-vue"><code class="language-vue"><template>  <div class="box">    <div class="active">      <div        class="activeBox"        v-for="(item, index) in tabList"        :key="item.value"        @click="selectedTab(index)"      >        <div class="text">          {{ item.label }}        </div>      </div>    </div>  </div></template><script>export default {  name: "MyTabs",  props: [value, tabList],  data() {    return {      activeValue: this.value,    };  },  watch: {    value: {      handler(val) {        deep: true;        this.activeValue = val.value;      },    },  },  computed: {    currentIndex() {      return this.tabList.findIndex((item) => item.value == this.value);    },  },  methods: {    selectedTab(i) {      console.log("子组件单击了");      this.$emit("onTabChange", this.tabList[i]);    },  },};</script><style></style></code></pre><p>写一个函数，用于比较两个对象是否相等</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isObjectEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> obj1Keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [ 'a', 'b' ]</span>  <span class="token keyword">const</span> obj2Keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [ 'a', 'b' ]</span>  <span class="token comment" spellcheck="true">//判断对象key个数是否相等</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1Keys<span class="token punctuation">.</span>length <span class="token operator">!==</span> obj2Keys<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//遍历对象的value值</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> obj1Keys<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// key:遍历数组的value值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> obj2<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token string">"world"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj3 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token string">"hello"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isObjectEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token comment" spellcheck="true">//   console.log(isObjectEqual(obj1, obj3)); // true</span></code></pre><h2 id="es6-与-commonjs-的区别"><a href="#es6-与-commonjs-的区别" class="headerlink" title="es6 与 commonjs 的区别"></a>es6 与 commonjs 的区别</h2><p>1.区别：<br>1、CommonJS 输出的是一个值的拷贝，ES6 输出的是值的引用；</p><p>2、CommonJS 是运行时加载，ES6 是编译时输出接口；</p><p>3、CommonJS 的 require 是同步加载模块，ES6 的 import 是异步加载，有独立模块依赖的解析阶段。</p><h2 id="JSON-parse-JSON-stringify-obj-深拷贝的问题"><a href="#JSON-parse-JSON-stringify-obj-深拷贝的问题" class="headerlink" title="JSON.parse(JSON.stringify(obj))深拷贝的问题"></a>JSON.parse(JSON.stringify(obj))深拷贝的问题</h2><p>1、如果 obj 里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。</p><p>2、如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象。</p><p>3、如果 obj 里有函数，undefined，则序列化的结果会把函数， undefined 丢失。</p><p>4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null。</p><p>5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor。</p><p>6、如果对象中存在循环引用的情况也无法正确实现深拷贝。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>    age <span class="token punctuation">:</span> <span class="token number">NaN</span><span class="token punctuation">,</span>  name<span class="token punctuation">:</span><span class="token string">"88"</span><span class="token punctuation">,</span>  isbol<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>  Reg<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'\\w+'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  err<span class="token punctuation">:</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  ubd<span class="token punctuation">:</span>undefined<span class="token punctuation">,</span>  isDate<span class="token punctuation">:</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>  fun <span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">'object :>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token keyword">let</span> newObj<span class="token operator">=</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'newObj :>> '</span><span class="token punctuation">,</span> newObj<span class="token punctuation">)</span><span class="token punctuation">;</span>newObj <span class="token punctuation">:</span><span class="token operator">></span><span class="token operator">></span>  <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null。</span>  name<span class="token punctuation">:</span> <span class="token string">'88'</span><span class="token punctuation">,</span>  isbol<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  Reg<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//有 RegExp、Error 对象，则序列化的结果将只得到空对象。</span>  err<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//有 RegExp、Error 对象，则序列化的结果将只得到空对象。</span>  isDate<span class="token punctuation">:</span> <span class="token string">'2023-07-25T23:46:27.476Z'</span> <span class="token comment" spellcheck="true">//存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。</span><span class="token punctuation">}</span></code></pre><h2 id="为什么-Hooks-不能写在条件语句或循环语句中？-为了保证执行顺序一致性"><a href="#为什么-Hooks-不能写在条件语句或循环语句中？-为了保证执行顺序一致性" class="headerlink" title="为什么 Hooks 不能写在条件语句或循环语句中？ (为了保证执行顺序一致性)"></a>为什么 Hooks 不能写在条件语句或循环语句中？ (为了保证执行顺序一致性)</h2><p>因为 React 需要保证在每次组件渲染时，Hooks 的执行顺序都是一致的。如果将 Hooks 写在循环或条件语句中，那么每次渲染时，Hooks 的执行顺序都可能会发生变化。例如，当循环重新运行时，React 将无法确定哪个 Hook 应该先运行，哪个应该后运行。这样会导致组件状态发生不可预测的变化，从而影响组件的正确性。为了解决这个问题，React 强制要求我们在函数的顶部使用 Hooks。这样可以确保每次渲染时 Hooks 的执行顺序是一致的，从而保证组件状态能够正确地更新。</p><h2 id="React-Hooks-——-useMemo-amp-useCallback-区别"><a href="#React-Hooks-——-useMemo-amp-useCallback-区别" class="headerlink" title="React Hooks —— useMemo&amp;useCallback 区别"></a>React Hooks —— useMemo&amp;useCallback 区别</h2><p>相同点：useMemo 和 useCallback——用于优化性能的 Hook 函数</p><p>不同点：useMemo 缓存数据——类似 vue 的计算属性 ，useCallback 缓存函数引用</p><p>推荐 useMemo，useCallback 不要乱用<br>因为并不是所有组件内部的函数都拿起包起来处理回归，虽然减少了堆内存的开辟，但是 useCallback 本身也有自己的处理逻辑和缓存的机制，这个也消耗时间，而 useMemo 对性能的提升很明显<br>所以 useMemo 能用则用，useCallback 能不用则不用，就算用了也不一定有好的效果</p><h2 id="跨域是存在于浏览器端还是服务器端？"><a href="#跨域是存在于浏览器端还是服务器端？" class="headerlink" title="跨域是存在于浏览器端还是服务器端？"></a>跨域是存在于浏览器端还是服务器端？</h2><p>跨域主要是浏览器行为，是客户端行为，浏览器根据策略，判断是否是跨域。服务器端，是没有跨域这种说法的，其次因为浏览器使用门槛非常低，为了防止别有用心的人攻击普通用户，所以引入跨域策略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-hooks&quot;&gt;&lt;a href=&quot;#react-hooks&quot; class=&quot;headerlink&quot; title=&quot;react hooks&quot;&gt;&lt;/a&gt;react hooks&lt;/h2&gt;&lt;p&gt;React Hooks 是从 React 16.8 版本推出的新特性</summary>
      
    
    
    
    <category term="前端面试" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端面试" scheme="https://liang996.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>forEach 如何跳出本次循环和终止循环</title>
    <link href="https://liang996.github.io/2022/120546254.html"/>
    <id>https://liang996.github.io/2022/120546254.html</id>
    <published>2022-12-05T03:59:32.000Z</published>
    <updated>2023-07-30T04:03:33.306Z</updated>
    
    <content type="html"><![CDATA[<p>通常，在 for 循环中跳出循环可以用 break 或者 continue 来跳出循环，那么这两个在 forEach 函数中好使吗，为此我们来试一试。</p><h5 id="1、forEach-跳出本次循环"><a href="#1、forEach-跳出本次循环" class="headerlink" title="1、forEach 跳出本次循环"></a>1、forEach 跳出本次循环</h5><p>可使用 return 语句跳出本次循环，执行下一次循环</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>将输出 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>，<span class="token number">3</span>不会输出</code></pre><p>可以看到，forEach 中使用 return 语句的作用只能跳出当前循环（实现了 continue 的效果），并不能跳出整个循环，没达到期待的效果，满足条件后还继续执行了循环。</p><p>在 forEach 中使用 break：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>item <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'item'</span><span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//运行结果：SyntaxError: Illegal break statement ：语法错误：非法的break语句</span></code></pre><p>直接报错了，后面的代码也没执行。</p><p>在 forEach 中使用 continue：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>item <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'item'</span><span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//打印结果：SyntaxError: Illegal continue statement: no surrounding iteration statement ：非法的continue语句：没有周围的迭代语句</span></code></pre><p>直接报错了，后面的代码也没执行。</p><h5 id="2、forEach-终止循环"><a href="#2、forEach-终止循环" class="headerlink" title="2、forEach 终止循环"></a>2、forEach 终止循环</h5><p>forEach 无法通过正常流程(如 break)终止循环，但可通过抛出异常的方式实现终止循环</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token keyword">try</span><span class="token punctuation">{</span>  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'End Loop'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message <span class="token operator">===</span> <span class="token string">'End Loop'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> e<span class="token punctuation">}</span>将只输出 <span class="token number">1</span> <span class="token number">2</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通常，在 for 循环中跳出循环可以用 break 或者 continue 来跳出循环，那么这两个在 forEach 函数中好使吗，为此我们来试一试。&lt;/p&gt;
&lt;h5 id=&quot;1、forEach-跳出本次循环&quot;&gt;&lt;a href=&quot;#1、forEach-跳出本次循环&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://liang996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>jsbreak、continue和return的区别总结</title>
    <link href="https://liang996.github.io/2022/120516197.html"/>
    <id>https://liang996.github.io/2022/120516197.html</id>
    <published>2022-12-05T03:32:43.000Z</published>
    <updated>2023-07-30T04:03:33.308Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程语法中我们会碰到 break ,continue, return 这三个常用的关键字，为此来对其知识点加以回顾学习。</p><h2 id="1-break"><a href="#1-break" class="headerlink" title="1.break"></a>1.break</h2><h4 id="break-：break-语句会使运行的程序立刻退出，包含在最内层的循环或者退出一个-switch-语句。"><a href="#break-：break-语句会使运行的程序立刻退出，包含在最内层的循环或者退出一个-switch-语句。" class="headerlink" title="break ：break 语句会使运行的程序立刻退出，包含在最内层的循环或者退出一个 switch 语句。"></a>break ：break 语句会使运行的程序立刻退出，包含在最内层的循环或者退出一个 switch 语句。</h4><p>例子 1</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//退出break所在层循环</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"j ="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//执行结果为：打印2次 j=0</span></code></pre><p>例子 2</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> num<span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span></code></pre><p>若不加 break 情况</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> num<span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span>    num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span><span class="token comment" spellcheck="true">//执行结果为：2</span></code></pre><p>由于它是用来退出循环或者 switch 语句，所以只有当它出现在这些语句时，这种形式的 break 语句才是合法的。</p><p>如果一个循环的终止条件非常复杂，那么使用 break 语句来实现某些条件比用一个循环表达式来表达所有的条件容易得多</p><h2 id="2-continue"><a href="#2-continue" class="headerlink" title="2.continue"></a>2.continue</h2><h4 id="continue：continue-语句和-break-语句相似。所不同的是，它不会终止整个循环，而是终止本次迭代，继续开始循环的一次新迭代"><a href="#continue：continue-语句和-break-语句相似。所不同的是，它不会终止整个循环，而是终止本次迭代，继续开始循环的一次新迭代" class="headerlink" title="continue：continue 语句和 break 语句相似。所不同的是，它不会终止整个循环，而是终止本次迭代，继续开始循环的一次新迭代"></a>continue：continue 语句和 break 语句相似。所不同的是，它不会终止整个循环，而是终止本次迭代，继续开始循环的一次新迭代</h4><p>continue 语句只能用在 while 语句、do/while 语句、for 语句、或者 for/in 语句的循环体内，在其它地方使用都会引起错误！</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//当i=6的时候，直接跳出本次for循环。下次继续执行。</span><span class="token comment" spellcheck="true">//输出结果：1234578910</span></code></pre><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><h4 id="return-用于指定函数的返回值，return-只能出现在函数内部。遇到-return-即终止函数内所有代码执行，包括循环，直接退出整个函数。"><a href="#return-用于指定函数的返回值，return-只能出现在函数内部。遇到-return-即终止函数内所有代码执行，包括循环，直接退出整个函数。" class="headerlink" title="return:用于指定函数的返回值，return 只能出现在函数内部。遇到 return 即终止函数内所有代码执行，包括循环，直接退出整个函数。"></a>return:用于指定函数的返回值，return 只能出现在函数内部。遇到 return 即终止函数内所有代码执行，包括循环，直接退出整个函数。</h4><p>当执行 return 语句时，即使函数主体中还有其他语句，函数执行也会停止！</p><p>js 编程语法中的 break ,continue, return 这三个常用的关键字的使用相关内容就向你介绍到这里，希望对你了解和学习 break ,continue, return 这三个常用关键字的使用有所帮助。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">testReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//终止整个函数体内代码执行，函数返回值为 1</span>      <span class="token punctuation">}</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"j ="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"函数的返回结果为："</span> <span class="token operator">+</span> <span class="token function">testReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行结果为：打印 1次 j =0; 打印一次  函数的返回结果为1</span></code></pre><p>如果在非函数内使用 return；<br>执行结果 Uncaught SyntaxError: illegal return statement(…)<br>错误意思是非法捕获的查询返回语句。<br>当执行 return 语句时, 即使函数主题中还有其他语句, 函数执行也会停止!</p><h4 id="总结：break-和-continue-为循环体内部使用，break-退出-当前循环以及当前循环内部所有循环，continue-是退出-当前循环的当前次迭代，开始下一次迭代。return-为函数返回值，终止整个函数执行。"><a href="#总结：break-和-continue-为循环体内部使用，break-退出-当前循环以及当前循环内部所有循环，continue-是退出-当前循环的当前次迭代，开始下一次迭代。return-为函数返回值，终止整个函数执行。" class="headerlink" title="总结：break 和 continue 为循环体内部使用，break 退出 当前循环以及当前循环内部所有循环，continue 是退出 当前循环的当前次迭代，开始下一次迭代。return 为函数返回值，终止整个函数执行。"></a>总结：break 和 continue 为循环体内部使用，break 退出 当前循环以及当前循环内部所有循环，continue 是退出 当前循环的当前次迭代，开始下一次迭代。return 为函数返回值，终止整个函数执行。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象编程语法中我们会碰到 break ,continue, return 这三个常用的关键字，为此来对其知识点加以回顾学习。&lt;/p&gt;
&lt;h2 id=&quot;1-break&quot;&gt;&lt;a href=&quot;#1-break&quot; class=&quot;headerlink&quot; title=&quot;1.brea</summary>
      
    
    
    
    <category term="前端" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://liang996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浅析vue-router动态路由传参的区别</title>
    <link href="https://liang996.github.io/2022/112314202.html"/>
    <id>https://liang996.github.io/2022/112314202.html</id>
    <published>2022-11-23T05:51:04.000Z</published>
    <updated>2022-11-23T06:07:08.682Z</updated>
    
    <content type="html"><![CDATA[<p>vue-router 动态路由传参常见方法有 query 和 params，今天我来和大家谈谈两者区别。</p><h2 id="1-用法不同：-query-用-path-来引入，params-只能用-name-来传递，不能使用-path"><a href="#1-用法不同：-query-用-path-来引入，params-只能用-name-来传递，不能使用-path" class="headerlink" title="1.用法不同： query 用 path 来引入，params 只能用 name 来传递，不能使用 path"></a>1.用法不同： query 用 path 来引入，params 只能用 name 来传递，不能使用 path</h2><p>query 方式传参和接收参数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//传参</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        path<span class="token punctuation">:</span><span class="token string">'/xxx'</span>        query<span class="token punctuation">:</span><span class="token punctuation">{</span>          id<span class="token punctuation">:</span>id        <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//接收参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id</code></pre><p>传参是 this.$router，接收参数是this.$route</p><p>$router为VueRouter实例。想要导航跳不同URL可以使用$this.router 的方法（push、go、replace）去切换路由</p><p>$route 是当前 router 跳转对象。里面可以获取 name、path、query、params 等相关信息</p><p>params 方式传参和接收参数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//传参</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        name<span class="token punctuation">:</span><span class="token string">'/xxx'</span>        params<span class="token punctuation">:</span><span class="token punctuation">{</span>          id<span class="token punctuation">:</span>id        <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//接收参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id</code></pre><p>params 传参里面只能是 name，不能是 path</p><p>params 只能用 name 来引入路由，如果这里写成了 path，接收参数页面会是 undefined</p><h2 id="展示效果：query-更像-ajax-中-get-请求（会在地址栏显示参数），而-params-更像-post-方式传递（不会在地址栏显示参数）"><a href="#展示效果：query-更像-ajax-中-get-请求（会在地址栏显示参数），而-params-更像-post-方式传递（不会在地址栏显示参数）" class="headerlink" title="展示效果：query 更像 ajax 中 get 请求（会在地址栏显示参数），而 params 更像 post 方式传递（不会在地址栏显示参数）"></a>展示效果：query 更像 ajax 中 get 请求（会在地址栏显示参数），而 params 更像 post 方式传递（不会在地址栏显示参数）</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//query展现效果</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>detail<span class="token operator">?</span>type<span class="token operator">=</span><span class="token number">0</span><span class="token operator">&amp;</span>detail<span class="token operator">=</span>哈哈<span class="token comment" spellcheck="true">// params展现效果</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span>detail</code></pre><p>query 跟 params，前者在浏览器地址栏中显示参数，后者则不显示。</p><h2 id="3-刷新是否丢失数据"><a href="#3-刷新是否丢失数据" class="headerlink" title="3.刷新是否丢失数据"></a>3.刷新是否丢失数据</h2><p>query 刷新不会丢失 query 里面的数据<br>params 刷新会丢失 params 里面的数据</p><p>总结</p><p>以上所述是给大家介绍的 vue-router 中 params 和 query 的区别，希望对大家有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vue-router 动态路由传参常见方法有 query 和 params，今天我来和大家谈谈两者区别。&lt;/p&gt;
&lt;h2 id=&quot;1-用法不同：-query-用-path-来引入，params-只能用-name-来传递，不能使用-path&quot;&gt;&lt;a href=&quot;#1-用法不同</summary>
      
    
    
    
    <category term="vue" scheme="https://liang996.github.io/categories/vue/"/>
    
    
    <category term="vue-router" scheme="https://liang996.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>vue3学习总结</title>
    <link href="https://liang996.github.io/2022/112328738.html"/>
    <id>https://liang996.github.io/2022/112328738.html</id>
    <published>2022-11-23T05:44:32.000Z</published>
    <updated>2022-11-23T06:10:33.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-学习总结"><a href="#Vue3-学习总结" class="headerlink" title="Vue3 学习总结"></a>Vue3 学习总结</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px"><h2 id="1-Vue3-简介"><a href="#1-Vue3-简介" class="headerlink" title="1.Vue3 简介"></a>1.Vue3 简介</h2><ul><li>2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece（海贼王）</li><li>耗时 2 年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个 RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次 PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99 位贡献者</a></li><li>github 上的 tags 地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3-带来了什么"><a href="#2-Vue3-带来了什么" class="headerlink" title="2.Vue3 带来了什么"></a>2.Vue3 带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少 41%</p></li><li><p>初次渲染快 55%, 更新渲染快 133%</p></li><li><p>内存减少 54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用 Proxy 代替 defineProperty 实现响应式</p></li><li><p>重写虚拟 DOM 的实现和 Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱-TypeScript"><a href="#3-拥抱-TypeScript" class="headerlink" title="3.拥抱 TypeScript"></a>3.拥抱 TypeScript</h3><ul><li>Vue3 可以更好的支持 TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合 API）</p><ul><li>setup 配置</li><li>ref 与 reactive</li><li>watch 与 watchEffect</li><li>provide 与 inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment</li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除 keyCode 支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建-Vue3-0-工程"><a href="#一、创建-Vue3-0-工程" class="headerlink" title="一、创建 Vue3.0 工程"></a>一、创建 Vue3.0 工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span>vue --version<span class="token comment" spellcheck="true">## 安装或者升级你的@vue/cli</span><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli<span class="token comment" spellcheck="true">## 创建</span>vue create vue_test<span class="token comment" spellcheck="true">## 启动</span><span class="token function">cd</span> vue_test<span class="token function">npm</span> run serve</code></pre><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite 官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是 vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite 构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left"><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px"></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## 创建工程</span><span class="token function">npm</span> init vite-app <span class="token operator">&lt;</span>project-name<span class="token operator">></span><span class="token comment" spellcheck="true">## 进入工程目录</span><span class="token function">cd</span> <span class="token operator">&lt;</span>project-name<span class="token operator">></span><span class="token comment" spellcheck="true">## 安装依赖</span><span class="token function">npm</span> <span class="token function">install</span><span class="token comment" spellcheck="true">## 运行</span><span class="token function">npm</span> run dev</code></pre><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的-setup"><a href="#1-拉开序幕的-setup" class="headerlink" title="1.拉开序幕的 setup"></a>1.拉开序幕的 setup</h2><ol><li>理解：Vue3.0 中一个新的配置项，值为一个函数。</li><li>setup 是所有<strong style="color:#DD5145">Composition API（组合 API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在 setup 中。</li><li>setup 函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与 Vue2.x 配置混用<ul><li>Vue2.x 配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup 中的属性、方法。</li><li>但在 setup 中<strong style="color:#DD5145">不能访问到</strong>Vue2.x 配置（data、methos、computed…）。</li><li>如果有重名, setup 优先。</li></ul></li><li>setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）</li></ol></li></ol><h2 id="2-ref-函数"><a href="#2-ref-函数" class="headerlink" title="2.ref 函数"></a>2.ref 函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code><ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference 对象，简称 ref 对象）</strong>。</li><li>JS 中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了 Vue3.0 中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive-函数"><a href="#3-reactive-函数" class="headerlink" title="3.reactive 函数"></a>3.reactive 函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy 的实例对象，简称 proxy 对象）</strong></li><li>reactive 定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0-中的响应式原理"><a href="#4-Vue3-0-中的响应式原理" class="headerlink" title="4.Vue3.0 中的响应式原理"></a>4.Vue3.0 中的响应式原理</h2><h3 id="vue2-x-的响应式"><a href="#vue2-x-的响应式" class="headerlink" title="vue2.x 的响应式"></a>vue2.x 的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0-的响应式"><a href="#Vue3-0-的响应式" class="headerlink" title="Vue3.0 的响应式"></a>Vue3.0 的响应式</h3><ul><li><p>实现原理:</p><ul><li><p>通过 Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过 Reflect（反射）: 对源对象的属性进行操作。</p></li><li><p>MDN 文档中描述的 Proxy 与 Reflect：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 拦截读取属性值</span>  <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 拦截设置属性值或添加新属性</span>  <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 拦截删除属性</span>  <span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"tom"</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul></li></ul><h2 id="5-reactive-对比-ref"><a href="#5-reactive-对比-ref" class="headerlink" title="5.reactive 对比 ref"></a>5.reactive 对比 ref</h2><ul><li>从定义数据角度对比：<ul><li>ref 用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive 用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref 也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref 通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive 通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref 定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive 定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup-的两个注意点"><a href="#6-setup-的两个注意点" class="headerlink" title="6.setup 的两个注意点"></a>6.setup 的两个注意点</h2><ul><li>setup 执行的时机<ul><li>在 beforeCreate 之前执行一次，this 是 undefined。</li></ul></li><li>setup 的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed-函数"><a href="#1-computed-函数" class="headerlink" title="1.computed 函数"></a>1.computed 函数</h3><ul><li><p>与 Vue2.x 中 computed 配置功能一致</p></li><li><p>写法</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>computed<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span>    <span class="token comment" spellcheck="true">//计算属性——简写</span>    <span class="token keyword">let</span> fullName <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">return</span> person<span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>lastName    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//计算属性——完整</span>    <span class="token keyword">let</span> fullName <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> person<span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> person<span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> nameArr <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>            person<span class="token punctuation">.</span>firstName <span class="token operator">=</span> nameArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            person<span class="token punctuation">.</span>lastName <span class="token operator">=</span> nameArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="2-watch-函数"><a href="#2-watch-函数" class="headerlink" title="2.watch 函数"></a>2.watch 函数</h3><ul><li><p>与 Vue2.x 中 watch 配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。</li><li>监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//情况一：监视ref定义的响应式数据</span><span class="token function">watch</span><span class="token punctuation">(</span>  sum<span class="token punctuation">,</span>  <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"sum变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> immediate<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//情况二：监视多个ref定义的响应式数据</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sum<span class="token punctuation">,</span> msg<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"sum或msg变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 情况三：监视reactive定义的响应式数据            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */</span><span class="token function">watch</span><span class="token punctuation">(</span>  person<span class="token punctuation">,</span>  <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"person变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deep<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此处的deep配置不再奏效</span><span class="token comment" spellcheck="true">//情况四：监视reactive定义的响应式数据中的某个属性</span><span class="token function">watch</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> person<span class="token punctuation">.</span>job<span class="token punctuation">,</span>  <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"person的job变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//情况五：监视reactive定义的响应式数据中的某些属性</span><span class="token function">watch</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> person<span class="token punctuation">.</span>job<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> person<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"person的job变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//特殊情况</span><span class="token function">watch</span><span class="token punctuation">(</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> person<span class="token punctuation">.</span>job<span class="token punctuation">,</span>  <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"person的job变化了"</span><span class="token punctuation">,</span> newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></code></pre></li></ul><h3 id="3-watchEffect-函数"><a href="#3-watchEffect-函数" class="headerlink" title="3.watchEffect 函数"></a>3.watchEffect 函数</h3><ul><li><p>watch 的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect 有点像 computed：</p><ul><li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> x1 <span class="token operator">=</span> sum<span class="token punctuation">.</span>value<span class="token punctuation">;</span>  <span class="token keyword">const</span> x2 <span class="token operator">=</span> person<span class="token punctuation">.</span>age<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"watchEffect配置的回调执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px"></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px"></div><p>1</p><ul><li>Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code>&nbsp;==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义-hook-函数"><a href="#9-自定义-hook-函数" class="headerlink" title="9.自定义 hook 函数"></a>9.自定义 hook 函数</h2><ul><li><p>什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。</p></li><li><p>类似于 vue2.x 中的 mixin。</p></li><li><p>自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,'name')</code></p></li><li><p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre class=" language-vue"><code class="language-vue"><template>  <input type="text" v-model="keyword" />  <h3>{{ keyword }}</h3></template><script>import { ref, customRef } from "vue";export default {  name: "Demo",  setup() {    // let keyword = ref('hello') //使用Vue准备好的内置ref    //自定义一个myRef    function myRef(value, delay) {      let timer;      //通过customRef去实现自定义      return customRef((track, trigger) => {        return {          get() {            track(); //告诉Vue这个value值是需要被“追踪”的            return value;          },          set(newValue) {            clearTimeout(timer);            timer = setTimeout(() => {              value = newValue;              trigger(); //告诉Vue去更新界面            }, delay);          },        };      });    }    let keyword = myRef("hello", 500); //使用程序员自定义的ref    return {      keyword,    };  },};</script></code></pre></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px"><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre class=" language-js"><code class="language-js"><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token keyword">let</span> car <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'奔驰'</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token string">'40万'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">provide</span><span class="token punctuation">(</span><span class="token string">'car'</span><span class="token punctuation">,</span>car<span class="token punctuation">)</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre></li><li><p>后代组件中：</p><pre class=" language-js"><code class="language-js"><span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span>context<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token keyword">const</span> car <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span><span class="token string">'car'</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>car<span class="token punctuation">}</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left"></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left"> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:360px"></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在 Vue2 中: 组件必须有一个根标签</li><li>在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是 Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件 html 结构</strong>移动到指定位置的技术。</p><pre class=" language-vue"><code class="language-vue"><teleport to="移动位置">    <div v-if="isShow" class="mask">        <div class="dialog">            <h3>我是一个弹窗</h3>            <button @click="isShow = false">关闭弹窗</button>        </div>    </div></teleport></code></pre></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> defineAsyncComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./components/Child.vue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre class=" language-vue"><code class="language-vue"><template>  <div class="app">    <h3>我是App组件</h3>    <Suspense>      <template v-slot:default>        <Child />      </template>      <template v-slot:fallback>        <h3>加载中.....</h3>      </template>    </Suspense>  </div></template></code></pre></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局-API-的转移"><a href="#1-全局-API-的转移" class="headerlink" title="1.全局 API 的转移"></a>1.全局 API 的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//注册全局组件</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyButton'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;button @click="count++">Clicked {{ count }} times.&lt;/button>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注册全局指令</span>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  inserted<span class="token punctuation">:</span> el <span class="token operator">=</span><span class="token operator">></span> el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>Vue3.0 中对这些 API 做出了调整：</p><ul><li><p>将全局的 API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data 选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x 写法</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.v-enter</span>,<span class="token class">.v-leave-to</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.v-leave</span>,<span class="token class">.v-enter-to</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Vue3.x 写法</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.v-enter-from</span>,<span class="token class">.v-leave-to</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.v-leave-from</span>,<span class="token class">.v-enter-to</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode 作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre class=" language-vue"><code class="language-vue"><my-component  v-on:close="handleComponentEvent"  v-on:click="handleNativeClickEvent"/></code></pre></li><li><p>子组件中声明自定义事件</p><pre class=" language-vue"><code class="language-vue"><script>export default {  emits: ["close"],};</script></code></pre></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-学习总结&quot;&gt;&lt;a href=&quot;#Vue3-学习总结&quot; class=&quot;headerlink&quot; title=&quot;Vue3 学习总结&quot;&gt;&lt;/a&gt;Vue3 学习总结&lt;/h1&gt;&lt;img src=&quot;https://user-images.githubuserconte</summary>
      
    
    
    
    <category term="vue3" scheme="https://liang996.github.io/categories/vue3/"/>
    
    
    <category term="vue3" scheme="https://liang996.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>js-代码简洁之道</title>
    <link href="https://liang996.github.io/2022/110437296.html"/>
    <id>https://liang996.github.io/2022/110437296.html</id>
    <published>2022-11-04T08:56:36.000Z</published>
    <updated>2022-12-05T06:38:34.684Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是跟大家分享了 javascript 简写常用技巧,三人行，必有我师，欢迎多补充，指教！</p><h2 id="1-空-null-undefined-验证"><a href="#1-空-null-undefined-验证" class="headerlink" title="1. 空(null, undefined)验证"></a>1. 空(null, undefined)验证</h2><p>null 和 undefined 的空置检查当这个数据已知是 null 或者是 undefined 可以这样写</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> a <span class="token operator">!==</span> undefined <span class="token operator">||</span> a <span class="token operator">!==</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// logic</span>  <span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以简写为：</p><p>1.</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>还可以基于 ?? 操作符 如果左边的值为 null 或 undefined 就返回右边的值，如果左边的值为默认值就返回左边的值</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"default"</span><span class="token punctuation">;</span></code></pre><h2 id="2-判断值是否存在"><a href="#2-判断值是否存在" class="headerlink" title="2.判断值是否存在"></a>2.判断值是否存在</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 存在</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 不存在</span></code></pre><h2 id="3-将字符串转数字"><a href="#3-将字符串转数字" class="headerlink" title="3.将字符串转数字"></a>3.将字符串转数字</h2><pre class=" language-js"><code class="language-js"> <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'123'</span> <span class="token comment" spellcheck="true">//方法1.parseInt()解析一个字符串并返回一个整数。允许空格。仅返回第一个数字。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  123</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token comment" spellcheck="true">//方法2.Number()可用于将 JavaScript 变量转换为数字。我们可以用它来转换字符串太数字。</span><span class="token function">Number</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123;</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token comment" spellcheck="true">//方法3. 使用一元运算符 (+)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">+</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 123;</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token comment" spellcheck="true">//方法4. 乘以数字</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 123;</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token comment" spellcheck="true">//方法5.双波浪号 (~~) 运算符</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123</span></code></pre><h2 id="4-运用三元运算符，来简化-if-true…else-条件的写法"><a href="#4-运用三元运算符，来简化-if-true…else-条件的写法" class="headerlink" title="4. 运用三元运算符，来简化 if true…else 条件的写法"></a>4. 运用三元运算符，来简化 if true…else 条件的写法</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> test<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  test <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  test <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简化操作</span>test <span class="token operator">=</span> x <span class="token operator">></span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><h2 id="5-if-判断输入非空"><a href="#5-if-判断输入非空" class="headerlink" title="5.if 判断输入非空"></a>5.if 判断输入非空</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> undefined <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">...</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token operator">?</span><span class="token operator">?</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></code></pre><p>补充：</p><ol><li><p>?? 是聚合运算符，又称为空值合并运算符，它只判断 null 和 undefined，如果左值为 null 或 undefined，就返回右值。默认返回左值。</p></li><li><p>!!将任何变量转换成 boolean</p></li></ol><h2 id="6-判断对象的某些属性是否存在，可选项"><a href="#6-判断对象的某些属性是否存在，可选项" class="headerlink" title="6.判断对象的某些属性是否存在，可选项 .?"></a>6.判断对象的某些属性是否存在，可选项 .?</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">5</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//非简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>obj<span class="token punctuation">.</span>a <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">!</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">!</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>obj1<span class="token punctuation">.</span>a<span class="token operator">?</span><span class="token punctuation">.</span>b<span class="token operator">?</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//属性不存在会返回undefined</span></code></pre><h2 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h2><p>描述：如果属性名与 key 名相同</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="9-合并数组数据"><a href="#9-合并数组数据" class="headerlink" title="9.合并数组数据"></a>9.合并数组数据</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,1,5,6]</span><span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,5,6]</span></code></pre><h2 id="10-合并对象数据"><a href="#10-合并对象数据" class="headerlink" title="10.合并对象数据"></a>10.合并对象数据</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  b<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:1}</span><span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj1<span class="token punctuation">,</span> <span class="token operator">...</span>obj2 <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:1}</span></code></pre><h2 id="11-判断条件后给对象添加属性"><a href="#11-判断条件后给对象添加属性" class="headerlink" title="11.判断条件后给对象添加属性"></a>11.判断条件后给对象添加属性</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"obj1"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> obj2<span class="token punctuation">:</span> <span class="token string">"obj2"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> obj1<span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简化操作</span><span class="token keyword">const</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>  obj2<span class="token punctuation">:</span> <span class="token string">"obj2"</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">(</span>condition <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"obj1"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="12-过滤唯一值"><a href="#12-过滤唯一值" class="headerlink" title="12.过滤唯一值"></a>12.过滤唯一值</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 简化操作1</span><span class="token keyword">const</span> uniqueArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 简化操作2</span><span class="token keyword">const</span> uniqueArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>uniqueArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[ 1, 2, 3, 5 ]</span></code></pre><h2 id="13-字符串拼接"><a href="#13-字符串拼接" class="headerlink" title="13.字符串拼接"></a>13.字符串拼接</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token string">"Frank"</span><span class="token punctuation">,</span>  last <span class="token operator">=</span> <span class="token string">"Fang"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">let</span> welcome <span class="token operator">=</span> <span class="token string">"You got a missed call from "</span> <span class="token operator">+</span> first <span class="token operator">+</span> <span class="token string">" at "</span> <span class="token operator">+</span> last<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>welcome<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 简化版</span>welcome <span class="token operator">=</span> <span class="token template-string"><span class="token string">`You have logged in as </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>first<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>last<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>welcome<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="14-三元判断简写"><a href="#14-三元判断简写" class="headerlink" title="14.三元判断简写"></a>14.三元判断简写</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> marks <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span><span class="token keyword">let</span> result<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>marks <span class="token operator">>=</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token string">"Pass"</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token string">"Fail"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">let</span> result <span class="token operator">=</span> marks <span class="token operator">>=</span> <span class="token number">30</span> <span class="token operator">?</span> <span class="token string">"Pass"</span> <span class="token punctuation">:</span> <span class="token string">"Fail"</span><span class="token punctuation">;</span></code></pre><ul><li>补充：多重三元玩法</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span><span class="token keyword">let</span> demo <span class="token operator">=</span> x <span class="token operator">></span> <span class="token number">100</span> <span class="token operator">?</span> <span class="token string">"100"</span> <span class="token punctuation">:</span> x <span class="token operator">&lt;</span> <span class="token number">50</span> <span class="token operator">?</span> <span class="token string">"50"</span> <span class="token punctuation">:</span> <span class="token string">"50 到 100之间"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "50 到 100之间"</span></code></pre><h2 id="15-key-value-简化-switch"><a href="#15-key-value-简化-switch" class="headerlink" title="15:key-value 简化 switch"></a>15:key-value 简化 switch</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// And so on...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token number">1</span><span class="token punctuation">:</span> test1<span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">:</span> test2<span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">:</span> test<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span>anything<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>anything<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="16-用-key-value-简化-if…else…"><a href="#16-用-key-value-简化-if…else…" class="headerlink" title="16.用 key-value 简化 if…else…"></a>16.用 key-value 简化 if…else…</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"test1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"test2"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"test3"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">"test4"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Invalid value "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">var</span> types <span class="token operator">=</span> <span class="token punctuation">{</span>  test1<span class="token punctuation">:</span> test1<span class="token punctuation">,</span>  test2<span class="token punctuation">:</span> test2<span class="token punctuation">,</span>  test3<span class="token punctuation">:</span> test3<span class="token punctuation">,</span>  test4<span class="token punctuation">:</span> test4<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> func <span class="token operator">=</span> types<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">!</span>func <span class="token operator">&amp;&amp;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Invalid value "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="17-多条件检查（含有多个条件的-if-语句）"><a href="#17-多条件检查（含有多个条件的-if-语句）" class="headerlink" title="17.多条件检查（含有多个条件的 if 语句）"></a>17.多条件检查（含有多个条件的 if 语句）</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token string">"one"</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token string">"two"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Execute some code</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简化版 1:使用indexOf来查找</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Execute some code</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简化版 2:使用includes来判断是否包含</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Execute some code</span><span class="token punctuation">}</span></code></pre><h2 id="18。判断变量是否存在的缩写法"><a href="#18。判断变量是否存在的缩写法" class="headerlink" title="18。判断变量是否存在的缩写法"></a>18。判断变量是否存在的缩写法</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>test1 <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>test1 <span class="token operator">!==</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>test1 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//  以上三种情况都实用</span><span class="token keyword">if</span> <span class="token punctuation">(</span>test1<span class="token punctuation">)</span></code></pre><h2 id="19-与-amp-amp-短路运算"><a href="#19-与-amp-amp-短路运算" class="headerlink" title="19. 与 (&amp;&amp;) 短路运算"></a>19. 与 (&amp;&amp;) 短路运算</h2><p>如果你只有当某个变量为 true 时调用一个函数，那么你可以使用与 (&amp;&amp;)短路形式书写。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isLoggedin<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">goToHomepage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span>isLoggedin <span class="token operator">&amp;&amp;</span> <span class="token function">goToHomepage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="20-交换两个变量"><a href="#20-交换两个变量" class="headerlink" title="20.交换两个变量"></a>20.交换两个变量</h2><p>为了交换两个变量，我们通常使用第三个变量。我们可以使用数组解构赋值来交换两个变量。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>  y <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">const</span> temp <span class="token operator">=</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> y<span class="token punctuation">;</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//简化版</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h2 id="21-赋值运算符缩写法"><a href="#21-赋值运算符缩写法" class="headerlink" title="21.赋值运算符缩写法"></a>21.赋值运算符缩写法</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span>test1 <span class="token operator">=</span> test1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>test2 <span class="token operator">=</span> test2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>test3 <span class="token operator">=</span> test3 <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//简化版</span>test1<span class="token operator">++</span><span class="token punctuation">;</span>test2<span class="token operator">--</span><span class="token punctuation">;</span>test3 <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre><h2 id="22-使用默认参数代替短路或条件"><a href="#22-使用默认参数代替短路或条件" class="headerlink" title="22.使用默认参数代替短路或条件"></a>22.使用默认参数代替短路或条件</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>test1<span class="token punctuation">,</span> test2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>test1 <span class="token operator">===</span> undefined<span class="token punctuation">)</span> test1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>test2 <span class="token operator">===</span> undefined<span class="token punctuation">)</span> test2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> test1 <span class="token operator">+</span> test2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span>add <span class="token operator">=</span> <span class="token punctuation">(</span>test1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> test2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> test1 <span class="token operator">+</span> test2<span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//output: 3</span></code></pre><h2 id="23-中可以放入任意的-JavaScript-表达式"><a href="#23-中可以放入任意的-JavaScript-表达式" class="headerlink" title="23.${}中可以放入任意的 JavaScript 表达式"></a>23.${}中可以放入任意的 JavaScript 表达式</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token punctuation">;</span><span class="token keyword">const</span> score <span class="token operator">=</span> <span class="token number">59</span><span class="token punctuation">;</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的考试成绩及格`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的考试成绩不及格`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token punctuation">;</span><span class="token keyword">const</span> score <span class="token operator">=</span> <span class="token number">59</span><span class="token punctuation">;</span><span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>score <span class="token operator">></span> <span class="token number">60</span> <span class="token operator">?</span> <span class="token string">"的考试成绩及格"</span> <span class="token punctuation">:</span> <span class="token string">"的考试成绩不及格"</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span></code></pre><h2 id="24-重复一个字符串多次-repeat"><a href="#24-重复一个字符串多次-repeat" class="headerlink" title="24.重复一个字符串多次(repeat)"></a>24.重复一个字符串多次(repeat)</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  str <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"Hello "</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Hello Hello Hello Hello Hello</span><span class="token comment" spellcheck="true">//简化版</span><span class="token string">"Hello "</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="25-找出数组中的最大和最小数字"><a href="#25-找出数组中的最大和最小数字" class="headerlink" title="25. 找出数组中的最大和最小数字"></a>25. 找出数组中的最大和最小数字</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 15</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span class="token comment" spellcheck="true">//或</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 15</span>Math<span class="token punctuation">.</span>min<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><h2 id="26-过滤无效值"><a href="#26-过滤无效值" class="headerlink" title="26.过滤无效值"></a>26.过滤无效值</h2><p>如果要过滤数组中的 false,null,0,undefined,NaN,”” 等值，可以这样做：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="27-通过条件判断给变量赋值布尔值的正确姿势"><a href="#27-通过条件判断给变量赋值布尔值的正确姿势" class="headerlink" title="27.通过条件判断给变量赋值布尔值的正确姿势"></a>27.通过条件判断给变量赋值布尔值的正确姿势</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span>b <span class="token operator">=</span> a <span class="token operator">===</span> <span class="token string">"a"</span><span class="token punctuation">;</span></code></pre><h2 id="28-在-if-中判断数组长度不为零的正确姿势"><a href="#28-在-if-中判断数组长度不为零的正确姿势" class="headerlink" title="28.在 if 中判断数组长度不为零的正确姿势"></a>28.在 if 中判断数组长度不为零的正确姿势</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo</span><span class="token punctuation">}</span></code></pre><h2 id="29-在-if-中判断数组长度为零的正确姿势"><a href="#29-在-if-中判断数组长度为零的正确姿势" class="headerlink" title="29.在 if 中判断数组长度为零的正确姿势"></a>29.在 if 中判断数组长度为零的正确姿势</h2><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//未简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo</span><span class="token punctuation">}</span></code></pre><h2 id="30-使用-Object-values-快速获取对象键值"><a href="#30-使用-Object-values-快速获取对象键值" class="headerlink" title="30.使用 Object.values 快速获取对象键值"></a>30.使用 Object.values 快速获取对象键值</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未简化版1</span><span class="token keyword">let</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//简化版</span><span class="token keyword">let</span> values <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2]</span></code></pre><ul><li>补充：for of 和 for in 区别</li></ul><ol><li><p>for in 和 for of 都可以循环数组，for in 输出的是数组的index下标，而for of 输出的是数组的每一项的值。</p></li><li><p>for in 可以遍历对象，for of 不能遍历对象，只能遍历带有iterator(迭代器)接口的，例如Set,Map,String,Array</p></li><li><p>for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的属性，以及原型链上的属性。</p></li></ol><ul><li>补充：JavaScript 中 forEach 如何退出循环</li></ul><p>JavaScript 中 forEach 循环，break 与 return 都是无法跳出循环，需要使用抛出异常的方式跳出循环</p><pre class=" language-js"><code class="language-js"><span class="token keyword">try</span> <span class="token punctuation">{</span>  BarCodeList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lst<span class="token punctuation">.</span>SNO <span class="token operator">==</span> item<span class="token punctuation">.</span>SNO<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//抛出异常，跳出循环</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"EndIterative"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>message <span class="token operator">!=</span> <span class="token string">"EndIterative"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mui<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"数据获取异常请重试!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章主要是跟大家分享了 javascript 简写常用技巧,三人行，必有我师，欢迎多补充，指教！&lt;/p&gt;
&lt;h2 id=&quot;1-空-null-undefined-验证&quot;&gt;&lt;a href=&quot;#1-空-null-undefined-验证&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://liang996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于js多次点击触发定时器越走越快的问题</title>
    <link href="https://liang996.github.io/2022/092828398.html"/>
    <id>https://liang996.github.io/2022/092828398.html</id>
    <published>2022-09-28T05:57:07.000Z</published>
    <updated>2022-09-28T06:28:13.691Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目有一个挑战答题的需求，10 道题目，每道题要在 45s 内完成，初次答题的时候没问题，每当我点下一题的时候，倒计时会越老越快，为了搞懂这个问题，专门记录总结下来。</p><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p><code>定义</code><br>setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。</p><p><code>语法</code></p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> millisec<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>参数</code>：<br>code：必需。要调用的函数后要执行的 JavaScript 代码串。<br>millisec： 必需。在执行代码前需等待的毫秒数。</p><p><code>提示</code><br>setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。</p><h2 id="setTimeout-的用法"><a href="#setTimeout-的用法" class="headerlink" title="setTimeout()的用法"></a>setTimeout()的用法</h2><pre class=" language-js"><code class="language-js"> <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>  <span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>head<span class="token operator">></span>            <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>script<span class="token operator">></span>                   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"alert('hello')"</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>       <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>     <span class="token operator">&lt;</span>body<span class="token operator">></span>     <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><p>页面会在停留 2 秒之后弹出对话框,注意 setTimeout 不会自动重复执行！</p><p>当然，setTimeout 也可以执行 function，还可以不断重复执行！</p><h2 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout()"></a>clearTimeout()</h2><p>要使用 clearTimeout()，需要我们设定 setTimeout()时， 给予这 setTimeout()一个名称, 这名称就是 timeoutID ，我们叫停时，就是用这 timeoutID 来叫停</p><pre class=" language-js"><code class="language-js">   <span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>    <span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>head<span class="token operator">></span>              <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>              <span class="token operator">&lt;</span>script<span class="token operator">></span>                    <span class="token keyword">var</span> timeId<span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">"alert('hello')"</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeId<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>       <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>      <span class="token operator">&lt;</span>body<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h2><p>setInterval()方法可按照指定的周期来调用函数或者计算表达式（以毫秒为单位）</p><p>语法：</p><pre class=" language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span>函数表达式，毫秒数<span class="token punctuation">)</span>；</code></pre><p>setInterval()会不停的调用函数，直到 clearInterval()被调用或者窗口被关闭，由 setInterval()返回的 ID 值可用作 clearInterval()方法的参数。</p><h2 id="setInterval-的用法"><a href="#setInterval-的用法" class="headerlink" title="setInterval 的用法"></a>setInterval 的用法</h2><p>每 60 秒执行 myFunction()一次</p><pre class=" language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token string">"myFunction()"</span><span class="token punctuation">,</span><span class="token number">60000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>funcition <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">’myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>’<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a>clearInterval()</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> helloFun（） <span class="token punctuation">{</span>trace（“Hello！”）<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> myInterval<span class="token operator">=</span> setInterval（helloFun，<span class="token number">2000</span>）<span class="token punctuation">;</span>clearInterval（myInterval）<span class="token punctuation">;</span></code></pre><p>回到正题，在来说一说遇到的问题，当定时器使用 setInterval()时,setInterva() 会执行多次 setTimeout() 只会执行一次,由于 setTimeout() 只会执行一次，所以不会出现越走越快的问题；那么这个问题就只讨论 setInterval() 的情况。</p><h5 id="解决-setInterval-定时器越走越快的问题"><a href="#解决-setInterval-定时器越走越快的问题" class="headerlink" title="解决 setInterval()定时器越走越快的问题"></a>解决 setInterval()定时器越走越快的问题</h5><pre class=" language-js"><code class="language-js">      <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每次调用时先的定时器</span>      <span class="token keyword">const</span> TIME_COUNT <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> TIME_COUNT<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> TIME_COUNT<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//限制倒计时区间</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删除定时器</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近项目有一个挑战答题的需求，10 道题目，每道题要在 45s 内完成，初次答题的时候没问题，每当我点下一题的时候，倒计时会越老越快，为了搞懂这个问题，专门记录总结下来。&lt;/p&gt;
&lt;h2 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeout&quot; class</summary>
      
    
    
    
    <category term="js" scheme="https://liang996.github.io/categories/js/"/>
    
    
    <category term="js" scheme="https://liang996.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>uniapp实现图片上传,图片预览，录音及录音文件上传功能</title>
    <link href="https://liang996.github.io/2022/092845745.html"/>
    <id>https://liang996.github.io/2022/092845745.html</id>
    <published>2022-09-28T05:31:30.000Z</published>
    <updated>2022-09-28T05:40:57.533Z</updated>
    
    <content type="html"><![CDATA[<p>##</p><p>最近开发 uniapp 小程序，遇到了项目上的开发任务，于是就记录在此，作为经验总结</p><h2 id="图片的上传和预览"><a href="#图片的上传和预览" class="headerlink" title="图片的上传和预览"></a>图片的上传和预览</h2><p>上传：uni.chooseImage(OBJECT)<br>预览：uni.previewImage(OBJECT)</p><h2 id="录音上传"><a href="#录音上传" class="headerlink" title="录音上传"></a>录音上传</h2><p>根据 uniapp 官网提供的 uni.uploadFile(OBJECT) API 来实现录音文件上传功能，具体 OBJECT 参数说明详见链接: uni.uploadFile(OBJECT).</p><h2 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h2><p>主要根据 uniapp 官网提供的 uni.getRecorderManager() API 来实现录音功能，具体代码详见 uniapp 官网链接: uni.getRecorderManager().<br>注：APP 端暂不支持暂停和继续录音功能</p><h2 id="录音上传-1"><a href="#录音上传-1" class="headerlink" title="录音上传"></a>录音上传</h2><p>根据 uniapp 官网提供的 uni.uploadFile(OBJECT) API 来实现录音文件上传功能，具体 OBJECT 参数说明详见链接: uni.uploadFile(OBJECT).</p><h6 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h6><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"card"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"card_one"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"header"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"header1"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>image            <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"imgHttps + imgUrl"</span>            @click<span class="token operator">=</span><span class="token string">"imgPreview(imgUrl, imgHttps)"</span>          <span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>image<span class="token operator">></span>          <span class="token operator">&lt;</span>img <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"imgUrl"</span> alt<span class="token operator">=</span><span class="token string">""</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>      <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"bottom"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"bottom-top"</span> @click<span class="token operator">=</span><span class="token string">"addImg"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>view<span class="token operator">></span> <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"za za-addImg big1"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>          <span class="token operator">&lt;</span>text<span class="token operator">></span>添加图片<span class="token operator">&lt;</span><span class="token operator">/</span>text<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>        <span class="token operator">&lt;</span>view          <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"bottom-top"</span>          @touchstart<span class="token operator">=</span><span class="token string">"startRecord"</span>          @touchend<span class="token operator">=</span><span class="token string">"endRecord"</span>        <span class="token operator">></span>          <span class="token operator">&lt;</span>view<span class="token operator">></span> <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"za za-record big"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>          <span class="token operator">&lt;</span>text<span class="token operator">></span>点击录音<span class="token operator">&lt;</span><span class="token operator">/</span>text<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> <span class="token punctuation">{</span> upoadJKUrl<span class="token punctuation">,</span> imgHttps <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"@config"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//域名地址信息</span><span class="token keyword">const</span> recorderManager <span class="token operator">=</span> uni<span class="token punctuation">.</span><span class="token function">getRecorderManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> innerAudioContext <span class="token operator">=</span> uni<span class="token punctuation">.</span><span class="token function">createInnerAudioContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>innerAudioContext<span class="token punctuation">.</span>autoplay <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"micro-class"</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      upoadJKUrl<span class="token punctuation">,</span>      imgHttps<span class="token punctuation">,</span>      urlArr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//上传图片资源集合</span>      srcs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//用于图片预览</span>      voicePath<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>      voicePathArr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//上传音频资源集合</span>      imgUrl<span class="token punctuation">:</span> <span class="token string">"a.jpg"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">onLoad</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    recorderManager<span class="token punctuation">.</span><span class="token function">onStop</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// //console.log("录音停止了" + JSON.stringify(res)); //返回录音的临时保存地址, 可用于后面的播放</span>      self<span class="token punctuation">.</span>voicePath <span class="token operator">=</span> res<span class="token punctuation">.</span>tempFilePath<span class="token punctuation">;</span>      self<span class="token punctuation">.</span>voicePath <span class="token operator">&amp;&amp;</span> self<span class="token punctuation">.</span><span class="token function">uploadRecord</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>voicePath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//有录音上传服务器</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">startRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intervalTime <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>intervalTime <span class="token operator">>=</span> <span class="token number">0.5</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isRecord<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>isRecord <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>intervalTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          recorderManager<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            format<span class="token punctuation">:</span> <span class="token string">"mp3"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">endRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>intervalTime <span class="token operator">&lt;=</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"showToast"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">"录音太短了!"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>isRecord<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          recorderManager<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>isRecord <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//延迟小段时间停止录音, 更好的体验</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//添加图片</span>    <span class="token function">addImg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      uni<span class="token punctuation">.</span><span class="token function">chooseImage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        count<span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">let</span> tempFilePaths <span class="token operator">=</span> res<span class="token punctuation">.</span>tempFilePaths<span class="token punctuation">;</span>          tempFilePaths<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            uni<span class="token punctuation">.</span><span class="token function">uploadFile</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              url<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>upoadJKUrl<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/across/file/upload`</span></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//仅为示例，非真实的接口地址</span>              fileType<span class="token punctuation">:</span> <span class="token string">"image"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//ZFB必填,不然报错</span>              headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 修改请求头Content-Type类型 此类型为文件上传</span>                <span class="token string">"Content-Type"</span><span class="token punctuation">:</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">,</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span>              formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//后端接口所需要的数据</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span>              filePath<span class="token punctuation">:</span> item<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//这个就是我们上面拍照返回或者先中照片返回的数组</span>              name<span class="token punctuation">:</span> <span class="token string">"file"</span><span class="token punctuation">,</span>              success<span class="token punctuation">:</span> <span class="token punctuation">(</span>uploadFileRes<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">let</span> objData <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>uploadFileRes<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由JSON字符串转换为JSON对象</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>urlArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>imgHttps <span class="token operator">+</span> objData<span class="token punctuation">.</span>data<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//去数组第一个</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>urlArr<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token keyword">this</span><span class="token punctuation">.</span>imgUrl <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>urlArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"showModal"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                  content<span class="token punctuation">:</span> <span class="token string">"图片添加成功"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 图片预览</span>    <span class="token function">imgPreview</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> imgHttps<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>img<span class="token punctuation">.</span>src <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> img<span class="token punctuation">.</span>src <span class="token operator">==</span> <span class="token string">""</span> <span class="token operator">||</span> img<span class="token punctuation">.</span>src <span class="token operator">==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>srcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>imgHttps<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>img<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>srcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>imgHttps<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>img<span class="token punctuation">.</span>src<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      uni<span class="token punctuation">.</span><span class="token function">previewImage</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        indicator<span class="token punctuation">:</span> <span class="token string">"number"</span><span class="token punctuation">,</span>        loop<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        urls<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>srcs<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>srcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//录音文件上传后端服务器</span>    <span class="token function">uploadRecord</span><span class="token punctuation">(</span>tempFilePath<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// tempFilePath为RecorderManager对象返回的录音文件临时地址</span>      <span class="token comment" spellcheck="true">//console.log("录音文件上传后端服务器,,,,,", tempFilePath);</span>      <span class="token keyword">const</span> uploadTask <span class="token operator">=</span> uni<span class="token punctuation">.</span><span class="token function">uploadFile</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>upoadJKUrl<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/across/file/upload`</span></span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//后端接口地址</span>        filePath<span class="token punctuation">:</span> tempFilePath<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//录音结束后返回的临时路径</span>        name<span class="token punctuation">:</span> <span class="token string">"file"</span><span class="token punctuation">,</span>        header<span class="token punctuation">:</span> <span class="token punctuation">{</span>          <span class="token string">"content-type"</span><span class="token punctuation">:</span> <span class="token string">"multipart/form-data"</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">// token: uni.getStorageSync("token"),</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">let</span> objData <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由JSON字符串转换为JSON对象</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>voicePathArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>imgHttps <span class="token operator">+</span> objData<span class="token punctuation">.</span>data<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"showModal"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            content<span class="token punctuation">:</span> <span class="token string">"录音上传成功"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        fail<span class="token punctuation">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">"showModal"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            content<span class="token punctuation">:</span> <span class="token string">"录音上传失败"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>style scoped lang<span class="token operator">=</span><span class="token string">"scss"</span><span class="token operator">></span><span class="token punctuation">.</span>card <span class="token punctuation">{</span>  height<span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  display<span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  flex<span class="token operator">-</span>direction<span class="token punctuation">:</span> column<span class="token punctuation">;</span>  background<span class="token operator">-</span>color<span class="token punctuation">:</span> #eee<span class="token punctuation">;</span>  box<span class="token operator">-</span>sizing<span class="token punctuation">:</span> border<span class="token operator">-</span>box<span class="token punctuation">;</span>  <span class="token punctuation">.</span>card_one <span class="token punctuation">{</span>    border<span class="token operator">-</span>radius<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">%</span><span class="token punctuation">;</span>    padding<span class="token punctuation">:</span> 10px 0px 10px<span class="token punctuation">;</span>    <span class="token punctuation">.</span>top <span class="token punctuation">{</span>      text<span class="token operator">-</span>align<span class="token punctuation">:</span> center<span class="token punctuation">;</span>      font<span class="token operator">-</span>weight<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">;</span>      height<span class="token punctuation">:</span> 72rpx<span class="token punctuation">;</span>      line<span class="token operator">-</span>height<span class="token punctuation">:</span> 50rpx<span class="token punctuation">;</span>      box<span class="token operator">-</span>shadow<span class="token punctuation">:</span> 4px 4px 15px #eee<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>header <span class="token punctuation">{</span>      box<span class="token operator">-</span>sizing<span class="token punctuation">:</span> border<span class="token operator">-</span>box<span class="token punctuation">;</span>      height<span class="token punctuation">:</span> 434rpx<span class="token punctuation">;</span>      margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span> 20rpx<span class="token punctuation">;</span>      display<span class="token punctuation">:</span> flex<span class="token punctuation">;</span>      justify<span class="token operator">-</span>content<span class="token punctuation">:</span> center<span class="token punctuation">;</span>      align<span class="token operator">-</span>items<span class="token punctuation">:</span> center<span class="token punctuation">;</span>      background<span class="token operator">-</span>color<span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">215</span><span class="token punctuation">,</span> <span class="token number">215</span><span class="token punctuation">,</span> <span class="token number">215</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">.</span>header1 <span class="token punctuation">{</span>        height<span class="token punctuation">:</span> 180px<span class="token punctuation">;</span>        width<span class="token punctuation">:</span> 359px<span class="token punctuation">;</span>        background<span class="token operator">-</span>color<span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        img <span class="token punctuation">{</span>          width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>          height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>          object<span class="token operator">-</span>fit<span class="token punctuation">:</span> cover<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不变形、铺满</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>bottom <span class="token punctuation">{</span>      display<span class="token punctuation">:</span> flex<span class="token punctuation">;</span>      height<span class="token punctuation">:</span> 150rpx<span class="token punctuation">;</span>      line<span class="token operator">-</span>height<span class="token punctuation">:</span> 80rpx<span class="token punctuation">;</span>      justify<span class="token operator">-</span>content<span class="token punctuation">:</span> space<span class="token operator">-</span>evenly<span class="token punctuation">;</span>      <span class="token punctuation">.</span>bottom<span class="token operator">-</span>top <span class="token punctuation">{</span>        display<span class="token punctuation">:</span> flex<span class="token punctuation">;</span>        flex<span class="token operator">-</span>direction<span class="token punctuation">:</span> column<span class="token punctuation">;</span>        align<span class="token operator">-</span>items<span class="token punctuation">:</span> center<span class="token punctuation">;</span>        justify<span class="token operator">-</span>content<span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token punctuation">.</span>big <span class="token punctuation">{</span>          font<span class="token operator">-</span>size<span class="token punctuation">:</span> 80rpx<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span>big1 <span class="token punctuation">{</span>          font<span class="token operator">-</span>size<span class="token punctuation">:</span> 90rpx<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>btn <span class="token punctuation">{</span>      padding<span class="token punctuation">:</span> 20rpx 40rpx <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##&lt;/p&gt;
&lt;p&gt;最近开发 uniapp 小程序，遇到了项目上的开发任务，于是就记录在此，作为经验总结&lt;/p&gt;
&lt;h2 id=&quot;图片的上传和预览&quot;&gt;&lt;a href=&quot;#图片的上传和预览&quot; class=&quot;headerlink&quot; title=&quot;图片的上传和预览&quot;&gt;&lt;/a&gt;图片</summary>
      
    
    
    
    <category term="uniapp" scheme="https://liang996.github.io/categories/uniapp/"/>
    
    
    <category term="uniapp" scheme="https://liang996.github.io/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>vue和React的区别</title>
    <link href="https://liang996.github.io/2022/053056519.html"/>
    <id>https://liang996.github.io/2022/053056519.html</id>
    <published>2022-05-30T00:37:52.000Z</published>
    <updated>2022-05-30T00:42:40.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-和-React-区别"><a href="#Vue-和-React-区别" class="headerlink" title="Vue 和 React 区别"></a>Vue 和 React 区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1.使用 Virtual DOM</p><p>2.提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</p><p>3.将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</p><p>4.运行时性能,React 和 Vue 都是非常快的</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>1.Vue 承认 React 更好的地方，比如更丰富的生态系统。</p><p>2.子组件的重渲染,react 由该组件的 props 所决定的，在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的</p><p>3.在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。<br>Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是模板</p><p>4.在组件作用域内的 CSS， React 和 Vue 主要的区别是，Vue 设置样式的默认方法是单文件组件里类似 style 的标签，Vue 的单文件组件里的样式设置是非常灵活</p><p>5.规模不同，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</p><p>6.学习成本，vue 比 react 更容易上手，因为学 React 前，你需要知道 JSX 和 ES2015</p><p>7.定义不同，Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架，React 是用于构建用户界面的 js 库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-和-React-区别&quot;&gt;&lt;a href=&quot;#Vue-和-React-区别&quot; class=&quot;headerlink&quot; title=&quot;Vue 和 React 区别&quot;&gt;&lt;/a&gt;Vue 和 React 区别&lt;/h1&gt;&lt;h2 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同</summary>
      
    
    
    
    <category term="前端" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    <category term="react" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF/vue/react/"/>
    
    
    <category term="前端" scheme="https://liang996.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://liang996.github.io/tags/react/"/>
    
    <category term="vue" scheme="https://liang996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue2学习总结</title>
    <link href="https://liang996.github.io/2022/052661760.html"/>
    <id>https://liang996.github.io/2022/052661760.html</id>
    <published>2022-05-26T10:45:10.000Z</published>
    <updated>2022-05-26T10:50:41.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-学习笔记总结"><a href="#vue-学习笔记总结" class="headerlink" title="vue 学习笔记总结"></a>vue 学习笔记总结</h1><p>最近利用晚上空闲时间，把 vue2 相关的知识用例子都敲了一遍，然后把相关的知识点来总结一下</p><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的-Vue"><a href="#关于不同版本的-Vue" class="headerlink" title="关于不同版本的 Vue"></a>关于不同版本的 Vue</h2><ol><li>vue.js 与 vue.runtime.xxx.js 的区别：<ol><li>vue.js 是完整版的 Vue，包含：核心功能 + 模板解析器。</li><li>vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。</li></ol></li><li>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 这个配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</li></ol><h2 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h2><ol><li>使用 vue inspect &gt; output.js 可以查看到 Vue 脚手架的默认配置。</li><li>使用 vue.config.js 可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ol><h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><ol><li>被用来给元素或子组件注册引用信息（id 的替代者）</li><li>应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref="xxx"&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref="xxx"&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h2 id="props-配置项"><a href="#props-配置项" class="headerlink" title="props 配置项"></a>props 配置项</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name="xxx"/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:['name'] </code></p></li><li><p>第二种方式（限制类型）：<code>props:{name:String}</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><pre class=" language-js"><code class="language-js">props<span class="token punctuation">:</span><span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token punctuation">{</span>    type<span class="token punctuation">:</span>String<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//类型</span>    required<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//必要性</span>    <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token string">'老王'</span> <span class="token comment" spellcheck="true">//默认值</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><blockquote><p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p></blockquote></li></ol><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p><p>第一步定义混合：</p><pre><code>{    data(){....},    methods:{....}    ....}</code></pre><p>第二步使用混入：</p><p>​ 全局混入：<code>Vue.mixin(xxx)</code><br>​ 局部混入：<code>mixins:['xxx'] </code></p></li></ol><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol><li><p>功能：用于增强 Vue</p></li><li><p>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p><pre class=" language-js"><code class="language-js">对象<span class="token punctuation">.</span>install <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. 添加全局过滤器</span>    Vue<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2. 添加全局指令</span>    Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 3. 配置全局混入(合)</span>    Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 4. 添加实例方法</span>    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>    Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myProperty <span class="token operator">=</span> xxxx<span class="token punctuation">}</span></code></pre></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><ol><li>作用：让样式在局部生效，防止冲突。</li><li>写法：<code>&lt;style scoped&gt;</code></li></ol><h2 id="总结-TodoList-案例"><a href="#总结-TodoList-案例" class="headerlink" title="总结 TodoList 案例"></a>总结 TodoList 案例</h2><ol><li><p>组件化编码流程：</p><p>​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。</p><p>​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>​ 1).一个组件在用：放在组件自身即可。</p><p>​ 2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p><p>​ (3).实现交互：从绑定事件开始。</p></li><li><p>props 适用于：</p><p>​ (1).父组件 ==&gt; 子组件 通信</p><p>​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</p></li><li><p>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</p></li><li><p>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p></li></ol><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol><li><p>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关 API：</p><ol><li><p><code>xxxxxStorage.setItem('key', 'value');</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p></li><li><p><code>xxxxxStorage.getItem('person');</code></p><p>​ 该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem('key');</code></p><p>​ 该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code> xxxxxStorage.clear()</code></p><p>​ 该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li><li>LocalStorage 存储的内容，需要手动清除才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li><li><code>JSON.parse(null)</code>的结果依然是 null。</li></ol></li></ol><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu="test"/&gt;</code> 或 <code>&lt;Demo v-on:atguigu="test"/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Demo ref<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">...</span><span class="token operator">...</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'atguigu'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p></li><li><p>解绑自定义事件<code>this.$off('atguigu')</code></p></li><li><p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p></li></ol><h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$bus <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment" spellcheck="true">//安装全局事件总线，$bus就是当前应用的vm</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p><pre class=" language-js"><code class="language-js"><span class="token function">methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">demo</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>$bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>demo<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p></li></ol></li><li><p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装 pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from 'pubsub-js'</code></p></li><li><p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p><pre class=" language-js"><code class="language-js"><span class="token function">methods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">demo</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>pid <span class="token operator">=</span> pubsub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>demo<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//订阅消息</span><span class="token punctuation">}</span></code></pre></li><li><p>提供数据：<code>pubsub.publish('xxx',数据)</code></p></li><li><p>最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li></ol><h2 id="Vue-封装的过度与动画"><a href="#Vue-封装的过度与动画" class="headerlink" title="Vue 封装的过度与动画"></a>Vue 封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p><pre class=" language-vue"><code class="language-vue"><transition name="hello">    <h1 v-show="isShow">你好啊！</h1></transition></code></pre></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h2 id="vue-脚手架配置代理"><a href="#vue-脚手架配置代理" class="headerlink" title="vue 脚手架配置代理"></a>vue 脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​ 在 vue.config.js 中添加如下配置：</p><pre class=" language-js"><code class="language-js">devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>  proxy<span class="token punctuation">:</span> <span class="token string">"http://localhost:5000"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​ 编写 vue.config.js 配置具体代理规则：</p><pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  devServer<span class="token punctuation">:</span> <span class="token punctuation">{</span>    proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">"/api1"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 匹配所有以 '/api1'开头的请求路径</span>        target<span class="token punctuation">:</span> <span class="token string">"http://localhost:5000"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 代理目标的基础路径</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"^/api1"</span><span class="token punctuation">:</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token string">"/api2"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 匹配所有以 '/api2'开头的请求路径</span>        target<span class="token punctuation">:</span> <span class="token string">"http://localhost:5001"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 代理目标的基础路径</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"^/api2"</span><span class="token punctuation">:</span> <span class="token string">""</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080   changeOrigin默认值为true*/</span></code></pre><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><pre class=" language-vue"><code class="language-vue">父组件中：<Category>           <div>html结构1</div>        </Category>子组件中：<template>  <div>    <!-- 定义插槽 -->    <slot>插槽默认内容...</slot>  </div></template></code></pre></li><li><p>具名插槽：</p><pre class=" language-vue"><code class="language-vue">父组件中：<Category>            <template slot="center">              <div>html结构1</div>            </template>            <template v-slot:footer>               <div>html结构2</div>            </template>        </Category>子组件中：<template>  <div>    <!-- 定义插槽 -->    <slot name="center">插槽默认内容...</slot>    <slot name="footer">插槽默认内容...</slot>  </div></template></code></pre></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p></li><li><p>具体编码：</p><pre class=" language-vue"><code class="language-vue">父组件中：<Category>            <template scope="scopeData">                <!-- 生成的是ul列表 -->                <ul>                    <li v-for="g in scopeData.games" :key="g">{{g}}</li>                </ul>            </template>        </Category><Category>            <template slot-scope="scopeData">                <!-- 生成的是h4标题 -->                <h4 v-for="g in scopeData.games" :key="g">{{g}}</h4>            </template>        </Category>子组件中：<template>  <div>    <slot :games="games"></slot>  </div></template><script>export default {  name: "Category",  props: ["title"],  //数据在子组件自身  data() {    return {      games: ["红色警戒", "穿越火线", "劲舞团", "超级玛丽"],    };  },};</script></code></pre></li></ol></li></ol><pre><code></code></pre></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​ 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​ 多个组件需要共享数据时</p><h3 id="3-搭建-vuex-环境"><a href="#3-搭建-vuex-环境" class="headerlink" title="3.搭建 vuex 环境"></a>3.搭建 vuex 环境</h3><ol><li><p>创建文件：<code>src/store/index.js</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入Vue核心库</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//应用Vuex插件</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备actions对象——响应组件中用户的动作</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备mutations对象——修改state中的数据</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备state对象——保存具体的数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  actions<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span>  state<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p><pre class=" language-js"><code class="language-js"><span class="token operator">...</span><span class="token operator">...</span><span class="token comment" spellcheck="true">//引入store</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token operator">...</span><span class="token operator">...</span><span class="token comment" spellcheck="true">//创建vm</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>    store<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ol><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入Vue核心库</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//响应组件中加的动作</span>  <span class="token function">jia</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('actions中的jia被调用了',miniStore,value)</span>    context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">"JIA"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//执行加</span>  <span class="token function">JIA</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('mutations中的JIA被调用了',state,value)</span>    state<span class="token punctuation">.</span>sum <span class="token operator">+</span><span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>  sum<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  actions<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span>  state<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改 vuex 中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p><blockquote><p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="5-getters-的使用"><a href="#5-getters-的使用" class="headerlink" title="5.getters 的使用"></a>5.getters 的使用</h3><ol><li><p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><pre class=" language-js"><code class="language-js"><span class="token operator">...</span><span class="token operator">...</span><span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token function">bigSum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">.</span>sum <span class="token operator">*</span> <span class="token number">10</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    getters<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="6-四个-map-方法的使用"><a href="#6-四个-map-方法的使用" class="headerlink" title="6.四个 map 方法的使用"></a>6.四个 map 方法的使用</h3><ol><li><p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//借助mapState生成计算属性：sum、school、subject（对象写法）</span>     <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>sum<span class="token punctuation">:</span><span class="token string">'sum'</span><span class="token punctuation">,</span>school<span class="token punctuation">:</span><span class="token string">'school'</span><span class="token punctuation">,</span>subject<span class="token punctuation">:</span><span class="token string">'subject'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//借助mapState生成计算属性：sum、school、subject（数组写法）</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'school'</span><span class="token punctuation">,</span><span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//借助mapGetters生成计算属性：bigSum（对象写法）</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>bigSum<span class="token punctuation">:</span><span class="token string">'bigSum'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//借助mapGetters生成计算属性：bigSum（数组写法）</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><pre class=" language-js"><code class="language-js">methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>incrementOdd<span class="token punctuation">:</span><span class="token string">'jiaOdd'</span><span class="token punctuation">,</span>incrementWait<span class="token punctuation">:</span><span class="token string">'jiaWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'jiaOdd'</span><span class="token punctuation">,</span><span class="token string">'jiaWait'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><pre class=" language-js"><code class="language-js">methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//靠mapActions生成：increment、decrement（对象形式）</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>increment<span class="token punctuation">:</span><span class="token string">'JIA'</span><span class="token punctuation">,</span>decrement<span class="token punctuation">:</span><span class="token string">'JIAN'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//靠mapMutations生成：JIA、JIAN（对象形式）</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'JIA'</span><span class="token punctuation">,</span><span class="token string">'JIAN'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre></li></ol><blockquote><p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> countAbout <span class="token operator">=</span> <span class="token punctuation">{</span>  namespaced<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//开启命名空间</span>  state<span class="token punctuation">:</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">bigSum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> state<span class="token punctuation">.</span>sum <span class="token operator">*</span> <span class="token number">10</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> personAbout <span class="token operator">=</span> <span class="token punctuation">{</span>  namespaced<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//开启命名空间</span>  state<span class="token punctuation">:</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>    countAbout<span class="token punctuation">,</span>    personAbout  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中读取 state 数据：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接读取</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>personAbout<span class="token punctuation">.</span>list<span class="token comment" spellcheck="true">//方式二：借助mapState读取：</span><span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'school'</span><span class="token punctuation">,</span><span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre></li><li><p>开启命名空间后，组件中读取 getters 数据：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接读取</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">'personAbout/firstPersonName'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//方式二：借助mapGetters读取：</span><span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中调用 dispatch</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接dispatch</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'personAbout/addPersonWang'</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式二：借助mapActions：</span><span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>incrementOdd<span class="token punctuation">:</span><span class="token string">'jiaOdd'</span><span class="token punctuation">,</span>incrementWait<span class="token punctuation">:</span><span class="token string">'jiaWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中调用 commit</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接commit</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'personAbout/ADD_PERSON'</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式二：借助mapMutations：</span><span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>increment<span class="token punctuation">:</span><span class="token string">'JIA'</span><span class="token punctuation">,</span>decrement<span class="token punctuation">:</span><span class="token string">'JIAN'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre></li></ol><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li><li>前端路由：key 是路径，value 是组件。</li></ol><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol><li><p>安装 vue-router，命令：<code>npm i vue-router</code></p></li><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写 router 配置项:</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入VueRouter</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">"vue-router"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入Luyou 组件</span><span class="token keyword">import</span> About <span class="token keyword">from</span> <span class="token string">"../components/About"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">"../components/Home"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建router实例对象，去管理一组一组的路由规则</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">"/about"</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> About<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> Home<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//暴露router</span><span class="token keyword">export</span> <span class="token keyword">default</span> router<span class="token punctuation">;</span></code></pre></li><li><p>实现切换（active-class 可配置高亮样式）</p><pre class=" language-vue"><code class="language-vue"><router-link active-class="active" to="/about">About</router-link></code></pre></li><li><p>指定展示位置</p><pre class=" language-vue"><code class="language-vue"><router-view></router-view></code></pre></li></ol><h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol><li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li><li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li><li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li></ol><h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol><li><p>配置路由规则，使用 children 配置项：</p><pre class=" language-js"><code class="language-js">routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">"/about"</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span> About<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span> Home<span class="token punctuation">,</span>    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token comment" spellcheck="true">//通过children配置子级路由</span>      <span class="token punctuation">{</span>        path<span class="token punctuation">:</span> <span class="token string">"news"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//此处一定不要写：/news</span>        component<span class="token punctuation">:</span> News<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        path<span class="token punctuation">:</span> <span class="token string">"message"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//此处一定不要写：/message</span>        component<span class="token punctuation">:</span> Message<span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li><li><p>跳转（要写完整路径）：</p><pre class=" language-vue"><code class="language-vue"><router-link to="/home/news">News</router-link></code></pre></li></ol><h3 id="4-路由的-query-参数"><a href="#4-路由的-query-参数" class="headerlink" title="4.路由的 query 参数"></a>4.路由的 query 参数</h3><ol><li><p>传递参数</p><pre class=" language-vue"><code class="language-vue"><!-- 跳转并携带query参数，to的字符串写法 --><router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link><!-- 跳转并携带query参数，to的对象写法 --><router-link  :to="{    path: '/home/message/detail',    query: {      id: 666,      title: '你好',    },  }">跳转</router-link></code></pre></li><li><p>接收参数：</p><pre class=" language-js"><code class="language-js">$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id<span class="token punctuation">;</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>title<span class="token punctuation">;</span></code></pre></li></ol><h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol><li><p>作用：可以简化路由的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">'/demo'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span>Demo<span class="token punctuation">,</span>    children<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span>            path<span class="token punctuation">:</span><span class="token string">'test'</span><span class="token punctuation">,</span>            component<span class="token punctuation">:</span>Test<span class="token punctuation">,</span>            children<span class="token punctuation">:</span><span class="token punctuation">[</span>                <span class="token punctuation">{</span>                      name<span class="token punctuation">:</span><span class="token string">'hello'</span> <span class="token comment" spellcheck="true">//给路由命名</span>                    path<span class="token punctuation">:</span><span class="token string">'welcome'</span><span class="token punctuation">,</span>                    component<span class="token punctuation">:</span>Hello<span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>简化跳转：</p><pre class=" language-vue"><code class="language-vue"><!--简化前，需要写完整的路径 --><router-link to="/demo/test/welcome">跳转</router-link><!--简化后，直接通过名字跳转 --><router-link :to="{ name: 'hello' }">跳转</router-link><!--简化写法配合传递参数 --><router-link  :to="{    name: 'hello',    query: {      id: 666,      title: '你好',    },  }">跳转</router-link></code></pre></li></ol></li></ol><h3 id="6-路由的-params-参数"><a href="#6-路由的-params-参数" class="headerlink" title="6.路由的 params 参数"></a>6.路由的 params 参数</h3><ol><li><p>配置路由，声明接收 params 参数</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">'/home'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span>Home<span class="token punctuation">,</span>    children<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span>            path<span class="token punctuation">:</span><span class="token string">'news'</span><span class="token punctuation">,</span>            component<span class="token punctuation">:</span>News        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            component<span class="token punctuation">:</span>Message<span class="token punctuation">,</span>            children<span class="token punctuation">:</span><span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    name<span class="token punctuation">:</span><span class="token string">'xiangqing'</span><span class="token punctuation">,</span>                    path<span class="token punctuation">:</span><span class="token string">'detail/:id/:title'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//使用占位符声明接收params参数</span>                    component<span class="token punctuation">:</span>Detail                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre></li><li><p>传递参数</p><pre class=" language-vue"><code class="language-vue"><!-- 跳转并携带params参数，to的字符串写法 --><router-link :to="/home/message/detail/666/你好">跳转</router-link><!-- 跳转并携带params参数，to的对象写法 --><router-link  :to="{    name: 'xiangqing',    params: {      id: 666,      title: '你好',    },  }">跳转</router-link></code></pre><blockquote><p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p></blockquote></li><li><p>接收参数：</p><pre class=" language-js"><code class="language-js">$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">;</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>title<span class="token punctuation">;</span></code></pre></li></ol><h3 id="7-路由的-props-配置"><a href="#7-路由的-props-配置" class="headerlink" title="7.路由的 props 配置"></a>7.路由的 props 配置</h3><p>​ 作用：让路由组件更方便的收到参数</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    name<span class="token punctuation">:</span><span class="token string">'xiangqing'</span><span class="token punctuation">,</span>    path<span class="token punctuation">:</span><span class="token string">'detail/:id'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span>Detail<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span>    <span class="token comment" spellcheck="true">// props:{a:900}</span>    <span class="token comment" spellcheck="true">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span>    <span class="token comment" spellcheck="true">// props:true</span>    <span class="token comment" spellcheck="true">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span>    <span class="token function">props</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            id<span class="token punctuation">:</span>route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id<span class="token punctuation">,</span>            title<span class="token punctuation">:</span>route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>title        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-lt-router-link-gt-的-replace-属性"><a href="#8-lt-router-link-gt-的-replace-属性" class="headerlink" title="8.<router-link>的 replace 属性"></a>8.<code>&lt;router-link&gt;</code>的 replace 属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//$router的两个API</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"xiangqing"</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>    title<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"xiangqing"</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>    title<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前进</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//后退</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可前进也可后退</span></code></pre></li></ol><h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><pre class=" language-vue"><code class="language-vue"><keep-alive include="News">     <router-view></router-view></keep-alive></code></pre></li></ol><h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//全局前置守卫：初始化时执行、每次路由切换前执行</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"beforeEach"</span><span class="token punctuation">,</span> to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>isAuth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断当前路由是否需要进行权限控制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"school"</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"atguigu"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//权限控制的具体规则</span>      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//放行</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"暂无权限查看"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// next({name:'guanyu'})</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//放行</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局后置守卫：初始化时执行、每次路由切换后执行</span>router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"afterEach"</span><span class="token punctuation">,</span> to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>title<span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span>title <span class="token operator">=</span> to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>title<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//修改网页的title</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">"vue_test"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>独享守卫:</p><pre class=" language-js"><code class="language-js"><span class="token function">beforeEnter</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span><span class="token keyword">from</span><span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'beforeEnter'</span><span class="token punctuation">,</span>to<span class="token punctuation">,</span><span class="token keyword">from</span><span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>isAuth<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//判断当前路由是否需要进行权限控制</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'school'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'atguigu'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'暂无权限查看'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// next({name:'guanyu'})</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>组件内守卫：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//进入守卫：通过路由规则，进入该组件时被调用</span>beforeRouteEnter <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//离开守卫：通过路由规则，离开该组件时被调用</span>beforeRouteLeave <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol><li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li><li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li><li>hash 模式：<ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li>history 模式：<ol><li>地址干净，美观 。</li><li>兼容性和 hash 模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue-学习笔记总结&quot;&gt;&lt;a href=&quot;#vue-学习笔记总结&quot; class=&quot;headerlink&quot; title=&quot;vue 学习笔记总结&quot;&gt;&lt;/a&gt;vue 学习笔记总结&lt;/h1&gt;&lt;p&gt;最近利用晚上空闲时间，把 vue2 相关的知识用例子都敲了一遍，然后把相关的</summary>
      
    
    
    
    
    <category term="vue" scheme="https://liang996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>个人面试总结三</title>
    <link href="https://liang996.github.io/2022/030425694.html"/>
    <id>https://liang996.github.io/2022/030425694.html</id>
    <published>2022-03-04T03:10:19.000Z</published>
    <updated>2022-12-07T03:19:59.266Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-看过哪些框架或者类库的源码，有什么收获？"><a href="#1-看过哪些框架或者类库的源码，有什么收获？" class="headerlink" title="1.看过哪些框架或者类库的源码，有什么收获？"></a>1.看过哪些框架或者类库的源码，有什么收获？</h4><p>看过 vue 框架源码，对 vue 有了初步的认识，包括对 Object.defineProperty、虚拟 DOM 有一定了解，<br>其中的收获了有，大致明白 vue 大体可以分两个部分：</p><p>1.采用 Object.defineProperty 进行数据的双向绑定；</p><p>2.采用虚拟 DOM 技术进行视图渲染；</p><p>####2.介绍 Vue 中的常用的指令</p><p>1.<code>v-text</code>指令：用于更新标签包含的文本，它的作用跟双大括号效果是一样的。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--等同于--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>2.<code>v-html</code>:元素的 innerHTML</p><p><code>作用</code>：向指定节点中渲染包含 html 结构的内容。</p><p><code>与插值语法的区别</code>：<br>(1).v-html 会替换掉节点中所有的内容，则不会。<br>(2).v-html 可以识别 html 结构。</p><p><code>严重注意</code>：v-html 有安全性问题！<br>(1).在网站上动态渲染任意 HTML 是非常危险的，容易导致 XSS 攻击。<br>(2).一定要在可信的内容上使用 v-html，永不要用在用户提交的内容上！</p><p>3.<code>v-if</code>:v-if 指令判断是否插入这个元素,相当于对元素的销毁和创建,取值为 true/false，控制元素是否需要被渲染，</p><p>4.<code>v-show</code>指令：指令的取值为 true/false，分别对应着显示/隐藏</p><p><code>注</code>：v-show 和 v-if 的区别：如果需要频繁切换显示/隐藏的可以用 v-show;如果运行后不太可能需要切换显示/隐藏的可以用 v-if；</p><p>5.<code>v-for</code>指令：遍历 data 中存放的数组数据，实现列表的渲染。（v-for 指令除了可以迭代数组，还可以迭代对象和整数）</p><p>6.<code>v-on</code>指令:可以绑定事件的监听器。用于处理自定义原生事件的,给按钮添加 click 并让使用变量的样式改变。</p><p>普通使用 v-on:事件名=”表达式||函数名”</p><p>简写方式<code>@事件名="表达式"</code></p><p>7.<code>v-bind</code>指令：用于动态绑定 DOM 元素的属性;例如<code>&lt;a&gt;</code>标签的<code>href</code>属性，<code>&lt;img&gt;</code>标签的<code>src</code>属性等。v-bind 可以简写成<code>":"</code>给元素的属性赋值</p><p>语法在元素上 v-bind:属性名=”常量||变量名”</p><p>简写形式<code>:属性名="变量名"</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>原属性名</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>变量<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span> <span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--等同于--></span>&lt;div:属性名="变量"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>8.<code>v-model</code>指令：用于表单输入，实现表单控件和数据的<code>双向绑定</code>。只要给 input 控件添加 v-model 指令，并指定关联的数据 content，就可以轻松把用户输入的内容绑定在 content 上。</p><p>巧记：双向数据流（绑定）<br>页面改变影响内存(js)<br>内存(js)改变影响页面</p><p><code>补充</code>:v-bind 和 v-model 的区别?</p><p><code>input v-model="name"</code></p><p>双向数据绑定页面对于 input 的 value 改变，能影响内存中 name 变量</p><p>内存 js 改变 name 的值，会影响页面重新渲染最新值</p><p><code>input :value="name"</code></p><p>单向数据绑定内存改变影响页面改变</p><p>v-model:其的改变影响其他</p><p>v-bind:其的改变不影响其他</p><p>v-bind 就是对属性的简单赋值,当内存中值改变，还是会触发重新渲染</p><p>9.<code>v-once</code>指令：只渲染一次，后面元素中的数据再更新变化，都不会重新渲染。</p><p>####3、vue 中常用的事件修饰符</p><p>1.<code>.stop</code>：等同于 JavaScript 中的 event.stopPropagation()，防止事件冒泡</p><p>2.<code>.prevent</code>：等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）</p><p>3.<code>.capture</code>：与事件冒泡的方向相反，事件捕获由外到内</p><p>4.<code>.self</code>：只会触发自己范围内的事件，不包含子元素</p><p>5.<code>.once</code>：只会触发一次</p><h4 id="4-谈谈你对-MVVM-开发模式的理解"><a href="#4-谈谈你对-MVVM-开发模式的理解" class="headerlink" title="4.谈谈你对 MVVM 开发模式的理解"></a>4.谈谈你对 MVVM 开发模式的理解</h4><p>MVVM 分别是：ModelViewViewModal</p><p>该开发模式主要体现在 vue.js 中</p><p>M 层：模型</p><p>V 层：视图</p><p>VM 层：视图模型 VM 是 MVVM 思想的核心，因为 VM 是 V 和 M 的调度者。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//VM层</span><span class="token keyword">var</span> vm<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//M层</span>msg<span class="token punctuation">:</span><span class="token string">'你好，vue.js'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//V层</span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">'app'</span><span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>Model:代表数据模型，数据和业务逻辑都在 Model 中定义。</p><p>View:代表 UI 视图，负责数据的展示</p><p>ViewModel:负责监听 Model 中数据的改变并且控制视图的更新。</p><h4 id="5、v-if-和-v-show-有什么区别"><a href="#5、v-if-和-v-show-有什么区别" class="headerlink" title="5、v-if 和 v-show 有什么区别"></a>5、v-if 和 v-show 有什么区别</h4><p>(1)、v-if 和 v-show 用于视图层显示和隐藏</p><p>(2)、v-if 的原理是根据判断条件来动态的进行增删 DOM 元素，v-show 是根据判断条件来动态的进行显示和隐藏元素，频繁的进行增删 DOM 操作会影响页面加载速度和性能，由此我们可以得出结论：</p><p>当您的项目程序不是很大的时候，v-if 和 v-show 都可以用来进行判断展示和隐藏（这种场景使用 v-if 只是影响不大，并不是没有影响）；</p><p>当您的项目程序比较大的时候，不推荐使用 v-if 来进行判断展示和隐藏，推荐使用 v-show；</p><p>(3)、只有 v-if 能和 v-else 连用进行分支判断，v-show 是不能和 v-else 连用的，如果出现多种条件场景的情况下，可以使用 v-if 来进行判断</p><h4 id="6-请详细说下你对-vue-生命周期的理解？"><a href="#6-请详细说下你对-vue-生命周期的理解？" class="headerlink" title="6.请详细说下你对 vue 生命周期的理解？"></a>6.请详细说下你对 vue 生命周期的理解？</h4><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><p>创建前/后：<br>在 beforeCreated 阶段，vue 实例的挂载元素 el 和 ∗∗ 数据对象 ∗∗data 都为 undefined，还未初始化。</p><p>在 created 阶段，vue 实例的数据对象 data 有了，el 还没有。</p><p>载入前/后：<br>在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。</p><p>在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p><p>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</p><p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。</p><h4 id="7、计算属性及和-watch-、methods-的区别"><a href="#7、计算属性及和-watch-、methods-的区别" class="headerlink" title="7、计算属性及和 watch 、methods 的区别"></a>7、计算属性及和 watch 、methods 的区别</h4><p>1、computed 必须 return 一个值，主要当做属性来使用，存在缓存；<br>另外 computed 属性，在 vue 里面用来触发 setter 和 getter 方法。setter 方法在设置值时触发，getter 方法在获取值时触发</p><p>methods 表示一个方法，是函数调用，主要书写业务逻辑；</p><p>watch 监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是 computed 和 methods 的结合体</p><p>2、watch 相比于 methods 虽然有时候显得更繁琐，但是在监听非 DOM 元素时，显示出优势</p><p>当页面内部使用了复杂的逻辑表达式，首选使用计算属性，methods 方法虽然能实现，但是会增大开销，计算属性基于缓存，具有更优性。当需要在数据变化时执行异步或者开销较大的操作时，则优先考虑 watch 属性</p><h4 id="8-跨域问题底层"><a href="#8-跨域问题底层" class="headerlink" title="8.跨域问题底层"></a>8.跨域问题底层</h4><p>同源策略的限制,跨域问题出现在浏览器端</p><p><code>跨域出现的原因</code>：(三不同)<br>（1）协议不同。（http 和 https）<br>（2）域名不同。（test 和 tests ，或者是直接请求 IP 的不同）<br>（3）端口号不同。（8080 和 8081）<br>以上三种条件都相同，就是同域，可以正常读写域内资源，有一个条件不同，请求方与响应方都属于跨域，无法进行资源访问。<br>这就叫做同源策略</p><p><code>解决方法</code></p><p>（跨域资源共享）cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。</p><p>jsonp：由于<code>&lt;script&gt;&lt;/script&gt;</code>,<code>&lt;img&gt;</code>中的<code>src</code>不受同源策略的限制,利用这一点，就有了 jsonp 这种非正式传输协议，所以 jsonp 解决跨域的原理是 script 标签可以跨域请求资源，将回调函数作为参数拼接在 url 中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成 javascript。</p><p>代理和反向代理</p><p>在响应头里添加特殊请求头 Access-Control-Allow-Origin 信息。</p><h4 id="9-你做过哪些性能的优化"><a href="#9-你做过哪些性能的优化" class="headerlink" title="9.你做过哪些性能的优化"></a>9.你做过哪些性能的优化</h4><p><strong>1.</strong> 减少 HTTP 请求</p><ol><li>HTML 优化：</li></ol><p>使用语义化标签</p><p>减少 iframe</p><p>避免重定向</p><ol start="2"><li>CSS 优化：</li></ol><p>布局代码写前面</p><p>删除空样式</p><p>不滥用浮动、字体，需要加载的网络字体根据需求添加</p><p>选择器性能优化</p><p>避免使用表达式</p><p>避免用 id 写样式</p><p>压缩代码</p><ol start="3"><li>JS 优化</li></ol><p>压缩代码</p><p>减少重复代码</p><ol start="4"><li>图片优化</li></ol><p>使用 webP</p><p>图片合并，CSS sprite 技术 - 雪碧图</p><p>移动端响应式图片 - @media(max-width:320px){}</p><p><strong>2.</strong> 减少 DOM 操作</p><p>缓存已经访问过的元素</p><p>离线更新节点，再将他们添加到树中</p><p>避免使用 js 输出页面布局</p><p><strong>3.</strong> 使用 JSON 格式进行数据交换</p><p><strong>4.</strong> 使用 CDN 加速</p><p><strong>5.</strong> 使用 HTTP 缓存：添加 Expires 或者 Cache-Control 信息头</p><p><strong>6.</strong> 使用 DNS 预解析</p><ol><li>用 meta 信息来告知浏览器，当前页面要做 DNS 预解析：</li></ol><p><code>&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;</code></p><ol start="2"><li>在页面 header 中使用 link 标签来强制对 DNS 预解析：</li></ol><p><code>&lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt;</code></p><h4 id="10-vue-router-路由有几种模式？说说它们的区别？"><a href="#10-vue-router-路由有几种模式？说说它们的区别？" class="headerlink" title="10. vue-router 路由有几种模式？说说它们的区别？"></a>10. vue-router 路由有几种模式？说说它们的区别？</h4><p>vue-router 路由有一共有两种模式，分别是 hash 模式,history 模式</p><p><code>hash模式</code></p><p>1、 url 路径会出现 # 字符</p><p>2、hash 值不包括在 HTTP 请求中，它是交由前端路由处理，所以改变 hash 值时不会刷新页面，也不会向服务器发送请求</p><p>3、hash 值的改变会触发 hashchange 事件</p><p><code>history模式</code></p><p>1、整个地址重新加载，可以保存历史记录，方便前进后退</p><p>2、使用 HTML5 API（旧浏览器不支持）和 HTTP 服务端配置，没有后台配置的话，页面刷新时会出现 404</p><p><code>补充</code>：如果 vue-router 使用 history 模式，部署时要注意什么？</p><p>HTTP 服务端需要进行配置，将页面请求全部重定向到 index.html。参考官方文档</p><p>nginx 配置：</p><pre class=" language-js"><code class="language-js">location <span class="token operator">/</span> <span class="token punctuation">{</span> try_files $uri $uri<span class="token operator">/</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="11-说一下你对同步和异步的理解"><a href="#11-说一下你对同步和异步的理解" class="headerlink" title="11.说一下你对同步和异步的理解"></a>11.说一下你对同步和异步的理解</h4><p>答：同步即 sync，形象的说就是代码一行行执行，前面代码和请求没有执行完，后面的代码和请求就不会被执行，</p><p>缺点：容易导致代码阻塞</p><p>优点：程序员容易理解（因为代码从上往下一行行执行，强调顺序）</p><p>异步：即 async,形象的说就是代码可以在当前程序没有执行完，也可以执行后面的代码</p><p>缺点：程序员不易理解（因为不是按顺序执行的）</p><p>优点：可以解决代码阻塞问题，提升代码执行效率和性能</p><p>异步解决方案主要有三个：</p><p>回调函数</p><p>promise（重点掌握）</p><p>generator(了解)</p><p>async 和 await（重点掌握）</p><h4 id="12-promise-是同步还是异步的？"><a href="#12-promise-是同步还是异步的？" class="headerlink" title="12.promise 是同步还是异步的？"></a>12.promise 是同步还是异步的？</h4><p>1.promise 本身是同步的</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> oP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> rej<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行的结果先打印出 1 再打印出 2，如果 promise 是异步的应该先打印出 2，所以 promise 本身是同步</p><p>2.Promise 本身是同步的，他的 then 方法的回调函数和 catch 方法的回调函数是异步的</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> oP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> rej<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oP<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>执行的结果 1，2，3，因为 then 是异步的，所以先打印了 2，最后再执行回调打印出 3</p><p>补充：Promise 作用是解决异步回调的问题的方案</p><h4 id="13-本地存储方式及区别"><a href="#13-本地存储方式及区别" class="headerlink" title="13.本地存储方式及区别"></a>13.本地存储方式及区别</h4><p><strong>一、cookie</strong></p><p>cookie 算是比较早的技术，最初是为了记录 http 的状态，提高访问速度。cookie 是服务器”种植”在客户端的 key-value 形式文本文件。但同时客户端也能操作 cookie。<br>特点：</p><pre><code>大小：cookie的大小限制在4k。每个域名下cookie的个数现在在20个。在客户端请求服务器端和服务器响应时，cookie始终被携带在http请求中，即使不需要(造成流量浪费)。这也是限制cookie大小的原因。客户端可以通过document.cookie操作cookie，并不安全。cookie可以设置过期时间、路径、域和httpOnly等字段。如果设置了过期时间，cookie会保存在硬盘里，知道到了设定的过期时间才会失效。若未设置过期时间，在浏览器窗口关闭时，cookie就失效了。路径和域两个字段限制了cookie的作用范围。httpOnly设置为true，则js不能通过document.cookie操作cookie。</code></pre><p><strong>二、localStorage</strong></p><p>它也是采用 key-value 的形式存储数据，但是它与 cookie 有很大的区别<br>特点：</p><pre><code>对比着来，localStorage能保存更大的数据，标准浏览器是5Mb。localStorage保存在客户端，不随着请求发送给服务器，避免了流量的浪费。客户端可以通过：setItem、getItem方法访问localStorage。并且，localStorage没有过期时间，如果不手动清除，数据就永远不会过期，一直保存在浏览器当中。存储的信息在同一域中是共享的。</code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//key，value 都必须是字符串，storage 的api 只能操作字符串</span><span class="token comment" spellcheck="true">//设置</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除某个数据</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清除所有数据</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取某个索引的key</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>三、sessionStorage</strong></p><p>特点：</p><pre><code>与localStorage不同的是，sessionStorage并不持久化，在窗口关闭那一刻，sessionStorage会被清除。存储的信息是会话级别的，同域也是不能共享的。关闭当前标签页，sessionStorage即失效。</code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//存储</span>sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span><span class="token string">"value"</span>）<span class="token comment" spellcheck="true">//按key获取值</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//按key 删除单个值</span>sessionStorage<span class="token punctuation">.</span><span class="token function">removeItems</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//清除所有数据</span>sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取数据的数量</span>sessionStorage<span class="token punctuation">.</span>length<span class="token comment" spellcheck="true">//获取全部值</span>sessionStorage<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sessionStorage也可存储Json对象：存储时，通过JSON.stringify()将对象转换为文本格式；读取时，通过JSON.parse()将文本转换回对象。</span><span class="token keyword">var</span> userEntity <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'tom'</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 存储值：将对象转换为Json字符串</span>sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>userEntity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 取值时：把获取到的Json字符串转换回对象</span><span class="token keyword">var</span> userJsonStr <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>userEntity <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>userJsonStr<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userEntity<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// => tom</span></code></pre><p>浏览器本地存储统称为 webStorage，包括了 localStorage 和 sessionStorage</p><p><strong>四、session(附加)</strong></p><p>上面提到了 cookie，顺带提一下 session。客户端第一次访问服务器，服务器种植一个 cookie，保存唯一的 sessionId。后面客户端再次访问，会读取此 sessionId，随即能在服务端读取到此 id 保存的会话对象。<br>特点：</p><p>session 是基于 cookie 的，由于 session 在客户端不可被修改，相对于 cookie 来说安全，所以可存放一些重要数据。<br>数据保存在服务器端，客户端通过 sessionId，读取到相对应的数据。</p><h4 id="14-undfind-和-null-的区别"><a href="#14-undfind-和-null-的区别" class="headerlink" title="14.undfind 和 null 的区别"></a>14.undfind 和 null 的区别</h4><p>JavaScript 的最初版本是这样区分的：null 是一个表示”无”的对象（空对象指针），转为数值时为 0；undefined 是一个表示”无”的原始值，转为数值时为 NaN。</p><h4 id="15-什么是作用域和作用域链"><a href="#15-什么是作用域和作用域链" class="headerlink" title="15.什么是作用域和作用域链"></a>15.什么是作用域和作用域链</h4><p>作用域(Scope)</p><p><strong>1.</strong> 什么是作用域</p><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> inVariable <span class="token operator">=</span> <span class="token string">"内层变量2"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//要先执行这个函数，否则根本不知道里面是啥</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught ReferenceError: inVariable is not defined</span></code></pre><p>从上面的例子可以体会到作用域的概念，变量 inVariable 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：</p><p>1.<code>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。</code></p><p>2 . <code>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</code></p><p>3.<code>变量的作用域无非就是两种：全局变量和局部变量。 </code></p><p>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p><p><strong>2.</strong> 什么是作用域链</p><p>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。<br>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><h4 id="16-箭头函数带来的一些问题"><a href="#16-箭头函数带来的一些问题" class="headerlink" title="16.箭头函数带来的一些问题"></a>16.箭头函数带来的一些问题</h4><p><strong>1.</strong> this 指向问题</p><p>在普通函数中，this 指向根据其使用场景不同改变。而箭头函数中的 this 始终指向其父级作用域</p><p>箭头函数与普通函数对 this 的指向不同，ES6 定义时 this 指向谁执行的时候 this 就指向谁。</p><p><strong>2.</strong> 箭头函数没有原型属性</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p><strong>3.</strong><br>箭头函数通过 apply 和 bind 调用，不会改变 this 指向，只会传入参数</p><p><strong>4.</strong><br>call、apply、bind 无法改变箭头函数中的 this。</p><h4 id="17-函数柯里化"><a href="#17-函数柯里化" class="headerlink" title="17.函数柯里化"></a>17.函数柯里化</h4><p>函数柯里化的定义：是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>通过上面的定义可以看出，柯里化是一个函数返回另一个函数，这是一个典型的闭包，它封装了一部分不变的内容，然后去处理其他可变的数据</p><p>举个官网的例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> abc <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> curried <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span>abc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curried</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// => [1, 2, 3]</span><span class="token function">curried</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// => [1, 2, 3]</span><span class="token function">curried</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// => [1, 2, 3]</span></code></pre><h4 id="18-JS-异步编程都有哪些方案"><a href="#18-JS-异步编程都有哪些方案" class="headerlink" title="18.JS 异步编程都有哪些方案"></a>18.JS 异步编程都有哪些方案</h4><p>总结起来无外乎有这几种：回调函数、事件监听、Promise、Generator、async/await，这几种 JS 的编程方式都是异步编程。回调函数方式是最早的 JS 异步编程的方式，后随着 ES 标准的发展，Promise、Generator 和 async/await 接连出现。</p><h4 id="19-关于-Vue-和-React-区别的一些笔记"><a href="#19-关于-Vue-和-React-区别的一些笔记" class="headerlink" title="19.关于 Vue 和 React 区别的一些笔记"></a>19.关于 Vue 和 React 区别的一些笔记</h4><ol><li>监听数据变化的实现原理不同</li></ol><p>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化。</p><p>React 默认是通过比较引用的方式（diff）进行的</p><ol start="2"><li>数据流的不同</li></ol><p>vue 组件与 DOM 之间可以通过 v-model 双向绑定。</p><p>React 一直不支持双向绑定，提倡的是单向数据流，称之为 onChange/setState()模式。</p><ol start="3"><li>框架本质不同</li></ol><p>Vue 本质是 MVVM 框架，由 MVC 发展而来；</p><p>React 是前端组件化框架，由后端组件化发展而来。</p><ol start="4"><li>Vuex 和 Redux 的区别</li></ol><p>Redux 使用的是不可变数据，而 Vuex 的数据是可变的，因此，Redux 每次都是用新 state 替换旧 state，而 Vuex 是直接修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-看过哪些框架或者类库的源码，有什么收获？&quot;&gt;&lt;a href=&quot;#1-看过哪些框架或者类库的源码，有什么收获？&quot; class=&quot;headerlink&quot; title=&quot;1.看过哪些框架或者类库的源码，有什么收获？&quot;&gt;&lt;/a&gt;1.看过哪些框架或者类库的源码，有什么收</summary>
      
    
    
    
    <category term="前端面试" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端面试" scheme="https://liang996.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React跳转路由传参3种方法和区别</title>
    <link href="https://liang996.github.io/2022/030444866.html"/>
    <id>https://liang996.github.io/2022/030444866.html</id>
    <published>2022-03-04T03:06:06.000Z</published>
    <updated>2022-03-04T03:15:25.038Z</updated>
    
    <content type="html"><![CDATA[<p>日常业务中，路由跳转的同时传递参数是比较常见的，为此来总结一下 react 的跳转方式</p><h3 id="1、params-传参"><a href="#1、params-传参" class="headerlink" title="1、params 传参"></a>1、params 传参</h3><p>路由表配置：参数地址栏显示</p><p>路由页面：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/demo/:id<span class="token punctuation">"</span></span> <span class="token attr-name">component</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{Demo}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Route</span><span class="token punctuation">></span></span> //配置 /:id</code></pre><p>路由跳转并传递参数：</p><p>链接方式：</p><pre class=" language-html"><code class="language-html">&lt;Link to={'/demo/' + '2'}>XX<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Link</span><span class="token punctuation">></span></span></code></pre><p>js 方式：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/demo/"</span> <span class="token operator">+</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获取参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>match<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><h3 id="2、query-传参"><a href="#2、query-传参" class="headerlink" title="2、query 传参"></a>2、query 传参</h3><p>query 方法：参数地址栏不显示，刷新地址栏，参数丢失</p><p>路由页面：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/demo<span class="token punctuation">"</span></span> <span class="token attr-name">component</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{Demo}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Route</span><span class="token punctuation">></span></span> //无需配置</code></pre><p>路由跳转并传递参数：</p><p>链接方式：</p><pre class=" language-html"><code class="language-html">&lt;Link to={{path:'/demo',query:{name:'dahuang'}}}>XX<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Link</span><span class="token punctuation">></span></span></code></pre><p>js 方式：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> pathname<span class="token punctuation">:</span> <span class="token string">"/demo"</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"dahuang"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获取参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location<span class="token punctuation">.</span>query<span class="token punctuation">.</span>name<span class="token punctuation">;</span></code></pre><h3 id="3、state-传参-同-query-差不多，只是属性不一样，而且-state-传的参数是加密的"><a href="#3、state-传参-同-query-差不多，只是属性不一样，而且-state-传的参数是加密的" class="headerlink" title="3、state 传参( 同 query 差不多，只是属性不一样，而且 state 传的参数是加密的)"></a>3、state 传参( 同 query 差不多，只是属性不一样，而且 state 传的参数是加密的)</h3><p>state 方法：参数地址栏不显示，刷新地址栏，参数不丢失</p><p>路由页面：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Route</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/demo<span class="token punctuation">"</span></span> <span class="token attr-name">component</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{Demo}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Route</span><span class="token punctuation">></span></span> //无需配置</code></pre><p>路由跳转并传递参数：</p><p>链接方式：</p><pre class=" language-html"><code class="language-html"> &lt;Link to={{path:'/demo',state:{name:'dahuang'}}}>XX<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Link</span><span class="token punctuation">></span></span></code></pre><p>js 方式：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> pathname<span class="token punctuation">:</span> <span class="token string">"/demo"</span><span class="token punctuation">,</span> state<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"dahuang"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获取参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location<span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">;</span></code></pre><p>借鉴网址：<br><a href="https://www.cnblogs.com/ranyonsue/p/14098491.html">React 跳转路由传参 3 种方法和区别</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常业务中，路由跳转的同时传递参数是比较常见的，为此来总结一下 react 的跳转方式&lt;/p&gt;
&lt;h3 id=&quot;1、params-传参&quot;&gt;&lt;a href=&quot;#1、params-传参&quot; class=&quot;headerlink&quot; title=&quot;1、params 传参&quot;&gt;&lt;/a&gt;1、</summary>
      
    
    
    
    <category term="React" scheme="https://liang996.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://liang996.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react的setState到底是同步还是异步?</title>
    <link href="https://liang996.github.io/2022/030421386.html"/>
    <id>https://liang996.github.io/2022/030421386.html</id>
    <published>2022-03-04T02:57:56.000Z</published>
    <updated>2022-03-04T03:12:05.381Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道经典 react 面试题，之前还有点疑惑，为了探究真理，特来加以总结。</p><p>答案：react 的 setState 既可能是同步的，也可能是异步的。 准确地说，在 React 内部机制能检测到的地方， setState 就是异步的；在 React 检测不到的地方，例如 setInterval,setTimeout 里，setState 就是同步更新的。</p><p>在介绍这个问题之前，我们先来看一下一个例子：</p><pre class=" language-js"><code class="language-js">state <span class="token operator">=</span> <span class="token punctuation">{</span>    number<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>number<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>number<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1</span><span class="token punctuation">}</span></code></pre><p>看完这个例子，也许很多小伙伴会下意识的以为 setState 是一个异步方法，但是其实 setState 并没有异步的说法，之所以会有一种异步方法的表现形式，归根结底还是因为 react 框架本身的性能机制所导致的。因为每次调用 setState 都会触发更新，异步操作是为了提高性能，将多个状态合并一起更新，减少 re-render 调用。</p><p>试想一下如果在组件中有以下这样一段代码执行：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> num<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>num <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果 setState 是一个同步执行的机制，那么这个组件会被重新渲染 100 次，这对性能是一个相当大的消耗。</p><p>显然，React 也是想到了这个问题，因此对 setState 做了一些特殊的优化：</p><pre><code>❝ React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新❞</code></pre><p>这也很好的印证了刚才提到的那个例子。</p><p>但是往往在实际的开发工作中，我们可能需要同步的获取到更新之后的数据，那么怎么获取呢？下面介绍几种常用的方法：</p><p><strong>回调函数</strong><br>setState 提供了一个回调函数供开发者使用，在回调函数中，我们可以实时的获取到更新之后的数据。还是以刚才的例子做示范：</p><pre class=" language-js"><code class="language-js">state <span class="token operator">=</span> <span class="token punctuation">{</span>    number<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>number<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//3</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>可以看见此时控制台打印的数据是最新的数据。这也完美的印证了我们的猜想是正确的。</p><p><strong>总结：</strong></p><pre><code>❝ setState本身并不是异步，只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。❞</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一道经典 react 面试题，之前还有点疑惑，为了探究真理，特来加以总结。&lt;/p&gt;
&lt;p&gt;答案：react 的 setState 既可能是同步的，也可能是异步的。 准确地说，在 React 内部机制能检测到的地方， setState 就是异步的；在 React 检测不到</summary>
      
    
    
    
    <category term="react" scheme="https://liang996.github.io/categories/react/"/>
    
    
    <category term="react" scheme="https://liang996.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue中路由跳转传递参数的五种方式</title>
    <link href="https://liang996.github.io/2022/030419579.html"/>
    <id>https://liang996.github.io/2022/030419579.html</id>
    <published>2022-03-04T02:44:16.000Z</published>
    <updated>2023-07-30T04:39:52.541Z</updated>
    
    <content type="html"><![CDATA[<p>日常业务中，路由跳转的同时传递参数是比较常见的，vue 的跳转方式如下：</p><h3 id="1-第一种：-router-link-params"><a href="#1-第一种：-router-link-params" class="headerlink" title="1.第一种： router-link params"></a>1.第一种： router-link params</h3><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>link tag<span class="token operator">=</span><span class="token string">"a"</span> <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{name:'测试页',params:{id:1}}"</span><span class="token operator">></span><span class="token function">点击跳转</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//跳转后页面获取参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id</code></pre><h3 id="2-第二种：router-link-query"><a href="#2-第二种：router-link-query" class="headerlink" title="2.第二种：router-link query"></a>2.第二种：router-link query</h3><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>link tag<span class="token operator">=</span><span class="token string">"a"</span> <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{path:'./test',query:{id:1}}"</span><span class="token operator">></span><span class="token function">点击跳转</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//跳转后页面获取参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id</code></pre><h3 id="3-通过动态路由方式"><a href="#3-通过动态路由方式" class="headerlink" title="3.通过动态路由方式"></a>3.通过动态路由方式</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//路由配置文件中 配置动态路由</span><span class="token punctuation">{</span>     path<span class="token punctuation">:</span> <span class="token string">'/detail/:id'</span><span class="token punctuation">,</span>     name<span class="token punctuation">:</span> <span class="token string">'Detail'</span><span class="token punctuation">,</span>     component<span class="token punctuation">:</span> Detail   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//跳转时页面</span><span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/detail/'</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//跳转后页面获取参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id</code></pre><h3 id="4-params"><a href="#4-params" class="headerlink" title="4.params"></a>4.params</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--html代码:--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clickTo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"测试页"</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳转后页面获取参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><h3 id="5-query"><a href="#5-query" class="headerlink" title="5.query"></a>5.query</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--html代码:--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clickTo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击跳转<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  path<span class="token punctuation">:</span> <span class="token string">"/测试页"</span><span class="token punctuation">,</span>  query<span class="token punctuation">:</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳转后页面获取参数</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><h3 id="补充：注意事项"><a href="#补充：注意事项" class="headerlink" title="补充：注意事项"></a>补充：注意事项</h3><p>总结：</p><p>第 1，2 种，是通过<router-link>标签跳转，第 4，5 种是通过事件跳转页面。</router-link></p><p>第 1，4 种，是通过 name 命名路由的方式跳转传参，跳转后页面刷新，参数会丢失（需要传参跳转的时候，不建议使用）；</p><p>第 2，5 种，是通过 path 路由跳转，跳转后页面刷新，参数不会丢失，跟我们平时写的路径后面携带参数类似：/test?id=1 (推荐使用);</p><p>第 3 种，是动态路由传值跳转，跳转后页面刷新，参数不会丢失。动态路由一般用来传一个参数时居多(如详情页的 id), query、params 可以传递一个也可以传递多个参数 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日常业务中，路由跳转的同时传递参数是比较常见的，vue 的跳转方式如下：&lt;/p&gt;
&lt;h3 id=&quot;1-第一种：-router-link-params&quot;&gt;&lt;a href=&quot;#1-第一种：-router-link-params&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="vue" scheme="https://liang996.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://liang996.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>详解为什么Vue中的v-if和v-for不建议一起用</title>
    <link href="https://liang996.github.io/2022/02229903.html"/>
    <id>https://liang996.github.io/2022/02229903.html</id>
    <published>2022-02-22T02:54:17.000Z</published>
    <updated>2022-02-22T03:17:41.833Z</updated>
    
    <content type="html"><![CDATA[<p>一、作用<br>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染</p><p>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名</p><p>在 v-for 的时候，建议设置 key 值，并且保证每个 key 值是独一无二的，这便于 diff 算法进行优化</p><p>两者在用法上</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>Modal v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"isShow"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in items"</span> <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"item.id"</span><span class="token operator">></span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> item<span class="token punctuation">.</span>label <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span></code></pre><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</p><p>一般我们在两种常见的情况下会倾向于这样做：</p><p>为了过滤一个列表中的项目 (比如 v-for=”user in users” v-if=”user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</p><p>如果避免出现这种情况，则在外层嵌套 template（页面渲染不生成 dom 节点），在这一层进行 v-if 判断，然后在内部进行 v-for 循环</p><p>错误写法</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>ul<span class="token operator">></span>  <span class="token operator">&lt;</span>li    v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"user in activeUsers"</span>    <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"user.id"</span>  <span class="token operator">></span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span></code></pre><p>正确写法</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>ul v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"shouldShowUsers"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>li    v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"user in users"</span>    <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"user.id"</span>  <span class="token operator">></span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span></code></pre><p><code>注意</code>，本文参考的原文链接来自 vue 官网：<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81">https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、作用&lt;br&gt;v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染&lt;/p&gt;
&lt;p&gt;v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或</summary>
      
    
    
    
    <category term="vue 面试" scheme="https://liang996.github.io/categories/vue-%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="vue 面试" scheme="https://liang996.github.io/tags/vue-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>网页图片加载优化方法总结</title>
    <link href="https://liang996.github.io/2022/022247417.html"/>
    <id>https://liang996.github.io/2022/022247417.html</id>
    <published>2022-02-22T02:40:39.000Z</published>
    <updated>2022-02-22T03:17:02.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-压缩图片"><a href="#1-压缩图片" class="headerlink" title="1.压缩图片"></a>1.压缩图片</h2><p>图片压缩是通过压缩减少图片的占用空间，如果您有大量的数码照，或是上传图片的网站有文件大小的限制，您就可以通过此软件来压缩图片大小，压缩图片文件大小，以达到减少大量图片占用磁盘空间，上传照片等效果</p><h2 id="2-图片懒加载"><a href="#2-图片懒加载" class="headerlink" title="2.图片懒加载"></a>2.图片懒加载</h2><p>图片懒加载是一种网页优化技术。图片作为一种网络资源，在被请求时也与普通静态资源一样，将占用网络资源，而一次性将整个页面的所有图片加载完，将大大增加页面的首屏加载时间。为了解决这种问题，通过前后端配合，使图片仅在浏览器当前视窗内出现时才加载该图片，达到减少首屏图片请求数的技术就被称为“图片懒加载”。<br>意义： 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p><p>实现方式：</p><p>1.第一种是纯粹的延迟加载，使用 setTimeOut 或 setInterval 进行加载延迟.</p><p>2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。</p><p>3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离前开始加载，这样能保证用户拉下时正好能看到图片。</p><h2 id="3-使用-CDN-加速"><a href="#3-使用-CDN-加速" class="headerlink" title="3.使用 CDN 加速"></a>3.使用 CDN 加速</h2><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p><h2 id="4-使用-base64-编码代替图片"><a href="#4-使用-base64-编码代替图片" class="headerlink" title="4.使用 base64 编码代替图片"></a>4.使用 base64 编码代替图片</h2><p>原理：将图片转换为 base64 编码字符串 inline 到页面或 css 中<br>场景：适用于图片大小小于 2KB，页面上引用图片总数不多的情况</p><p>优势：减少 http 的请求次数，并可以放到后台数据库中，只传输字符串，有较多的构建工具可以直接实现<br>劣势：这种方法仅限于图片总数较少，而且图片大小小于 2KB 的情况。否则图片字符串会变得很长很长</p><p><code>注意</code>，本文参考的原文链接：<a href="https://blog.csdn.net/ywy502/article/details/90756219">https://blog.csdn.net/ywy502/article/details/90756219</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-压缩图片&quot;&gt;&lt;a href=&quot;#1-压缩图片&quot; class=&quot;headerlink&quot; title=&quot;1.压缩图片&quot;&gt;&lt;/a&gt;1.压缩图片&lt;/h2&gt;&lt;p&gt;图片压缩是通过压缩减少图片的占用空间，如果您有大量的数码照，或是上传图片的网站有文件大小的限制，您就可以通过</summary>
      
    
    
    
    <category term="性能优化" scheme="https://liang996.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="https://liang996.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>link和@import的区别有哪些</title>
    <link href="https://liang996.github.io/2022/022265068.html"/>
    <id>https://liang996.github.io/2022/022265068.html</id>
    <published>2022-02-22T02:22:17.000Z</published>
    <updated>2022-02-22T03:18:21.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>都属于外部引用 CSS 方式</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h4 id="1-写法不同"><a href="#1-写法不同" class="headerlink" title="1.写法不同"></a>1.写法不同</h4><pre class=" language-css"><code class="language-css">&lt;link rel=<span class="token string">"stylesheet"</span> rev=<span class="token string">"stylesheet"</span> href=<span class="token string">"CSS文件"</span> type=<span class="token string">"text/css"</span> media=<span class="token string">"all"</span> /></code></pre><pre class=" language-css"><code class="language-css">&lt;style type=<span class="token string">"text/css"</span> media=<span class="token string">"screen"</span>><span class="token atrule"><span class="token rule">@import</span> <span class="token url">url("CSS文件")</span><span class="token punctuation">;</span></span>&lt;/style></code></pre><h4 id="2-加载顺序区别"><a href="#2-加载顺序区别" class="headerlink" title="2.加载顺序区别"></a>2.加载顺序区别</h4><pre><code>A.link引用CSS时，在页面载入时同时加载；B.@import需要页面网页完全载入以后加载。</code></pre><h4 id="3-兼容不同"><a href="#3-兼容不同" class="headerlink" title="3.兼容不同"></a>3.兼容不同</h4><pre><code>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</code></pre><h3 id="4、从属关系区别"><a href="#4、从属关系区别" class="headerlink" title="4、从属关系区别"></a>4、从属关系区别</h3><pre><code>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import是 CSS 提供的语法规则，只有导入样式表的作用；</code></pre><h3 id="5-DOM-可控性区别"><a href="#5-DOM-可控性区别" class="headerlink" title="5.DOM 可控性区别"></a>5.DOM 可控性区别</h3><pre><code>link支持使用Javascript控制DOM去改变样式；而@import不支持。</code></pre><h2 id="补充-1-写法最优方法"><a href="#补充-1-写法最优方法" class="headerlink" title="补充 1.写法最优方法"></a>补充 1.写法最优方法</h2><p>@import url(style.css) 和@import url(“style.css”)是最优的写法选择，兼容的浏览器最多。</p><p>从字节优化的角度来看@import url(style.css)最值得推荐。</p><h2 id="补充-2-link-与-import-区别与选择"><a href="#补充-2-link-与-import-区别与选择" class="headerlink" title="补充 2.link 与@import 区别与选择"></a>补充 2.link 与@import 区别与选择</h2><p>首页 link 和 import 语法结构不同，前者<code>&lt;link&gt;</code>是 html 标签，只能放入 html 源代码中使用，后者可看作为 css 样式，作用是引入 css 样式功能。import 在 html 使用时候需要<code>&lt;style type="text/css"&gt;</code>标签，同时可以直接“@import url(CSS 文件路径地址);”放如 css 文件或 css 代码里引入其它 css 文件。</p><p>本质上两者使用选择区别不大，但为了软件中编辑布局网页 html 代码，一般使用 link 较多，也推荐使用 link。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;headerlink&quot; title=&quot;相同点&quot;&gt;&lt;/a&gt;相同点&lt;/h2&gt;&lt;p&gt;都属于外部引用 CSS 方式&lt;/p&gt;
&lt;h2 id=&quot;不同点&quot;&gt;&lt;a href=&quot;#不同点&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="css" scheme="https://liang996.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://liang996.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js继承的几种方式</title>
    <link href="https://liang996.github.io/2022/022218233.html"/>
    <id>https://liang996.github.io/2022/022218233.html</id>
    <published>2022-02-22T01:50:32.000Z</published>
    <updated>2022-02-22T03:22:08.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-原型链方式"><a href="#1-原型链方式" class="headerlink" title="1.原型链方式"></a>1.原型链方式</h2><p>基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。</p><p>构造函数，原型，实例之间的关系：每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p><p>原型链实现继承例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Father<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSuperValue <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//继承了Father</span>Son<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Son<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSubValue <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>优点：</p><p>简单易于实现，父类的新增的实例与属性子类都能访问</p><p>缺点：</p><p>可以在子类中增加实例属性，如果要新增加原型属性和方法需要在 new 父类构造函数的后面</p><p>无法实现多继承</p><p>创建子类实例时，不能向父类构造函数中传参数</p><h2 id="2-借用构造函数（伪造对象、经典继承）"><a href="#2-借用构造函数（伪造对象、经典继承）" class="headerlink" title="2.借用构造函数（伪造对象、经典继承）"></a>2.借用构造函数（伪造对象、经典继承）</h2><p>基本思想：在子类型构造函数的内部调用超类构造函数，通过使用 call()和 apply()方法可以在新创建的对象上执行构造函数。</p><p>例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Father<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//继承了Father</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red","blue","green","black"</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"red","blue","green"</span></code></pre><p>优点：</p><p>解决了子类构造函数向父类构造函数中传递参数</p><p>可以实现多继承（call 或者 apply 多个父类）</p><p>缺点：</p><p>方法都在构造函数中定义，无法复用</p><p>不能继承原型属性/方法，只能继承父类的实例属性和方法</p><h2 id="3-ES6-class"><a href="#3-ES6-class" class="headerlink" title="3.ES6 class"></a>3.ES6 class</h2><p>代码量少，易懂</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//class 相当于es5中构造函数</span><span class="token comment" spellcheck="true">//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中</span><span class="token comment" spellcheck="true">//class中定义的所有方法是不可枚举的</span><span class="token comment" spellcheck="true">//class中只能定义方法，不能定义对象，变量等</span><span class="token comment" spellcheck="true">//class和方法内默认都是严格模式</span><span class="token comment" spellcheck="true">//es5中constructor为隐式属性</span><span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"wang"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token string">"27"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> eat food`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//继承父类</span><span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ren"</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token string">"27"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//继承父类属性</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//继承父类方法</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> wonmanObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token string">"xiaoxiami"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wonmanObj<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-原型链方式&quot;&gt;&lt;a href=&quot;#1-原型链方式&quot; class=&quot;headerlink&quot; title=&quot;1.原型链方式&quot;&gt;&lt;/a&gt;1.原型链方式&lt;/h2&gt;&lt;p&gt;基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。&lt;/p&gt;
&lt;p&gt;构造函数，原型，实</summary>
      
    
    
    
    <category term="javaScript" scheme="https://liang996.github.io/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://liang996.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>js检测数据类型的四种办法</title>
    <link href="https://liang996.github.io/2022/011725344.html"/>
    <id>https://liang996.github.io/2022/011725344.html</id>
    <published>2022-01-17T02:55:06.000Z</published>
    <updated>2022-01-17T08:03:17.688Z</updated>
    
    <content type="html"><![CDATA[<p>最近经常听到前端朋友在面试时，会被问到 js 检测数据类型的四种办法，为此我来总结一下，温故而知新。</p><h2 id="js-检测数据类型的四种办法"><a href="#js-检测数据类型的四种办法" class="headerlink" title="js 检测数据类型的四种办法"></a>js 检测数据类型的四种办法</h2><ol><li><p>typeof</p></li><li><p>instanceof</p></li><li><p>constructor</p></li><li><p>Object.prototype.toString.call()</p></li></ol><p>下面我来依次说明</p><p>先举几个例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"字符串"</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> e <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"22"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">var</span> h <span class="token operator">=</span> undefined<span class="token punctuation">;</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h2><p>typeof：返回一个字符串,typeof 也是最常见的判断方法</p><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> string<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> b<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> number<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> c<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> object<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> d<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> object<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> e<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> <span class="token keyword">function</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> f<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> <span class="token keyword">function</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> g<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> object<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> h<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> undefined<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> i<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> boolean<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> j<span class="token punctuation">)</span>  <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> object</code></pre><p>从上面可以看出，typeof 对 Array，null 是不起作用的, typeof null 返回类型错误，返回 object，typeof Array 返回 object。</p><p>引用类型，除了 function 返回 function 类型外，其他均返回 object。</p><p><code>注意</code>:其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。</p><h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h2><p>instanceof:用于判断一个变量是否为某个类的实例.利用 instanceof 来判断 A 是否为 B 的实例，表达为 A instanceof B，返回一个布尔值。instanceof 的原理是通过检测对象的原型链上是否含有类型的原型。</p><p>还是以上面的例子来判断，暂且不考虑 null 和 undefined（这两个比较特殊），看看控制台输出什么</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>可以看到前三个都是以对象字面量创建的基本数据类型，但是却不是所属类的实例，这个就有点怪了。后面四个是引用数据类型，可以得到正确的结果。如果我们通过 new 关键字去创建基本数据类型，你会发现，这时就会输出 true,如下:</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>接下再来说说为什么 null 和 undefined 为什么比较特殊，实际上按理来说，null 的所属类就是 Null，undefined 就是 Undefined，但事实并非如此，由于浏览器压根不认识这 null 和 undefined，直接报错。在第一个例子你可能已经发现了，typeof null 的结果是 object，typeof undefined 的结果是 undefined</p><p><code>注意</code>:尤其是 null，其实这是 js 设计的一个败笔，早期准备更改 null 的类型为 null，由于当时已经有大量网站使用了 null，如果更改，将导致很多网站的逻辑出现漏洞问题，就没有更改过来，于是一直遗留到现在。作为学习者，我们只需要记住就好。</p><h2 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h2><p>constructor 是原型 prototype 的一个属性，当函数被定义时候，js 引擎会为函数添加原型 prototype，并且这个 prototype 中 constructor 属性指向函数引用， 因此重写 prototype 会丢失原来的 constructor。</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//console.log((null).constructor === Null)</span><span class="token comment" spellcheck="true">//console.log((undefined).constructor === Undefined)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p><code>注意</code>:</p><p>1：null 和 undefined 无 constructor，这种方法判断不了。</p><p>2：还有，如果自定义对象，开发者重写 prototype 之后，原有的 constructor 会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p><h2 id="4-Object-prototype-toString-call"><a href="#4-Object-prototype-toString-call" class="headerlink" title="4.Object.prototype.toString.call()"></a>4.Object.prototype.toString.call()</h2><p>toString()方法是 Object 原型上的方法，调用此方法，返回格式为[object,xxx]，xxx 即为判断的结果。对于 Object 对象可以直接调用 Object.prototype.toString()，对于其他数据类型，需要通过.call()来调用。</p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object String]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Number]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Boolean]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[object Symbol]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Undefined]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Null]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Function]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Date]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Array]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object RegExp]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Error]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object HTMLDocument]</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[object global] window 是全局对象 global 的引用</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近经常听到前端朋友在面试时，会被问到 js 检测数据类型的四种办法，为此我来总结一下，温故而知新。&lt;/p&gt;
&lt;h2 id=&quot;js-检测数据类型的四种办法&quot;&gt;&lt;a href=&quot;#js-检测数据类型的四种办法&quot; class=&quot;headerlink&quot; title=&quot;js 检测数</summary>
      
    
    
    
    <category term="javaScript" scheme="https://liang996.github.io/categories/javaScript/"/>
    
    
    <category term="javaScript" scheme="https://liang996.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>个人面试记录二</title>
    <link href="https://liang996.github.io/2021/121522883.html"/>
    <id>https://liang996.github.io/2021/121522883.html</id>
    <published>2021-12-15T09:14:38.000Z</published>
    <updated>2021-12-15T09:17:15.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-笔记总结"><a href="#js-笔记总结" class="headerlink" title="js 笔记总结"></a>js 笔记总结</h1><h2 id="盒子塌陷的原因？解决方式"><a href="#盒子塌陷的原因？解决方式" class="headerlink" title="盒子塌陷的原因？解决方式"></a>盒子塌陷的原因？解决方式</h2><pre><code>原因: 1. 浮动导致的塌陷,浮动会脱落标准流2. 嵌套的两个盒子,子盒子设置margin-top会导致父盒子一下下移解决方法:第一种情况 1 清除浮动;  2 给父盒子加高度;3 给父元素添加overflow:hidden第二种情况 1 给父元素加上边框; 2 给父元素添加overflow:hidden</code></pre><h2 id="不定宽高的-div-水平垂直居中"><a href="#不定宽高的-div-水平垂直居中" class="headerlink" title="不定宽高的 div 水平垂直居中"></a>不定宽高的 div 水平垂直居中</h2><pre><code>答: 1、使用定位和translate来实现        div{            position:absolute;            top: 50%;             left: 50%;             transform: translate(-50%, -50%);        }    2、使用flex来实现        div {           display: flex;           justify-content:center; //子元素水平居中           align-items:center; //子元素垂直居中         }    3、使用定位和margin来实现        #box {            width: 100px;            height: 100px;            position: relative;        }        #content {            width: 50px;            height: 50px;            position: absolute;            top: 0;            right: 0;            bottom: 0;            left: 0;            margin: auto;        }</code></pre><h2 id="css-写一个三角形"><a href="#css-写一个三角形" class="headerlink" title="css 写一个三角形"></a>css 写一个三角形</h2><pre><code>答: div {    width: 0px;      height: 0px;      border: 30px solid transparent;      border-left-color: rgb(233, 42, 191)    }   不设置宽高，设置边框中一个边框大小及颜色，其他三边框为透明色</code></pre><h2 id="css-选择器的优先级"><a href="#css-选择器的优先级" class="headerlink" title="css 选择器的优先级"></a>css 选择器的优先级</h2><pre><code>答: !important&gt;行内样式&gt;id选择器&gt;类/属性/伪类选择器&gt;伪元素/标签选择器&gt;通配符选择器*</code></pre><h2 id="px、em-和-rem-的区别"><a href="#px、em-和-rem-的区别" class="headerlink" title="px、em 和 rem 的区别"></a>px、em 和 rem 的区别</h2><pre><code>答: px 是固定单位,    em 是相对单位,相当于当前文字的大小,如果没有就找父元素    rem 也是相对单位,相对于html的fontsize的大小</code></pre><h2 id="rem-布局的原理"><a href="#rem-布局的原理" class="headerlink" title="rem 布局的原理"></a>rem 布局的原理</h2><pre><code>答:rem是css的相对单位，rem缩放是相对根元素字体大小.   rem布局的本质是等比缩放，一般是基于宽度。   rem会配合媒体查询（或js动态获取屏幕宽度）来一起使用，来实现屏幕的适配。</code></pre><h2 id="什么是重绘和重排"><a href="#什么是重绘和重排" class="headerlink" title="什么是重绘和重排"></a>什么是重绘和重排</h2><pre><code>答:    重排: 当DOM元素影响了元素的几何属性（例如宽和高），浏览器需要重新计算元素的几何属性，同样其它元素的几何属性也会和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为“重排”。    重绘: 完成重排后，浏览器会重新绘制受影响的部分到屏幕上中，该过程称为“重绘”。    当我们改变DOM的大小，增加删除都会导致重排，当给DOM元素改变颜色的时候，会导致重绘，重排一定会重绘，重绘不会重排。重排会影响性能，所以我们尽快能的减少重排的操作</code></pre><h2 id="flex-常用的容器属性"><a href="#flex-常用的容器属性" class="headerlink" title="flex 常用的容器属性"></a>flex 常用的容器属性</h2><pre><code>答:1. flex-direction: 设置容器中的主轴方向2. flex-wrap: 项目在主轴方向上是否换行显示3. justify-content: 设置容器中的项目在主轴上的对齐方式4. align-items: 单行项目在侧轴上的排列方式5. align-content: 多行项目侧轴上的对齐方式6. flex-flow: 是flex-direction和flex-wrap的合写, 默认值为row nowrap</code></pre><h2 id="如何设置比-12px-更小的字体"><a href="#如何设置比-12px-更小的字体" class="headerlink" title="如何设置比 12px 更小的字体"></a>如何设置比 12px 更小的字体</h2><pre><code>  p {        font-size:12px;        -webkit-transform:scale(0.8);    }</code></pre><h2 id="H5-新增了那些特性"><a href="#H5-新增了那些特性" class="headerlink" title="H5 新增了那些特性"></a>H5 新增了那些特性</h2><pre><code>答:1. 语义化标签: header nav section article aside footer2. 多媒体标签: video audio3. 表单控件: number search email tel date file time  url4. 本地离线存储 localStorage 长期存储数据,改变浏览器数据不会丢失              sessionStorage 浏览器关闭数据会丢失5. 自定义属性 data-*6. 画布 Canvas7. 拖拽释放 (Drap and Drap) API ondrop8. 新的技术文本 webworker9. 地理位置 (Geolocation) API</code></pre><h2 id="C3-新增了那些特性"><a href="#C3-新增了那些特性" class="headerlink" title="C3 新增了那些特性"></a>C3 新增了那些特性</h2><pre><code>答:1. 圆角 border-radius2. 盒子模型 box-sizing3. 阴影 box-shadow 盒子阴影  text-shadow 文字阴影4. 过渡 transition5. 2D转换transform  translate(平移) scale(缩放)  skew(斜切) rotate(旋转) transform-origin 控制转换中心点6. 3D转换 perspective(透视距)  transform-style(3D控件效果)7. 渐变 linear-gradient radial-gradient8. 弹性布局 flex9. 媒体查询 @media screen and () {...}10. 边框图片 border-image11. 自定义动画 @keyframes    animation12. 颜色 新增RGBA HSLA模式13. 背景 background-size   background-origin   background-clip</code></pre><h2 id="js-的数据类型有哪些"><a href="#js-的数据类型有哪些" class="headerlink" title="js 的数据类型有哪些"></a>js 的数据类型有哪些</h2><pre><code>答: 简单数据类型: number string boolean undefined   null    复制数据类型: object  function  array</code></pre><h2 id="typeof-返回的数据类型"><a href="#typeof-返回的数据类型" class="headerlink" title="typeof 返回的数据类型"></a>typeof 返回的数据类型</h2><pre><code>答: number string boolean undefined  object  function   特殊情况：   typeof null --&gt;object   typeof array --&gt;object   typeof typeof 任何类型  --&gt;string</code></pre><h2 id="返回-false-的情况有哪些"><a href="#返回-false-的情况有哪些" class="headerlink" title="返回 false 的情况有哪些"></a>返回 false 的情况有哪些</h2><pre><code>答: 0  ""   null  false  NaN  undefined  不成立的表达式</code></pre><h2 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h2><pre><code>答: this是个关键字,它的指向和函数的调用方式有关1. 函数调用模式, this指向window2. 构造函数调用模式, this指向新创建的实例对象3. 方法调用模式, this指向调用方法的对象4. 上下文调用模式, call和apply方法中, this指向方法内的第一个参数  bind方法中, bind创建的新函数的this绑定为bind方法中新的函数5. 在事件处理函数中,this指向触发事件的当前元素6. 定时器中,this指向window7. 箭头函数中没有this指向问题,它的this和外层作用域的this保持一致8. 匿名函数中的this总是指向window</code></pre><h2 id="new-操作符做了什么"><a href="#new-操作符做了什么" class="headerlink" title="new 操作符做了什么"></a>new 操作符做了什么</h2><pre><code>答:  1. 创建一个新对象    2. 函数内部的this指向这个对象    3. 执行函数体    4. 自动返回这个函数</code></pre><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="==和===的区别"></a>==和===的区别</h2><pre class=" language-js"><code class="language-js">答：<span class="token operator">==</span> 表示是相等，只比较内容   <span class="token operator">===</span> 表示是全等，不仅比较内容，也比较类型</code></pre><h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h2><pre class=" language-js"><code class="language-js">答：<span class="token keyword">null</span> 表示空值 没有获取到。<span class="token keyword">typeof</span> <span class="token keyword">null</span> 返回<span class="token string">"object"</span>   undefined 表示未定义，声明没有值。<span class="token keyword">typeof</span> undefined 返回<span class="token string">"undefined"</span></code></pre><h2 id="localStorage、sessionStorage-和-cookie-的区别"><a href="#localStorage、sessionStorage-和-cookie-的区别" class="headerlink" title="localStorage、sessionStorage 和 cookie 的区别"></a>localStorage、sessionStorage 和 cookie 的区别</h2><pre><code>答: 共同点: 都可以用来存储数据。    区别:    1. 请求不同:        cookie 数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。        sessionStorage 和 localStorage不会自动把数据发给服务器，仅在本地保存。    2. 存储大小限制也不同:        cookie 数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。        sessionStorage 和 localStorage虽然也有存储大小的限制，但比cookie大得多，sessionStorage和localStorage约5M 。    3. 数据有效期不同:         sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；         localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；         cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</code></pre><h2 id="js-的运行机制是什么"><a href="#js-的运行机制是什么" class="headerlink" title="js 的运行机制是什么"></a>js 的运行机制是什么</h2><pre class=" language-js"><code class="language-js">答：js是单线程执行的，页面加载时，会自上而下执行主线程上的同步任务，当主线程代码执行完毕时，才开始执行在任务队列中的异步任务。具体如下    <span class="token number">1</span><span class="token punctuation">.</span>所有同步任务都在主线程上执行，形成一个执行栈。    <span class="token number">2</span><span class="token punctuation">.</span>主线程之外，还存在一个<span class="token string">"任务队列(eventloop队列或者消息队列)"</span>。只要异步任务有了运行结果，就在<span class="token string">"任务队列"</span>之中放置一个事件。    <span class="token number">3</span><span class="token punctuation">.</span>一旦<span class="token string">"执行栈"</span>中的所有同步任务执行完毕，系统就会读取<span class="token string">"任务队列"</span>，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。    <span class="token number">4</span><span class="token punctuation">.</span>主线程不断重复上面的第三步。</code></pre><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><pre class=" language-js"><code class="language-js">答：<span class="token number">1</span>、面向对象是一种软件开发的思想和面向过程是相对应的，就是把程序看作一个对象，将属性和方法封装其中，以提高代码的灵活性、复用性、可扩展性。  <span class="token number">2</span>、面向对象有三大特性：封装、继承、多态。       封装：把相关的信息（无论数据或方法）存储在对象中的能力       继承：由另一个类（或多个类）得来类的属性和方法的能力       多态：编写能以多种方法运行的函数或方法的能力   <span class="token number">3</span>、js中对象是一个无序的数据集合或者也可以说是属性和方法的集合，可以动态的添加属性可方法。   <span class="token number">4</span>、js是基于对象，但是也使用了嵌入了面向对象的思想，可以实现继承和封装，这样也可以提供代码的灵活性和复用性。</code></pre><h2 id="那些情况会得到伪数组"><a href="#那些情况会得到伪数组" class="headerlink" title="那些情况会得到伪数组"></a>那些情况会得到伪数组</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、参数 arguments，<span class="token number">2</span>、DOM 对象列表（比如通过 document<span class="token punctuation">.</span>getElementsByTags 得到的列表）、childNodes也是伪数组<span class="token number">3</span>、jQuery 对象（比如 <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span>）</code></pre><h2 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a>let、const、var 的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、<span class="token keyword">var</span>声明变量存在提升（提升当前作用域最顶端），<span class="token keyword">let</span>和<span class="token keyword">const</span>是不存在变量提升的情况<span class="token number">2</span>、<span class="token keyword">var</span>没有块级作用，<span class="token keyword">let</span>和<span class="token keyword">const</span>存在块级作用域<span class="token number">3</span>、<span class="token keyword">var</span>允许重复声明，<span class="token keyword">let</span>和<span class="token keyword">const</span>在同一作用域不允许重复声明<span class="token number">4</span>、<span class="token keyword">var</span>和<span class="token keyword">let</span>声明变量可以修改，<span class="token keyword">const</span>是常量不能改变</code></pre><h2 id="怎么理解事件循环机制"><a href="#怎么理解事件循环机制" class="headerlink" title="怎么理解事件循环机制"></a>怎么理解事件循环机制</h2><pre class=" language-js"><code class="language-js">    <span class="token number">1</span>、JavaScript 是一门单线程语言<span class="token punctuation">.</span>单线程可能会出现阻塞的情况，所js分了同步任务和异步任务。    <span class="token number">2</span>、同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue（事件队列） 。主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop <span class="token punctuation">(</span>事件循环<span class="token punctuation">)</span>。</code></pre><h2 id="什么是作用域链"><a href="#什么是作用域链" class="headerlink" title="什么是作用域链"></a>什么是作用域链</h2><pre class=" language-js"><code class="language-js">    <span class="token number">1</span>、作用域：分全局作用域和局部作用域    <span class="token number">2</span>、在访问一个变量时，首先在当前作用域中找，如果找不到再到外层作用域中找，这样一层一层的查找，就形成了作用域链。</code></pre><h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、<span class="token keyword">for</span>…<span class="token keyword">in</span>是遍历数组、对象的key下标<span class="token number">2</span>、<span class="token keyword">for</span>…<span class="token keyword">of</span>是遍历数组的value属性例如：<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token number">1</span>）<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//0 1</span>  <span class="token punctuation">}</span>  <span class="token number">2</span>）<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a b</span>  <span class="token punctuation">}</span></code></pre><h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、值类型    <span class="token number">1</span>）基本类型数据是值类型    <span class="token number">2</span>）保存与复制的是值本身    <span class="token number">3</span>）使用<span class="token keyword">typeof</span>检测数据的类型<span class="token number">2</span>、引用类型    <span class="token number">1</span>）保存与复制的是指向对象的一个指针    <span class="token number">2</span>）使用<span class="token keyword">instanceof</span>检测数据类型    <span class="token number">3</span>）使用 <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法构造出的对象是引用型</code></pre><h2 id="什么是深拷贝什么是浅拷贝"><a href="#什么是深拷贝什么是浅拷贝" class="headerlink" title="什么是深拷贝什么是浅拷贝"></a>什么是深拷贝什么是浅拷贝</h2><pre><code>答: 浅拷贝: 拷贝对象的一层属性,如果对象里面还有对象,拷贝的是地址, 两者之间修改会有影响,适用于对象里面属性的值是简单数据类型的.    深拷贝: 拷贝对象的多层属性,如果对象里面还有对象,会继续拷贝,使用递归去实现.</code></pre><h2 id="如何实现深拷贝和浅拷贝"><a href="#如何实现深拷贝和浅拷贝" class="headerlink" title="如何实现深拷贝和浅拷贝"></a>如何实现深拷贝和浅拷贝</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 浅拷贝<span class="token punctuation">:</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">"UI"</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  love<span class="token punctuation">:</span> <span class="token string">"eat"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    newObj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> newObj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>深拷贝<span class="token punctuation">:</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">"前端"</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span>  love<span class="token punctuation">:</span> <span class="token punctuation">{</span>    friuts<span class="token punctuation">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span>    meat<span class="token punctuation">:</span> <span class="token string">"beef"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* if (typeof obj[k] == 'object') {          newObj[k] = getObj(obj[k])        } else {          newObj[k] = obj[k]        } */</span>    newObj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"object"</span> <span class="token operator">?</span> <span class="token function">getObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> newObj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="对闭包的理解？并能举出闭包的例子"><a href="#对闭包的理解？并能举出闭包的例子" class="headerlink" title="对闭包的理解？并能举出闭包的例子"></a>对闭包的理解？并能举出闭包的例子</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 闭包 <span class="token function">函数和声明该函数的词法环境的组合</span><span class="token punctuation">(</span>两个嵌套关系的函数<span class="token punctuation">,</span>内部函数可以访问外部函数定义的变量<span class="token punctuation">)</span>    闭包的优点：<span class="token number">1</span>、形成私有空间，避免全局变量的污染               <span class="token number">2</span>、持久化内存，保存数据    闭包的缺点：<span class="token number">1</span>、持久化内存，导致内存泄露    解决：<span class="token number">1</span>、尽快避免函数的嵌套，以及变量的引用          <span class="token number">2</span>、执行完的变量，可以赋值<span class="token keyword">null</span>，让垃圾回收机制，进行回收释放内存（当不在引用的变量，垃圾回收机制就会回收）例<span class="token punctuation">:</span> 点击li获取当前下标    <span class="token operator">&lt;</span>ul<span class="token operator">></span>      <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token number">111</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>      <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token number">222</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>      <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token number">333</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>      <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token number">444</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>      <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token number">555</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>      <span class="token keyword">var</span> lis <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lis<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>          lis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>      <span class="token punctuation">}</span></code></pre><h2 id="什么是原型和原型链"><a href="#什么是原型和原型链" class="headerlink" title="什么是原型和原型链"></a>什么是原型和原型链</h2><pre><code>答: 原型: 函数都有prototype属性,这个属性的值是个对象,称之为原型   原型链: 对象都有__proto__属性,这个属性指向它的原型对象,原型对象也是对象,也有__proto__属性,指向原型对象的原型对象,这样一层一层形成的链式结构称为原型链.</code></pre><h2 id="call、apply-和-bind-的区别"><a href="#call、apply-和-bind-的区别" class="headerlink" title="call、apply 和 bind 的区别"></a>call、apply 和 bind 的区别</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">.</span> call和apply方法都可以调用函数<span class="token punctuation">,</span>方法内的第一个参数可以修改<span class="token keyword">this</span>的指向    <span class="token number">2</span><span class="token punctuation">.</span> call方法可以有多个参数<span class="token punctuation">,</span>除了第一个参数<span class="token punctuation">,</span>其他参数作为实参传递给函数             apply方法最多有<span class="token number">2</span>个参数<span class="token punctuation">,</span>第二个参数是个数组或伪数组<span class="token punctuation">,</span>数组里面的每一项作为实参传递给函数    <span class="token number">3</span><span class="token punctuation">.</span> bind方法不能调用函数<span class="token punctuation">,</span>它会创建一个副本函数<span class="token punctuation">,</span>并且绑定新函数的<span class="token keyword">this</span>指向bind返回的新的函数</code></pre><h2 id="es6-es10-新增常用方法"><a href="#es6-es10-新增常用方法" class="headerlink" title="es6-es10 新增常用方法"></a>es6-es10 新增常用方法</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span>es6<span class="token punctuation">:</span><span class="token number">1</span>、<span class="token keyword">let</span>、<span class="token keyword">const</span><span class="token number">2</span>、解构赋值   <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token number">3</span>、箭头函数   <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token number">4</span>、字符串模板  <span class="token template-string"><span class="token string">``</span></span><span class="token number">5</span>、扩展运算符  <span class="token operator">...</span>arr<span class="token number">6</span>、数组方法：map、filter、some等等<span class="token number">7</span>、类：<span class="token keyword">class</span>关键字<span class="token number">8</span>、promise 主要用于异步计算<span class="token number">9</span>、函数参数默认值 <span class="token function">fn</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token number">10</span>、对象属性简写 <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">}</span><span class="token number">11</span>、模块化：<span class="token keyword">import</span><span class="token operator">--</span>引入、exprot <span class="token keyword">default</span><span class="token operator">--</span>导出es7<span class="token punctuation">:</span><span class="token number">1</span><span class="token function">、includes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回<span class="token boolean">true</span>，否则返回<span class="token boolean">false</span>。es8<span class="token punctuation">:</span><span class="token number">1</span>、<span class="token keyword">async</span><span class="token operator">/</span><span class="token keyword">await</span>es9：<span class="token number">1</span>、Promise<span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 允许你指定最终的逻辑es10<span class="token punctuation">:</span><span class="token number">1</span><span class="token function">、数组Array的flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">和flatmap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   flat<span class="token punctuation">:</span>方法最基本的作用就是数组降维      <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            arr1<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// [1, 2, 3, 4]</span>        <span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// [1, 2, 3, 4, 5, 6]</span>        <span class="token comment" spellcheck="true">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span>        arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// [1, 2, 3, 4, 5, 6]</span>   flatmap<span class="token punctuation">:</span><span class="token function">方法首先使用映射函数映射</span><span class="token punctuation">(</span>遍历<span class="token punctuation">)</span>每个元素，然后将结果压缩成一个新数组</code></pre><h2 id="怎么理解函数的防抖和节流"><a href="#怎么理解函数的防抖和节流" class="headerlink" title="怎么理解函数的防抖和节流"></a>怎么理解函数的防抖和节流</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span><span class="token number">1</span>、定义：防抖<span class="token punctuation">:</span> 就是指触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。     例如：设定<span class="token number">1000</span>毫秒执行，当你触发事件了，他会<span class="token number">1000</span>毫秒后执行，但是在还剩<span class="token number">500</span>毫秒的时候你又触发了事件，那就会重新开始<span class="token number">1000</span>毫秒之后再执行节流<span class="token punctuation">:</span> 就是指连续触发事件但是在设定的一段时间内中只执行一次函数。     例如：设定<span class="token number">1000</span>毫秒执行，那你在<span class="token number">1000</span>毫秒触发在多次，也只在<span class="token number">1000</span>毫秒后执行一次<span class="token number">2</span>、防抖和节流的实现：    <span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"ipt"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>      <span class="token keyword">var</span> timerId <span class="token operator">=</span> <span class="token keyword">null</span>      document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onkeyup <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 防抖</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timerId <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是防抖'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.ipt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onkeyup <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 节流</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timerId <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span>        <span class="token punctuation">}</span>        timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是节流'</span><span class="token punctuation">)</span>          timerId <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span></code></pre><h2 id="异步函数有哪些"><a href="#异步函数有哪些" class="headerlink" title="异步函数有哪些"></a>异步函数有哪些</h2><pre class=" language-js"><code class="language-js">JavaScript 中常见的异步函数有：定时器，事件和 ajax 等</code></pre><h2 id="伪数组有哪些"><a href="#伪数组有哪些" class="headerlink" title="伪数组有哪些"></a>伪数组有哪些</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、参数 arguments，<span class="token number">2</span>、DOM 对象列表（比如通过 document<span class="token punctuation">.</span>getElementsByTags 得到的列表）、childNodes也是伪数组<span class="token number">3</span>、jQuery 对象（比如 <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span>）</code></pre><h2 id="真数组和伪数组的区别"><a href="#真数组和伪数组的区别" class="headerlink" title="真数组和伪数组的区别"></a>真数组和伪数组的区别</h2><pre class=" language-js"><code class="language-js">伪数组：<span class="token number">1</span>、拥有length属性<span class="token number">2</span>、不具有数组的方法<span class="token number">3</span>、伪数组是一个Object，真数组是Array<span class="token number">4</span>、伪数组的长度不可变，真数组的长度是可变的</code></pre><h2 id="伪数组怎么转真数组"><a href="#伪数组怎么转真数组" class="headerlink" title="伪数组怎么转真数组"></a>伪数组怎么转真数组</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、<span class="token keyword">let</span> newArr <span class="token operator">=</span> Array<span class="token punctuation">.</span>protype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>伪数组<span class="token punctuation">)</span><span class="token number">2</span>、<span class="token keyword">let</span> newArr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>伪数组<span class="token punctuation">)</span><span class="token punctuation">,</span>ES6的新语法<span class="token number">3</span>、<span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>伪数组<span class="token punctuation">]</span>，使用扩展运算符<span class="token punctuation">,</span>也是ES6的语法</code></pre><h2 id="数组如何进行降维（扁平化）"><a href="#数组如何进行降维（扁平化）" class="headerlink" title="数组如何进行降维（扁平化）"></a>数组如何进行降维（扁平化）</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、利用Array<span class="token punctuation">.</span>some方法判断数组中是否还存在数组，es6展开运算符连接数组       <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token number">2</span>、使用数组的concat方法　   <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>     <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     result <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token number">3</span>、 使用数组的concat方法和扩展运算符    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token number">4</span>、es6中的flat函数也可以实现数组的扁平化    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'中'</span><span class="token punctuation">,</span><span class="token string">'文'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span> <span class="token number">Infinity</span> <span class="token punctuation">)</span>    注意：flat方法的infinity属性，可以实现多层数组的降维</code></pre><h1 id="ajax-笔记总结"><a href="#ajax-笔记总结" class="headerlink" title="ajax 笔记总结"></a>ajax 笔记总结</h1><h2 id="什么是事件流"><a href="#什么是事件流" class="headerlink" title="什么是事件流"></a>什么是事件流</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 事件流是指事件传播的顺序<span class="token punctuation">,</span> <span class="token punctuation">(</span>由事件捕获<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>目标事件<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> 事件冒泡<span class="token punctuation">;</span></code></pre><h2 id="如何阻止冒泡和默认行为"><a href="#如何阻止冒泡和默认行为" class="headerlink" title="如何阻止冒泡和默认行为"></a>如何阻止冒泡和默认行为</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 阻止冒泡和捕获  e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    阻止默认行为   e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token boolean">false</span>    注意：addEventListener注册的事件，在高浏览器版本中，<span class="token keyword">return</span> <span class="token boolean">false</span>将没有效果，必须要用事件对象</code></pre><h2 id="原生注册事件的方式有哪些？区别是什么"><a href="#原生注册事件的方式有哪些？区别是什么" class="headerlink" title="原生注册事件的方式有哪些？区别是什么"></a>原生注册事件的方式有哪些？区别是什么</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 注册方式          <span class="token number">1</span><span class="token punctuation">.</span> on <span class="token operator">+</span> 事件名称          <span class="token number">2</span><span class="token punctuation">.</span> addEventListener        区别<span class="token punctuation">:</span>            <span class="token number">1</span><span class="token punctuation">.</span> 使用on注册事件<span class="token punctuation">,</span>同一个元素只能注册一个同类型事件<span class="token punctuation">,</span>否则会覆盖。            <span class="token number">2</span><span class="token punctuation">.</span> addEventListener可以注册同一事件多次<span class="token punctuation">,</span>不会被覆盖。</code></pre><h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span>  <span class="token number">1</span><span class="token punctuation">.</span>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。  <span class="token number">2</span><span class="token punctuation">.</span>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl<span class="token operator">/</span>tls加密传输协议。  <span class="token number">3</span><span class="token punctuation">.</span>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是<span class="token number">80</span>，后者是<span class="token number">443</span>。  <span class="token number">4</span><span class="token punctuation">.</span>http的连接很简单，是无状态的；HTTPS协议是由SSL<span class="token operator">/</span>TLS<span class="token operator">+</span>HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</code></pre><h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> <span class="token keyword">get</span>            <span class="token number">1</span><span class="token punctuation">.</span> 在url后面拼接参数<span class="token punctuation">,</span>只能以文本的形式传递数据            <span class="token number">2</span><span class="token punctuation">.</span> 传递的数据量小<span class="token punctuation">,</span>4KB左右            <span class="token number">3</span><span class="token punctuation">.</span> 安全性低<span class="token punctuation">,</span> 会将数据显示在地址栏            <span class="token number">4</span><span class="token punctuation">.</span> 速度快<span class="token punctuation">,</span>通常用于安全性要求不高的请求            <span class="token number">5</span><span class="token punctuation">.</span> 会缓存数据    post            <span class="token number">1</span><span class="token punctuation">.</span> 安全性比较高            <span class="token number">2</span><span class="token punctuation">.</span> 传递数据量大<span class="token punctuation">,</span>请求对数据长度没有要求            <span class="token number">3</span><span class="token punctuation">.</span> 请求不会被缓存<span class="token punctuation">,</span>也不会保留在浏览器历史记录里</code></pre><h2 id="项目中常遇到的状态码有哪些"><a href="#项目中常遇到的状态码有哪些" class="headerlink" title="项目中常遇到的状态码有哪些"></a>项目中常遇到的状态码有哪些</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> <span class="token number">200</span>  请求成功<span class="token punctuation">,</span>  <span class="token number">2</span>开头的异步表示请求成功        <span class="token number">304</span>  请求被允许<span class="token punctuation">,</span>但请求内容没有改变<span class="token punctuation">,</span> <span class="token number">3</span>开头的一般请求完成        <span class="token number">400</span>  请求格式错误<span class="token punctuation">,</span>  <span class="token number">4</span>开头的一般表示请求错误        <span class="token number">404</span>  <span class="token function">请求的资源</span><span class="token punctuation">(</span>网页<span class="token punctuation">)</span>不存在<span class="token punctuation">,</span>        <span class="token number">500</span>  内部服务器错误<span class="token punctuation">,</span>  <span class="token number">5</span>开头的一般都是指服务器错误</code></pre><h2 id="jsonp-的原理？以及优缺点"><a href="#jsonp-的原理？以及优缺点" class="headerlink" title="jsonp 的原理？以及优缺点"></a>jsonp 的原理？以及优缺点</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 原理<span class="token punctuation">:</span> 利用script标签的src属性具有天然可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式响应给浏览器<span class="token punctuation">.</span>        优点<span class="token punctuation">:</span> 完美解决在测试或者开发中获取不同域下的数据<span class="token punctuation">,</span>用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。        缺点：Jsonp只支持<span class="token keyword">get</span>请求而不支持post 请求<span class="token punctuation">,</span>也即是说如果想传给后台一个json 格式的数据<span class="token punctuation">,</span>此时问题就来了<span class="token punctuation">,</span> 浏览器会报一个http状态码<span class="token number">41</span>错误<span class="token punctuation">,</span>告诉你请求格式不正确<span class="token punctuation">.</span></code></pre><h2 id="Json-字符串和-json-对象怎么相互转换"><a href="#Json-字符串和-json-对象怎么相互转换" class="headerlink" title="Json 字符串和 json 对象怎么相互转换"></a>Json 字符串和 json 对象怎么相互转换</h2><pre><code>答: JSON对象转JSON字符串: json.stringify(对象)    JSON字符串转JSON对象: json.parse(字符串)</code></pre><h2 id="什么是同源策略？怎么解决跨域问题"><a href="#什么是同源策略？怎么解决跨域问题" class="headerlink" title="什么是同源策略？怎么解决跨域问题"></a>什么是同源策略？怎么解决跨域问题</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> 同源策略<span class="token punctuation">:</span> 同源策略是浏览器的一种安全策略<span class="token punctuation">,</span> 所谓同源是指域名、协议、端口完全相同，不同源则跨域。   解决跨域的方法<span class="token punctuation">:</span>            <span class="token number">1</span><span class="token punctuation">.</span> 通过jsonp跨域            <span class="token number">2</span><span class="token punctuation">.</span> 跨域资源共享（CORS  Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com）            <span class="token number">3</span><span class="token punctuation">.</span> nginx代理跨域</code></pre><h2 id="怎么理解同步和异步"><a href="#怎么理解同步和异步" class="headerlink" title="怎么理解同步和异步"></a>怎么理解同步和异步</h2><pre><code>1、javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念——任务队列。2、所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有等主线程任务执行完毕，"任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行。</code></pre><h2 id="你对-WebSocket-了解哪些"><a href="#你对-WebSocket-了解哪些" class="headerlink" title="你对 WebSocket 了解哪些"></a>你对 WebSocket 了解哪些</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> WebSocket 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：    <span class="token number">1</span><span class="token punctuation">.</span> WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser<span class="token operator">/</span>Client Agent都能主动的向对方发送或接收数据，就像Socket一样；    <span class="token number">2</span><span class="token punctuation">.</span> WebSocket需要类似TCP的客户端和服务器端通过握手连接连接成功后才能相互通信。</code></pre><h2 id="在地址栏输入网址，到数据返回的过程是什么？"><a href="#在地址栏输入网址，到数据返回的过程是什么？" class="headerlink" title="在地址栏输入网址，到数据返回的过程是什么？"></a>在地址栏输入网址，到数据返回的过程是什么？</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> 输入url地址后，首先进行DNS解析，将相应的域名解析为IP地址。     <span class="token number">2</span><span class="token punctuation">.</span> 根据IP地址去寻找相应的服务器。     <span class="token number">3</span><span class="token punctuation">.</span> 与服务器进行TCP的三次握手，建立连接。     <span class="token number">4</span><span class="token punctuation">.</span> 客户端发送请求，找到相应的资源库。     <span class="token number">5</span><span class="token punctuation">.</span> 客户端拿到数据，进行相应的渲染。</code></pre><h2 id="原生-ajax-请求的步骤"><a href="#原生-ajax-请求的步骤" class="headerlink" title="原生 ajax 请求的步骤"></a>原生 ajax 请求的步骤</h2><pre class=" language-js"><code class="language-js">答：<span class="token number">1</span><span class="token punctuation">.</span>创建异步对象 <span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">2</span><span class="token punctuation">.</span>设置请求行  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">3</span><span class="token punctuation">.</span>设置请求头  xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">get</span>请求没有请求头    post请求多一个关键头信息    Content<span class="token operator">-</span>type<span class="token punctuation">:</span> application<span class="token operator">/</span>x<span class="token operator">-</span>www<span class="token operator">-</span>form<span class="token operator">-</span>urlencoded    <span class="token number">4</span><span class="token punctuation">.</span>设置请求体  xhr<span class="token punctuation">.</span>send      <span class="token keyword">get</span>请求没有请求体<span class="token punctuation">,</span>参数为<span class="token keyword">null</span>    <span class="token number">5</span><span class="token punctuation">.</span>监视异步对象的状态变化   xhr<span class="token punctuation">.</span><span class="token function">onreadystatechange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h2 id="怎么理解三次握手"><a href="#怎么理解三次握手" class="headerlink" title="怎么理解三次握手"></a>怎么理解三次握手</h2><pre class=" language-js"><code class="language-js">字段          含义URG       紧急指针是否有效。为<span class="token number">1</span>，表示某一位需要被优先处理ACK       确认号是否有效，一般置为<span class="token number">1</span>。PSH       提示接收端应用程序立即从TCP缓冲区把数据读走。RST       对方要求重新建立连接，复位。SYN       请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为<span class="token number">1</span>FIN    希望断开连接。<span class="token number">1</span>、三次握手    第一次握手：建立连接时，客户端发送syn包到服务器，等待服务器确认。    第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包（syn<span class="token operator">=</span>y）到客户端    第三次握手：客户端收到服务器的SYN<span class="token operator">+</span>ACK包，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入（TCP连接成功）状态，完成三次握手   （通俗：主机<span class="token number">1</span>告诉主机<span class="token number">2</span>，我可以向你请求数据吗。主机<span class="token number">2</span>告诉主机<span class="token number">1</span>，可以请求数据。主机<span class="token number">1</span>告诉主机<span class="token number">2</span>，那我来请求数据了，请求完成，实现三次握手）</code></pre><h2 id="怎么理解四次挥手"><a href="#怎么理解四次挥手" class="headerlink" title="怎么理解四次挥手"></a>怎么理解四次挥手</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、四次挥手    第一次分手：主机<span class="token number">1</span>（可以使客户端，也可以是服务器端）向主机<span class="token number">2</span>发送一个FIN报文段；此时，主机<span class="token number">1</span>进入FIN_WAIT_1状态；这表示主机<span class="token number">1</span>没有数据要发送给主机<span class="token number">2</span>了。    第二次分手：主机<span class="token number">2</span>收到了主机<span class="token number">1</span>发送的FIN报文段，向主机<span class="token number">1</span>回一个ACK报文段，主机<span class="token number">1</span>进入FIN_WAIT_2状态；主机<span class="token number">2</span>告诉主机<span class="token number">1</span>，我“同意”你的关闭请求。    第三次分手：主机<span class="token number">2</span>向主机<span class="token number">1</span>发送FIN报文段，请求关闭连接，同时主机<span class="token number">2</span>进入LAST_ACK状态。    第四次分手：主机<span class="token number">1</span>收到主机<span class="token number">2</span>发送的FIN报文段，向主机<span class="token number">2</span>发送ACK报文段，然后主机<span class="token number">1</span>进入TIME_WAIT状态；主机<span class="token number">2</span>收到主机<span class="token number">1</span>的ACK报文段以后，就关闭连接；此时，主机<span class="token number">1</span>等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机<span class="token number">1</span>也可以关闭连接了。    （通俗：主机<span class="token number">1</span>告诉主机<span class="token number">2</span>，我没有数据要发送了，希望断开连接。主机<span class="token number">2</span>接到请求后说，同意断开。主机<span class="token number">2</span>告诉主机<span class="token number">1</span>可以关闭连接了。主机<span class="token number">1</span>接到可以关闭的指令后，关闭连接，四次挥手完成）</code></pre><h1 id="vue-笔记总结"><a href="#vue-笔记总结" class="headerlink" title="vue 笔记总结"></a>vue 笔记总结</h1><h2 id="怎么理解-mvvm-这种设计模式"><a href="#怎么理解-mvvm-这种设计模式" class="headerlink" title="怎么理解 mvvm 这种设计模式"></a>怎么理解 mvvm 这种设计模式</h2><pre class=" language-js"><code class="language-js"> Model–View–ViewModel （MVVM） 是一个软件架构设计模式，是一种简化用户界面的事件驱动编程方式。MVVM    M Model 模型 指的是数据层    V View  视图 指的是用户页面    VM ViewModel 视图模型    视图模型是MVVM模式的核心，它是连接view和model的桥梁，MVVM实现了view和model的自动同步，当model的属性改变时，我们不用自己手动操作DOM元素，来改变view的显示，反之亦然，我们称之为数据的双向绑定。</code></pre><h2 id="v-if-和-v-show-的区别，使用场景区别"><a href="#v-if-和-v-show-的区别，使用场景区别" class="headerlink" title="v-if 和 v-show 的区别，使用场景区别"></a>v-if 和 v-show 的区别，使用场景区别</h2><pre class=" language-js"><code class="language-js"> v<span class="token operator">-</span><span class="token keyword">if</span>和v<span class="token operator">-</span>show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的<span class="token punctuation">:</span><span class="token number">1</span>、v<span class="token operator">-</span><span class="token keyword">if</span>在条件切换时，会对标签进行适当的创建和销毁，而v<span class="token operator">-</span>show则仅在初始化时加载一次，因此v<span class="token operator">-</span><span class="token keyword">if</span>的开销相对来说会比v<span class="token operator">-</span>show大。<span class="token number">2</span>、v<span class="token operator">-</span><span class="token keyword">if</span>是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v<span class="token operator">-</span><span class="token keyword">if</span>不会去渲染标签。v<span class="token operator">-</span>show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS（display）切换。<span class="token number">3</span>、 v<span class="token operator">-</span><span class="token keyword">if</span>适用于不需要频繁切换元素显示和隐藏的情况    v<span class="token operator">-</span>show适用于需要频繁切换元素的显示和隐藏的场景。</code></pre><h2 id="vue-事件修饰符和按键修饰符有哪些"><a href="#vue-事件修饰符和按键修饰符有哪些" class="headerlink" title="vue 事件修饰符和按键修饰符有哪些"></a>vue 事件修饰符和按键修饰符有哪些</h2><pre class=" language-js"><code class="language-js">事件修饰符：    <span class="token punctuation">.</span>prevent  阻止事件默认行为    <span class="token punctuation">.</span>stop     阻止事件冒泡    <span class="token punctuation">.</span>capture  设置事件捕获机制    <span class="token punctuation">.</span>self     只有点击元素自身才能触发事件    <span class="token punctuation">.</span>once     事件只触发一次 按键修饰符：    <span class="token punctuation">.</span>tab    <span class="token punctuation">.</span>enter    <span class="token punctuation">.</span>esc    <span class="token punctuation">.</span>space    <span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>捕获<span class="token string">"删除"</span>和<span class="token string">"空格"</span>键<span class="token punctuation">)</span>    <span class="token punctuation">.</span>up    <span class="token punctuation">.</span>down    <span class="token punctuation">.</span>left    <span class="token punctuation">.</span>right</code></pre><h2 id="v-model-修饰符有哪些"><a href="#v-model-修饰符有哪些" class="headerlink" title="v-model 修饰符有哪些"></a>v-model 修饰符有哪些</h2><pre class=" language-js"><code class="language-js"><span class="token punctuation">.</span>trim   去除首尾空格    <span class="token punctuation">.</span>lazy   只在输入框失去焦点或按回车键时更新内容，不是实时更新    <span class="token punctuation">.</span>number <span class="token function">将数据转换成number类型</span><span class="token punctuation">(</span>原本是字符串类型<span class="token punctuation">)</span></code></pre><h2 id="v-for-中为什么要加-key，原理是什么"><a href="#v-for-中为什么要加-key，原理是什么" class="headerlink" title="v-for 中为什么要加 key，原理是什么"></a>v-for 中为什么要加 key，原理是什么</h2><pre class=" language-js"><code class="language-js">作用：      <span class="token number">1</span><span class="token punctuation">.</span>key的作用主要是为了高效的更新虚拟DOM，提高渲染性能。      <span class="token number">2</span><span class="token punctuation">.</span>key属性可以避免数据混乱的情况出现。 原理：      <span class="token number">1</span><span class="token punctuation">.</span>vue实现了一套虚拟DOM，使我们可以不直接操作DOM元素只操作数据，就可以重新渲染页面，而隐藏在背后的原理是高效的Diff算法      <span class="token number">2</span><span class="token punctuation">.</span>当页面数据发生变化时，Diff算法只会比较同一层级的节点；      <span class="token number">3</span><span class="token punctuation">.</span>如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点后面的子节点；        如果节点类型相同，则会重新设置该节点属性，从而实现节点更新      <span class="token number">4</span><span class="token punctuation">.</span>使用key给每个节点做一个唯一标识，Diff算法就可以正确失败此节点，<span class="token string">"就地更新"</span>找到正确的位置插入新的节点。</code></pre><h2 id="v-for-和-v-if-的优先级"><a href="#v-for-和-v-if-的优先级" class="headerlink" title="v-for 和 v-if 的优先级"></a>v-for 和 v-if 的优先级</h2><pre class=" language-js"><code class="language-js"> v<span class="token operator">-</span><span class="token keyword">for</span>优先级高于v<span class="token operator">-</span><span class="token keyword">if</span>    如果同时出现v<span class="token operator">-</span><span class="token keyword">for</span>和v<span class="token operator">-</span><span class="token keyword">if</span>，无论判断条件是否成立，都会执行一遍v<span class="token operator">-</span><span class="token keyword">for</span>循环，这样浪费性能，所以要尽可能的避免两者一起使用。</code></pre><h2 id="插槽（solt）"><a href="#插槽（solt）" class="headerlink" title="插槽（solt）"></a>插槽（solt）</h2><pre><code>1、什么是插槽    1.1 插槽（Slot）是Vue提出来的一个概念，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。    1.2 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制2、插槽使用    2.1 默认插槽  在子组件中写入slot，slot所在的位置就是父组件要显示的内容    2.2 具名插槽  在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer                 在父组件中使用template并写入对应的slot名字来指定该内容在子组件中现实的位置    2.3 作用域插槽  在子组件的slot标签上绑定需要的值    &lt;slot :data="user"&gt;&lt;/slot&gt;在父组件上使用slot-scope=“user”来接收子组件传过来的值</code></pre><h2 id="组件中的-data-为什么是函数-new-Vue-实例里，data-可以直接是一个对象"><a href="#组件中的-data-为什么是函数-new-Vue-实例里，data-可以直接是一个对象" class="headerlink" title="组件中的 data 为什么是函数,new Vue 实例里，data 可以直接是一个对象"></a>组件中的 data 为什么是函数,new Vue 实例里，data 可以直接是一个对象</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、组件是用来复用的，组件中的data写成一个函数<span class="token punctuation">,</span>数据以函数返回值形式定义<span class="token punctuation">,</span>函数有独立的作用域，这样每复用一次组件<span class="token punctuation">,</span>就会返回一份新的data<span class="token punctuation">,</span>类似于给每个组件实例创建一个私有的数据空间<span class="token punctuation">,</span>让各个组件实例维护各自的数据。<span class="token number">2</span>、而单纯的写成对象形式<span class="token punctuation">,</span>由于对象是引用类型，就使得所有组件实例共用了一份data<span class="token punctuation">,</span>就会造成一个变了全都会变的结果。<span class="token number">3</span>、因为<span class="token keyword">new</span> <span class="token class-name">vue</span>里面的代码是不存在复用的情况，所以可以写成对象形式</code></pre><h2 id="vue-中怎么给-data-动态添加数据，为什么要这样写"><a href="#vue-中怎么给-data-动态添加数据，为什么要这样写" class="headerlink" title="vue 中怎么给 data 动态添加数据，为什么要这样写"></a>vue 中怎么给 data 动态添加数据，为什么要这样写</h2><pre><code>答: 1.官方文档定义：如果在vue实例创建之后添加新的属性到实例上，她不会触发视图更新。    2.原因：受现代JavaScript的限制，vue不能检测到对象属性的添加或删除。由于vue会在初始化实例是对属性执行getter/setter转换过程（使用Object.defineProperty进行数据的劫持）。所以属性必须在data对象上存在才能让vue转换它，这样才能让它是响应的。    方法：1.this.$set(对象名，属性，值)或 Vue.set(对象名，属性，值)          2.Object.assign(target,source)添加多个属性          例如：            const target = {a:1, b:2}            const source = {b:4, d:5}            const returnedTarget = Object.assign(target,source)            console.log(returnedTarget); //{ a: 1, b: 4, c: 5 }</code></pre><h2 id="computed-和-watch-的区别是什么"><a href="#computed-和-watch-的区别是什么" class="headerlink" title="computed 和 watch 的区别是什么"></a>computed 和 watch 的区别是什么</h2><pre class=" language-js"><code class="language-js">计算属性computed：<span class="token number">1</span>、支持缓存，只有依赖数据发生改变，才会重新进行计算<span class="token number">2</span>、不支持异步，当computed内有异步操作时无效，无法监听数据的变化<span class="token number">3</span>、如果computed需要对数据修改，需要写<span class="token keyword">get</span>和<span class="token keyword">set</span>两个方法，当数据变化时，调用<span class="token keyword">set</span>方法。<span class="token number">4</span>、computed擅长处理的场景：一个数据受多个数据影响，例如购物车计算总价侦听属性watch：<span class="token number">1</span>、不支持缓存，数据变，直接会触发相应的操作；<span class="token number">2</span>、watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；<span class="token number">3</span>、immediate：组件加载立即触发回调函数执行<span class="token number">4</span>、deep<span class="token punctuation">:</span><span class="token boolean">true</span>的意思就是深入监听，任何修改obj里面任何一个属性都会触发这个监听器里的 handler方法来处理逻辑<span class="token number">5</span>、watch擅长处理的场景：一个数据影响多个数据，例如搜索框</code></pre><h2 id="组件化和模块化的区别"><a href="#组件化和模块化的区别" class="headerlink" title="组件化和模块化的区别"></a>组件化和模块化的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行工具性的封装。<span class="token number">2</span>、模块相应于业务逻辑模块，把同一类型项目里的功能逻辑进行进行需求性的封装。</code></pre><h2 id="怎么理解-vue-中的虚拟-DOM"><a href="#怎么理解-vue-中的虚拟-DOM" class="headerlink" title="怎么理解 vue 中的虚拟 DOM"></a>怎么理解 vue 中的虚拟 DOM</h2><pre class=" language-js"><code class="language-js">原理：    用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；diff 算法 — 比较两棵虚拟 DOM 树的差异；pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。好处：    <span class="token number">1</span>、性能优化    <span class="token number">2</span>、无需手动操作DOM    <span class="token number">3</span>、可以跨平台，服务端渲染等</code></pre><h2 id="怎么理解-vue-的生命周期"><a href="#怎么理解-vue-的生命周期" class="headerlink" title="怎么理解 vue 的生命周期"></a>怎么理解 vue 的生命周期</h2><pre class=" language-js"><code class="language-js"> vue的生命周期：vue实例从创建到销毁的全过程，这个过程可以分为<span class="token number">3</span>个阶段    第一阶段：初始化阶段   创建vue实例<span class="token punctuation">,</span>准备数据<span class="token punctuation">,</span>准备模板<span class="token punctuation">,</span>渲染视图    第二阶段：数据更新阶段 当数据变化时，会进行新旧DOM的对比，对比出差异的部分，进行差异化更新。    第三阶段：实例销毁阶段 当vm<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>被调用，vue实例就会被销毁，释放相关资源，此时再更新数据，视图不会再变化。</code></pre><h2 id="vue-钩子函数有哪些，有哪些使用的场景"><a href="#vue-钩子函数有哪些，有哪些使用的场景" class="headerlink" title="vue 钩子函数有哪些，有哪些使用的场景"></a>vue 钩子函数有哪些，有哪些使用的场景</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、各阶段包含钩子： beforeCreate  在data数据注入到vm实例之前，此时vm身上没有数据    created       在data数据注入到vm实例之前，此时vm身上有数据    beforeMount   生成的结构替换视图之前，此时DOM还没更新    mounted       生成的结构替换视图之前，此时DOM已经更新完成    beforeUpdate  数据变化了，dom更新之前    updated       数据变化了，dom更新之后        activated     被keep<span class="token operator">-</span>alive缓存的组件激活时调用    deactivated   被keep<span class="token operator">-</span>alive缓存的组件停用时调用    beforeDestroy 实例销毁，是否资源之前    destroyed     实例销毁，是否资源之后    这些钩子函数会在vue的生命周期的不同阶段，自动被vue调用<span class="token number">2</span>、常用的钩子函数使用场景：    beforeCreate  做loading的一些渲染    created       结束loading， 发送数据的请求，拿数据    mounted       可以对dom进行操作    updated       监视数据的更新    beforeDestroy 销毁非vue资源，防止内存泄漏，例如清除定时器    activated     当我们运用了组件缓存时，如果想每次切换都发送一次请求的话，需要把请求函数写在activated中，而写在created或mounted中其只会在首次加载该组件的时候起作用。</code></pre><h2 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 <span class="token number">4</span> 部分：  <span class="token number">1</span>）加载渲染过程     父 beforeCreate <span class="token operator">-</span><span class="token operator">></span> 父 created <span class="token operator">-</span><span class="token operator">></span> 父 beforeMount <span class="token operator">-</span><span class="token operator">></span> 子 beforeCreate <span class="token operator">-</span><span class="token operator">></span> 子 created <span class="token operator">-</span><span class="token operator">></span> 子 beforeMount <span class="token operator">-</span><span class="token operator">></span> 子 mounted <span class="token operator">-</span><span class="token operator">></span> 父 mounted  <span class="token number">2</span>）子组件更新过程     父 beforeUpdate <span class="token operator">-</span><span class="token operator">></span> 子 beforeUpdate <span class="token operator">-</span><span class="token operator">></span> 子 updated <span class="token operator">-</span><span class="token operator">></span> 父 updated  <span class="token number">3</span>）父组件更新过程     父 beforeUpdate <span class="token operator">-</span><span class="token operator">></span> 父 updated  <span class="token number">4</span>）销毁过程  父 beforeDestroy <span class="token operator">-</span><span class="token operator">></span> 子 beforeDestroy <span class="token operator">-</span><span class="token operator">></span> 子 destroyed <span class="token operator">-</span><span class="token operator">></span> 父 destroyed</code></pre><h2 id="vue-组件传值的方式"><a href="#vue-组件传值的方式" class="headerlink" title="vue 组件传值的方式"></a>vue 组件传值的方式</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、父传子    通过props传递    父组件： <span class="token operator">&lt;</span>child <span class="token punctuation">:</span>list <span class="token operator">=</span> <span class="token string">'list'</span> <span class="token operator">/</span><span class="token operator">></span>    子组件<span class="token punctuation">:</span> props<span class="token punctuation">[</span><span class="token string">'list'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>接收数据<span class="token punctuation">,</span>接受之后使用和data中定义数据使用方式一样<span class="token number">2</span>、子传父    <span class="token function">在父组件中给子组件绑定一个自定义的事件，子组件通过$emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>触发该事件并传值。    父组件： <span class="token operator">&lt;</span>child @receive <span class="token operator">=</span> <span class="token string">'getData'</span> <span class="token operator">/</span><span class="token operator">></span>            <span class="token function">getData</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>value就是接收的值<span class="token punctuation">}</span>    子组件<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'receive'</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token number">3</span>、兄弟组件传值    通过中央通信 <span class="token keyword">let</span> bus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    A组件：methods <span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token function">sendData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                bus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'getData'</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>              <span class="token punctuation">}</span> 发送    <span class="token function">B组件：created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>‘getData’<span class="token punctuation">,</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>value就是接收的数据<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> 进行数据接收</code></pre><h2 id="nextTick-是什么？原理是什么？使用的场景"><a href="#nextTick-是什么？原理是什么？使用的场景" class="headerlink" title="$nextTick 是什么？原理是什么？使用的场景"></a>$nextTick 是什么？原理是什么？使用的场景</h2><pre class=" language-js"><code class="language-js">背景：    <span class="token number">1</span>、简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。定义：    <span class="token number">2</span>、在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 <span class="token function">DOM。nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数。原理    <span class="token number">3</span>、vue用异步队列的方式来控制DOM更新和nextTick回调先后执行。    简单来说，nextTick是做了promise加上setTimeout的封装<span class="token punctuation">,</span>利用事件换行机制，来确保当nextTick出现时，都是在我们所有操作DOM更新之后的。场景：    <span class="token number">4.1</span> 点击获取元素宽度    <span class="token number">4.2</span> 使用swiper插件通过 ajax 请求图片后的滑动问题    <span class="token number">4.3</span> 点击按钮显示原本以 v<span class="token operator">-</span>show <span class="token operator">=</span> <span class="token boolean">false</span> 隐藏起来的输入框，并获取焦点</code></pre><h2 id="vue-是如何获取-DOM"><a href="#vue-是如何获取-DOM" class="headerlink" title="vue 是如何获取 DOM"></a>vue 是如何获取 DOM</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、先给标签设置一个ref值，再通过<span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>domName获取，这个操作要在mounted阶段进行。<span class="token number">2</span>、例如：<span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">const</span> dom <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>test <span class="token punctuation">}</span></code></pre><h2 id="v-on-可以监听多个方法吗"><a href="#v-on-可以监听多个方法吗" class="headerlink" title="v-on 可以监听多个方法吗"></a>v-on 可以监听多个方法吗</h2><pre class=" language-js"><code class="language-js">可以例如：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span>on<span class="token operator">=</span><span class="token string">"{ input:onInput,focus:onFocus }"</span><span class="token operator">></span></code></pre><h2 id="谈谈你对-keep-alive-的了解"><a href="#谈谈你对-keep-alive-的了解" class="headerlink" title="谈谈你对 keep-alive 的了解"></a>谈谈你对 keep-alive 的了解</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、keep<span class="token operator">-</span>alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染<span class="token number">2</span>、一般结合路由和动态组件一起使用，用于缓存组件<span class="token number">3</span>、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated4、提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；例如：<span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive include<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span> <span class="token operator">&lt;</span>component<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> name 为 a 的组件将被缓存！ <span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive exclude<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span> <span class="token operator">&lt;</span>component<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 除了 name 为 a 的组件都将被缓存！ <span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span></code></pre><h2 id="谈谈你对-slot-的了解"><a href="#谈谈你对-slot-的了解" class="headerlink" title="谈谈你对 slot 的了解"></a>谈谈你对 slot 的了解</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、什么是插槽    <span class="token number">1.1</span> 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。    <span class="token number">1.2</span> 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制    <span class="token number">2</span>、插槽使用    <span class="token number">2.1</span> 默认插槽  在子组件中写入slot，slot所在的位置就是父组件要显示的内容    <span class="token number">2.2</span> 具名插槽  在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer                 在父组件中使用template并写入对应的slot名字来指定该内容在子组件中现实的位置    <span class="token number">2.3</span> 作用域插槽  在子组件的slot标签上绑定需要的值<span class="token operator">&lt;</span>slot <span class="token punctuation">:</span>data<span class="token operator">=</span><span class="token string">"user"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>                  在父组件上使用slot<span class="token operator">-</span>scope<span class="token operator">=</span>“user”来接收子组件传过来的值</code></pre><h2 id="vue-中动态组件如何使用"><a href="#vue-中动态组件如何使用" class="headerlink" title="vue 中动态组件如何使用"></a>vue 中动态组件如何使用</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、在某个中使用 is 特性来切换不同的组件：    <span class="token operator">&lt;</span>component <span class="token punctuation">:</span>is<span class="token operator">=</span><span class="token string">"TabComponent"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">></span>   TabComponent<span class="token punctuation">:</span>已注册组件的名字</code></pre><h2 id="v-model-的原理是什么"><a href="#v-model-的原理是什么" class="headerlink" title="v-model 的原理是什么"></a>v-model 的原理是什么</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、v<span class="token operator">-</span>model主要提供了两个功能，view层输入值影响data的属性值，属性值发生改变会更新层的数值变化<span class="token punctuation">.</span><span class="token number">2</span>、v<span class="token operator">-</span>model指令的实现：    <span class="token number">3.1</span> v<span class="token operator">-</span>bind<span class="token punctuation">:</span>绑定响应式数据    <span class="token number">3.2</span> 触发input事件并传递数据 <span class="token punctuation">(</span>核心和重点<span class="token punctuation">)</span><span class="token number">3</span><span class="token function">、其底层原理就是</span><span class="token punctuation">(</span>双向数据绑定原理<span class="token punctuation">)</span>：    <span class="token number">3.1</span> 一方面modal层通过defineProperty来劫持每个属性，一旦监听到变化通过相关的页面元素更新。    <span class="token number">3.2</span> 另一方面通过编译模板文件，为控件的v<span class="token operator">-</span>model绑定input事件，从而页面输入能实时更新相关data属性值。</code></pre><h2 id="vue-响应式的原理"><a href="#vue-响应式的原理" class="headerlink" title="vue 响应式的原理"></a>vue 响应式的原理</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、原理：    Vue 的响应式原理是核心是通过 ES5 的 Object<span class="token punctuation">.</span>defindeProperty 进行数据劫持，然后利用 <span class="token keyword">get</span> 和 <span class="token keyword">set</span> 方法进行获取和设置，data 中声明的属性都被添加到了<span class="token keyword">get</span>和<span class="token keyword">set</span>中，当读取 data 中的数据时自动调用 <span class="token keyword">get</span> 方法，当修改 data 中的数据时，自动调用 <span class="token keyword">set</span> 方法，检测到数据的变化，会通知观察者 Wacher，观察者 Wacher自动触发重新render 当前组件（子组件不会重新渲染）<span class="token punctuation">,</span>生成新的虚拟 DOM 树，Vue 框架会遍历并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真实 DOM 树上。<span class="token number">2</span>、底层代码实现：       <span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">"lis"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        sex<span class="token punctuation">:</span> <span class="token string">"男"</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  vue2.0实现  使用Object.defineProperty进行数据劫持</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> temp            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                temp <span class="token operator">=</span> value            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// vue3.0实现 使用Proxy 进行数据的代理</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>        <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="vue2-0-和-vue3-0-响应式的区别"><a href="#vue2-0-和-vue3-0-响应式的区别" class="headerlink" title="vue2.0 和 vue3.0 响应式的区别"></a>vue2.0 和 vue3.0 响应式的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、Object<span class="token punctuation">.</span>defineProperty  <span class="token number">1</span><span class="token punctuation">)</span> 用于监听对象的数据变化  <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">无法监听数组变化</span><span class="token punctuation">(</span>下标，长度<span class="token punctuation">)</span>  <span class="token number">3</span><span class="token punctuation">)</span> 只能劫持对象的自身属性，动态添加的劫持不到<span class="token number">2</span>、Proxy  <span class="token number">1</span><span class="token punctuation">)</span> proxy返回的是一个新对象， 可以通过操作返回的新的对象达到目的  <span class="token number">2</span>）可以监听到数组变化，也可以监听到动态添加的数据</code></pre><h2 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="headerlink" title="router 和 route 的区别"></a>router 和 route 的区别</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、$router对象    <span class="token number">1</span>）$router对象是全局路由的实例，是router构造方法的实例    <span class="token number">2</span><span class="token function">）$router对象上的方法有：push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、go</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">、replace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">2</span>、$route对象    <span class="token number">1</span>）$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等    <span class="token number">2</span>）$route对象上的属性有：path、params、query、hash等等</code></pre><h2 id="路由传参的方式和区别"><a href="#路由传参的方式和区别" class="headerlink" title="路由传参的方式和区别"></a>路由传参的方式和区别</h2><pre class=" language-js"><code class="language-js">答<span class="token punctuation">:</span> <span class="token number">1</span>、方式：params 和 query2、区别：<span class="token number">1</span>）params用的是name，传递的参数在地址栏不会显示，类似于post        <span class="token number">2</span>）query用的是path<span class="token punctuation">,</span>传递的参数会在地址栏显示出来，类似于<span class="token keyword">get</span>      <span class="token number">3</span>、举例说明：   <span class="token number">1</span>）params 传参    传： <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          name<span class="token punctuation">:</span> <span class="token string">'particulars'</span><span class="token punctuation">,</span>          params<span class="token punctuation">:</span> <span class="token punctuation">{</span>            id<span class="token punctuation">:</span> id          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>     接：<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id        <span class="token number">2</span>）query传参     传：<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          path<span class="token punctuation">:</span> <span class="token string">'/particulars'</span><span class="token punctuation">,</span>          query<span class="token punctuation">:</span> <span class="token punctuation">{</span>            id<span class="token punctuation">:</span> id          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      接：<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id</code></pre><h2 id="Vue-模版编译原理知道吗，能简单说一下吗"><a href="#Vue-模版编译原理知道吗，能简单说一下吗" class="headerlink" title="Vue 模版编译原理知道吗，能简单说一下吗"></a>Vue 模版编译原理知道吗，能简单说一下吗</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span><span class="token function">、简单说，Vue的编译过程就是将template转化为render函数的过程。2、首先解析模版，生成AST语法树</span><span class="token punctuation">(</span>一种用JavaScript对象的形式来描述整个模板<span class="token punctuation">)</span>。 <span class="token function">使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。3、Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点</span><span class="token punctuation">(</span>静态节点<span class="token punctuation">)</span>我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。<span class="token number">4</span>、编译的最后一步是将优化后的AST树转换为可执行的代码。</code></pre><h2 id="SSR-了解吗"><a href="#SSR-了解吗" class="headerlink" title="SSR 了解吗"></a>SSR 了解吗</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。<span class="token number">2</span>、SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node<span class="token punctuation">.</span>js的运行环境。还有就是服务器的压力比较大。</code></pre><h2 id="你都做过哪些-Vue-的性能优化"><a href="#你都做过哪些-Vue-的性能优化" class="headerlink" title="你都做过哪些 Vue 的性能优化"></a>你都做过哪些 Vue 的性能优化</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、v<span class="token operator">-</span><span class="token keyword">if</span>和v<span class="token operator">-</span><span class="token keyword">for</span>不能连用<span class="token number">2</span>、页面采用keep<span class="token operator">-</span>alive缓存组件<span class="token number">3</span>、合理使用v<span class="token operator">-</span><span class="token keyword">if</span>和v<span class="token operator">-</span>show4、key保证唯一<span class="token number">5</span>、使用路由懒加载、异步组件、组件封装<span class="token number">6</span>、防抖、节流<span class="token number">7</span>、第三方模块按需导入<span class="token number">8</span>、图片懒加载<span class="token number">9</span>、精灵图的使用<span class="token number">10</span>、代码压缩</code></pre><h2 id="Vue-router-路由有哪些模式"><a href="#Vue-router-路由有哪些模式" class="headerlink" title="Vue-router 路由有哪些模式"></a>Vue-router 路由有哪些模式</h2><pre class=" language-js"><code class="language-js">一般有两种模式：<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token number">1</span>、hash 模式：后面的 hash 值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次 hash 值的变化会触发 hashchange 事件。<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token number">2</span>、history 模式：利用了 HTML5 中新增的 <span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 和 <span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法。这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</code></pre><h2 id="Vuex-是什么？有哪几种属性？"><a href="#Vuex-是什么？有哪几种属性？" class="headerlink" title="Vuex 是什么？有哪几种属性？"></a>Vuex 是什么？有哪几种属性？</h2><pre class=" language-js"><code class="language-js">  <span class="token number">1</span>、Vuex 是专为Vue设计的状态管理工具，采用集中式储存管理 Vue 中所有组件的状态。  <span class="token number">2</span>、属性  （<span class="token number">1</span>）state属性：基本数据  （<span class="token number">2</span>）getters属性：从 state 中派生出的数据  （<span class="token number">3</span>）mutation属性：更新 store 中数据的唯一途径，其接收一个以 state 为第一参数的回调函数  （<span class="token number">4</span>）action 属性：提交 mutation 以更改 state，其中可以包含异步操作，数据请求  （<span class="token number">5</span>）module 属性：用于将 store分割成不同的模块。</code></pre><h2 id="axios-封装请求拦截器和响应拦截器"><a href="#axios-封装请求拦截器和响应拦截器" class="headerlink" title="axios 封装请求拦截器和响应拦截器"></a>axios 封装请求拦截器和响应拦截器</h2><pre class=" language-js"><code class="language-js">interceptors：【ɪntərˈsɛptərz】<span class="token number">1</span>、项目中会在utils文件中，封装一个request<span class="token punctuation">.</span>js文件<span class="token number">2</span>、通过axios<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>配置baseURL，并得到一个request实例<span class="token number">3</span>、通过request<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span>use来配置请求拦截<span class="token number">4</span>、通过request<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span>use来配置响应拦截</code></pre><h2 id="webpack-在项目中的常见配置"><a href="#webpack-在项目中的常见配置" class="headerlink" title="webpack 在项目中的常见配置"></a>webpack 在项目中的常见配置</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、 配置兼容编译ES6转成ES5    用babel来编译，npm i babel<span class="token operator">-</span>core babel<span class="token operator">-</span>loader babel<span class="token operator">-</span>preset<span class="token operator">-</span>env babel<span class="token operator">-</span>polyfill babel<span class="token operator">-</span>plugin<span class="token operator">-</span>transform<span class="token operator">-</span>runtime <span class="token operator">--</span>save<span class="token operator">-</span>dev<span class="token number">2</span>、配置跨域代理服务    用proxy进行代理，在devServer里面配置，proxy<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>target<span class="token punctuation">:</span>代理的地址<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">3</span>、配置打包路径    publicPath<span class="token punctuation">:</span><span class="token string">'/'</span><span class="token number">4</span>、配置打包出去文件    outputDir<span class="token punctuation">:</span> <span class="token string">'dist'</span><span class="token number">5</span>、配置执行环境变量    启动的端口  <span class="token keyword">const</span> port <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>port <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>npm_config_port <span class="token operator">||</span> <span class="token number">9528</span></code></pre><h2 id="vue-怎么实现强制刷新组件"><a href="#vue-怎么实现强制刷新组件" class="headerlink" title="vue 怎么实现强制刷新组件"></a>vue 怎么实现强制刷新组件</h2><pre class=" language-js"><code class="language-js">第一<span class="token punctuation">.</span>使用<span class="token keyword">this</span><span class="token punctuation">.</span>$forceUpdate强制重新渲染    <span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"reload()"</span><span class="token operator">></span>刷新当前组件<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'comp'</span><span class="token punctuation">,</span>        methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>第二<span class="token punctuation">.</span>使用v<span class="token operator">-</span><span class="token keyword">if</span>指令<span class="token operator">&lt;</span>template<span class="token operator">></span>    <span class="token operator">&lt;</span>comp v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"update"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>comp<span class="token operator">></span>    <span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"reload()"</span><span class="token operator">></span>刷新comp组件<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">import</span> comp <span class="token keyword">from</span> <span class="token string">'@/views/comp.vue'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'parentComp'</span><span class="token punctuation">,</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            update<span class="token punctuation">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 移除组件            this.update = false            // 在组件移除后，重新渲染组件            // this.$nextTick可实现在DOM 状态更新后，执行传入的方法。            this.$nextTick(() => {                this.update = true            })        }    }}&lt;/script></span></code></pre><h2 id="在使用计算属性的时-函数名和-data-数据源中的数据可以同名吗"><a href="#在使用计算属性的时-函数名和-data-数据源中的数据可以同名吗" class="headerlink" title="在使用计算属性的时,函数名和 data 数据源中的数据可以同名吗?"></a>在使用计算属性的时,函数名和 data 数据源中的数据可以同名吗?</h2><pre class=" language-js"><code class="language-js">不可以    在初始化vm的过程，因为不管是计算属性还是data还是props 都会被挂载在vm实例上，会把data覆盖了<span class="token punctuation">,</span>因此 这三个都不能同名</code></pre><h2 id="vue-中-data-的属性可以和-methods-中的方法同名吗"><a href="#vue-中-data-的属性可以和-methods-中的方法同名吗" class="headerlink" title="vue 中 data 的属性可以和 methods 中的方法同名吗?"></a>vue 中 data 的属性可以和 methods 中的方法同名吗?</h2><pre class=" language-js"><code class="language-js">不可以    vue源码中的 <span class="token function">initData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法会取出 methods 中的方法进行判断，如果有重复的就会报错</code></pre><h2 id="你知道-style-加-scoped-属性的用途和原理吗"><a href="#你知道-style-加-scoped-属性的用途和原理吗" class="headerlink" title="你知道 style 加 scoped 属性的用途和原理吗"></a>你知道 style 加 scoped 属性的用途和原理吗</h2><pre class=" language-js"><code class="language-js">用途：防止全局同名CSS污染原理：在标签加上v<span class="token operator">-</span>data<span class="token operator">-</span>something属性，再在选择器时加上对应<span class="token punctuation">[</span>v<span class="token operator">-</span>data<span class="token operator">-</span>something<span class="token punctuation">]</span>，即CSS带属性选择器，以此完成类似作用域的选择方式<span class="token punctuation">.</span>    scoped会在元素上添加唯一的属性（data<span class="token operator">-</span>v<span class="token operator">-</span>x形式），css编译后也会加上属性选择器，从而达到限制作用域的目的。</code></pre><h2 id="如何在子组件中访问父组件的实例"><a href="#如何在子组件中访问父组件的实例" class="headerlink" title="如何在子组件中访问父组件的实例"></a>如何在子组件中访问父组件的实例</h2><pre class=" language-js"><code class="language-js">Vue中子组件调用父组件的方法，这里有三种方法提供参考：    <span class="token number">1</span>：直接在子组件中通过<span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>event来调用父组件的方法    <span class="token number">2</span>：在子组件里用$emit向父组件触发一个事件，父组件监听这个事件    <span class="token number">3</span>：父组件把方法传入子组件中，在子组件里直接调用这个方法</code></pre><h2 id="watch-的属性用箭头函数定义结果会怎么样"><a href="#watch-的属性用箭头函数定义结果会怎么样" class="headerlink" title="watch 的属性用箭头函数定义结果会怎么样"></a>watch 的属性用箭头函数定义结果会怎么样</h2><pre class=" language-js"><code class="language-js">不应该使用箭头函数来定义 watch <span class="token punctuation">:</span>例如：    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>      a<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//  这里不应该用箭头函数</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>。理由是箭头函数绑定了父级作用域的上下文，所以 <span class="token keyword">this</span> 将不会按照期望指向 Vue 实例，<span class="token keyword">this</span><span class="token punctuation">.</span>a 将是 undefined。注意：methods里面定义的方法也不要用箭头函数</code></pre><h2 id="怎么解决-vue-打包后静态资源图片失效的问题"><a href="#怎么解决-vue-打包后静态资源图片失效的问题" class="headerlink" title="怎么解决 vue 打包后静态资源图片失效的问题"></a>怎么解决 vue 打包后静态资源图片失效的问题</h2><pre class=" language-js"><code class="language-js">在vue<span class="token operator">-</span>cli 需要在根目录下建一个vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>js 在里面配置publicPath即可默认值为<span class="token operator">/</span>，更改为<span class="token punctuation">.</span><span class="token operator">/</span>就好了</code></pre><h2 id="怎么解决-vue-动态设置-img-的-src-不生效的问题"><a href="#怎么解决-vue-动态设置-img-的-src-不生效的问题" class="headerlink" title="怎么解决 vue 动态设置 img 的 src 不生效的问题"></a>怎么解决 vue 动态设置 img 的 src 不生效的问题</h2><pre class=" language-js"><code class="language-js">因为动态添加src被当做静态资源处理了，没有进行编译，所以要加上require。<span class="token operator">&lt;</span>img <span class="token punctuation">:</span>src<span class="token operator">=</span><span class="token string">"require('@/assets/images/xxx.png')"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><h2 id="EventBus-注册在全局上时，路由切换时会重复触发事件，如何解决呢"><a href="#EventBus-注册在全局上时，路由切换时会重复触发事件，如何解决呢" class="headerlink" title="EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢"></a>EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢</h2><pre class=" language-js"><code class="language-js">原因：因为我们的事件是全局的，它并不会随着组件的销毁而自动注销，需要我们手动调用注销方法来注销。解决：我们可以在组件的 beforeDestroy <span class="token punctuation">,</span>或 destroy 生命周期中执行注销方法，手动注销事件</code></pre><h2 id="你认为-vue-的核心是什么"><a href="#你认为-vue-的核心是什么" class="headerlink" title="你认为 vue 的核心是什么"></a>你认为 vue 的核心是什么</h2><pre class=" language-js"><code class="language-js">组件化<span class="token punctuation">;</span>双向数据绑定<span class="token punctuation">;</span></code></pre><h2 id="在-vue-文件中-style-是必须的吗？那-script-是必须的吗"><a href="#在-vue-文件中-style-是必须的吗？那-script-是必须的吗" class="headerlink" title="在.vue 文件中 style 是必须的吗？那 script 是必须的吗"></a>在.vue 文件中 style 是必须的吗？那 script 是必须的吗</h2><pre class=" language-js"><code class="language-js">在<span class="token punctuation">.</span>vue 文件中，template是必须的，而script与style都不是必须的。都没有的话那就是一个静态网页</code></pre><h2 id="说说-vue-的优缺点"><a href="#说说-vue-的优缺点" class="headerlink" title="说说 vue 的优缺点"></a>说说 vue 的优缺点</h2><pre class=" language-js"><code class="language-js">优点：    <span class="token number">1</span><span class="token punctuation">.</span>数据驱动    <span class="token number">2</span><span class="token punctuation">.</span>组件化    <span class="token number">3</span><span class="token punctuation">.</span>轻量级    <span class="token number">4</span><span class="token punctuation">.</span><span class="token function">SPA</span><span class="token punctuation">(</span>单页面<span class="token punctuation">)</span>    <span class="token number">5</span><span class="token punctuation">.</span>版本<span class="token number">3.0</span>的界面化管理工具比较好使    <span class="token number">6</span><span class="token punctuation">.</span>vue易入门    <span class="token number">7</span><span class="token punctuation">.</span>中文社区强大，入门简单，提升也有很多的参考资料。缺点：    <span class="token number">1</span><span class="token punctuation">.</span>不支持IE8及以下浏览器    <span class="token number">2</span><span class="token punctuation">.</span>吃内存（每个组件都会实例化一个Vue实例，实例的属性和方法很多）    <span class="token number">3</span><span class="token punctuation">.</span>定义在data里面的对象，实例化时，都会递归的遍历转成响应式数据，然而有的响应式数据我们并不会用到，造成性能上的浪费</code></pre><h2 id="库和框架的区别"><a href="#库和框架的区别" class="headerlink" title="库和框架的区别"></a>库和框架的区别</h2><pre><code>答: 库 本质上是一个函数的集合，每一次调用函数，实现一个特定的功能，使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。    框架 是一套完整的解决方案，使用框架的时候，框架实现了大部分的功能，我们只需要按照框架的规则书写代码即可，使用框架开发比库开发效率更高，更容易维护。</code></pre><h2 id="MVC-和-MVVM-的区别"><a href="#MVC-和-MVVM-的区别" class="headerlink" title="MVC 和 MVVM 的区别"></a>MVC 和 MVVM 的区别</h2><pre><code>答: MVVM    M Model 模型 指的是数据层    V View  视图 指的是用户页面    VM ViewModel 视图模型    视图模型是MVVM模式的核心，它是连接view和model的桥梁，MVVM实现了view和model的自动同步，当model的属性改变时，我们不用自己手动操作DOM元素，来改变view的显示，反之亦然，我们称之为数据的双向绑定。    MVC    M Model 模型 指的是数据层    V View  视图 指的是用户页面    C controller 控制器 指的是页面业务逻辑    view传送指令到controller，controller完成业务逻辑后，要求model改变状态，model将新的数据发送给view，用户得到反馈。所有通信都是单向的。</code></pre><h2 id="自己实现一个-v-model-的效果"><a href="#自己实现一个-v-model-的效果" class="headerlink" title="自己实现一个 v-model 的效果"></a>自己实现一个 v-model 的效果</h2><pre><code>答:    &lt;input type="text"&gt;    &lt;script&gt;     // vue2.0    let data = {      msg: 'hello vue'    }    let input = document.querySelector('input')    input.value = data.msg    input.addEventListener('input', function () {      data.msg = this.value    })    let temp = data.msg    Object.defineProperty(data, 'msg', {      get() {        return temp      },      set(value) {        input.value = value        return (temp = value)      }    })    // vue3.0    let data = {      msg: 'hello vue'    }    let input = document.querySelector('input')    input.value = data.msg    input.addEventListener('input', function () {      obj.msg = this.value    })    const obj = new Proxy(data, {      get(target, key) {        return target[key]      },      set(target, key, value) {        target[key] = value        input.value = value      }    })   &lt;/script&gt;</code></pre><h2 id="Object-defineProperty-和-proxy-的区别"><a href="#Object-defineProperty-和-proxy-的区别" class="headerlink" title="Object.defineProperty 和 proxy 的区别"></a>Object.defineProperty 和 proxy 的区别</h2><pre><code>1、Object.defineProperty  用于监听对象的数据变化缺点：    1）无法监听数组变化    2）只能劫持对象的属性,属性值也是对象那么需要深度遍历2、proxy  可以理解为 在被劫持的对象之前 加了一层拦截   proxy返回的是一个新对象， 可以通过操作返回的新的对象达到目的总结：当使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截</code></pre><h2 id="vue-loader-是做什么的"><a href="#vue-loader-是做什么的" class="headerlink" title="vue-loader 是做什么的"></a>vue-loader 是做什么的</h2><pre><code>答: 概念：vue-loader是基于webpack的一个loader，解析和转换.vue文件。提取出其中的逻辑代码script，样式代码style，以及HTML模板template，再分别把他们交给对应的loader去处理。    用途：js可以写es6、style样式可以是less或scss等</code></pre><h2 id="vue-中怎么操作-dom"><a href="#vue-中怎么操作-dom" class="headerlink" title="vue 中怎么操作 dom"></a>vue 中怎么操作 dom</h2><pre><code>答: 要在mounted中使用，在执行mounted的时候，vue已经渲染了dom节点，可以获取dom节点。    方法：      1）在标签中添加ref="name"      2）在方法中用this.$refs.name拿到这个元素，</code></pre><h2 id="导航钩子有几种（导航守卫）具体怎么用的"><a href="#导航钩子有几种（导航守卫）具体怎么用的" class="headerlink" title="导航钩子有几种（导航守卫）具体怎么用的"></a>导航钩子有几种（导航守卫）具体怎么用的</h2><pre><code>答: 分类：    1、全局守卫： router.beforeEach    2、全局解析守卫： router.beforeResolve    3、全局后置钩子： router.afterEach    4、路由独享的守卫： beforeEnter    5、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave    使用：    1、全局守卫： router.beforeEach       const router = new VueRouter({ ... })          router.beforeEach((to, from, next) =&gt; {          // ...        })    2、全局解析守卫： router.beforeResolve       可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。    3、全局后置钩子： router.afterEach       router.afterEach((to, from) =&gt; {          // ...        })    4、路由独享的守卫： beforeEnter       const router = new VueRouter({          routes: [            {              path: '/foo',              component: Foo,              beforeEnter: (to, from, next) =&gt; {                // ...              }            }          ]        })    5、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave       const Foo = {          template: `...`,          beforeRouteEnter (to, from, next) {            // 在渲染该组件的对应路由被 confirm 前调用            // 不能获取组件实例 `this`            // 因为当守卫执行前，组件实例还没被创建          },          beforeRouteUpdate (to, from, next) {            // 在当前路由改变，但是该组件被复用时调用            // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，            // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。            // 可以访问组件实例 `this`          },          beforeRouteLeave (to, from, next) {            // 导航离开该组件的对应路由时调用            // 可以访问组件实例 `this`          }        }</code></pre><h2 id="什么是-promise，特点是什么"><a href="#什么是-promise，特点是什么" class="headerlink" title="什么是 promise，特点是什么"></a>什么是 promise，特点是什么</h2><pre><code>    首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的效果，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。    简单说，它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。 特点：    1、Promise对象只有三种状态。        异步操作“未完成”（pending）        异步操作“已完成”（resolved，又称fulfilled）        异步操作“失败”（rejected）        异步操作成功，Promise对象传回一个值，状态变为resolved。        异步操作失败，Promise对象抛出一个错误，状态变为rejected。    2、promise的回调是同步的，then是异步的    3、可以链式调用</code></pre><h2 id="promise-的方法有哪些，能说明其作用"><a href="#promise-的方法有哪些，能说明其作用" class="headerlink" title="promise 的方法有哪些，能说明其作用"></a>promise 的方法有哪些，能说明其作用</h2><pre class=" language-js"><code class="language-js">原型上的方法：<span class="token number">1</span>、Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）作用是为 Promise 实例添加状态改变时的回调函数。接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。    <span class="token number">2</span>）返回的是另一个Promise对象，后面还可以接着调用then方法。<span class="token number">2</span>、Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）用于指定发生错误时的回调函数。    <span class="token number">2</span>）返回的也是一个 Promise 对象，因此还可以接着调用then方法<span class="token number">3</span>、Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）<span class="token keyword">finally</span>方法用于指定不管 Promise 对象最后状态如何，都会执行的回调函数。    <span class="token number">2</span>）<span class="token keyword">finally</span>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。自身API<span class="token punctuation">:</span><span class="token number">1</span>、Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）不带参数传递 — 返回一个新的状态为resolve的promise对象    <span class="token number">2</span>）参数是一个 Promise 实例— 返回 当前的promise实例<span class="token number">2</span>、Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span><span class="token punctuation">)</span>返回的是一个值    <span class="token number">2</span>）返回的值会传递到下一个then的resolve方法参数中<span class="token number">3</span>、Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）并行执行异步操作的能力    <span class="token number">2</span>）所有异步操作执行完后才执行回调<span class="token number">4</span>、Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token number">1</span>）那个结果返回来的快就是，那个结果，不管结果是成功还是失败</code></pre><h2 id="async-和-await-是干什么的"><a href="#async-和-await-是干什么的" class="headerlink" title="async 和 await 是干什么的"></a>async 和 await 是干什么的</h2><pre class=" language-js"><code class="language-js"> <span class="token keyword">async</span>和<span class="token keyword">await</span>可以说是异步终极解决方案了。<span class="token number">1</span>、<span class="token keyword">async</span> 用于申明一个 <span class="token keyword">function</span> 是异步的，而 <span class="token keyword">await</span> 用于等待一个异步方法执行完成。<span class="token number">2</span>、<span class="token keyword">await</span> 只能出现在 <span class="token keyword">async</span> 函数中。<span class="token number">3</span>、<span class="token keyword">async</span> 函数返回的是一个 Promise 对象，后面可以用then方法。缺点：因为<span class="token keyword">await</span>将异步代码改造成了同步代码，如果多个异步代码都使用了<span class="token keyword">await</span>会导致性能上的降低。</code></pre><h2 id="什么是宏任务和微任务，执行顺序是什么"><a href="#什么是宏任务和微任务，执行顺序是什么" class="headerlink" title="什么是宏任务和微任务，执行顺序是什么"></a>什么是宏任务和微任务，执行顺序是什么</h2><pre class=" language-js"><code class="language-js"><span class="token number">1</span>、宏任务一般是：包括整体代码script，setTimeout，setInterval。<span class="token number">2</span><span class="token function">、微任务：Promise</span><span class="token punctuation">(</span>then、<span class="token keyword">catch</span>、<span class="token keyword">finally</span><span class="token punctuation">)</span>，process<span class="token punctuation">.</span>nextTick（node<span class="token punctuation">.</span>js）。<span class="token number">3</span>、先执行主代码块，然后执行微任务，最后在执行宏任务（异步）</code></pre><h2 id="webpack-的作用是什么"><a href="#webpack-的作用是什么" class="headerlink" title="webpack 的作用是什么"></a>webpack 的作用是什么</h2><pre class=" language-js"><code class="language-js">webpack是一个打包器（bundler），它能将多个js文件打包成一个文件（其实不止能打包js文件，也能打包其他类型的文件，比如css文件，json文件等）</code></pre><h2 id="webpack-打包的流程是什么"><a href="#webpack-打包的流程是什么" class="headerlink" title="webpack 打包的流程是什么"></a>webpack 打包的流程是什么</h2><pre class=" language-js"><code class="language-js">Webpack首先会把配置参数和命令行的参数及默认参数合并，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后会调用Compiler的run来真正启动webpack编译构建过程，webpack的构建流程包括compile、make、build、seal、emit阶段，执行完这些阶段就完成了构建过程<span class="token punctuation">.</span><span class="token function">大概阶段：1、初始化参数</span><span class="token punctuation">(</span>加载插件和处理入口等<span class="token punctuation">)</span>        <span class="token number">2</span><span class="token function">、编译阶段</span><span class="token punctuation">(</span>读取文件<span class="token operator">-</span>编译模块<span class="token operator">-</span>分析模块依赖关系<span class="token punctuation">)</span>        <span class="token number">3</span><span class="token function">、文件输出</span><span class="token punctuation">(</span>渲染源码<span class="token operator">-</span>执行文件输出<span class="token operator">-</span>全部完成<span class="token punctuation">)</span></code></pre><h2 id="页面通信的方式有哪些"><a href="#页面通信的方式有哪些" class="headerlink" title="页面通信的方式有哪些"></a>页面通信的方式有哪些</h2><pre><code>1. 通过url拼接地址2. H5本地存储</code></pre><h2 id="如何清除浏览器的缓存"><a href="#如何清除浏览器的缓存" class="headerlink" title="如何清除浏览器的缓存"></a>如何清除浏览器的缓存</h2><pre><code>答: 当我们请求的地址相同的时候，浏览器为了提高性能，会把相同地址的数据进行缓存。如果服务端的数据发生改变，客户端也不会更新，那就需要清除缓存    解决：在url后面加时间戳    例如：https://www.baidu.com?time=New Date()</code></pre><h2 id="token-的作用是什么"><a href="#token-的作用是什么" class="headerlink" title="token 的作用是什么"></a>token 的作用是什么</h2><pre><code>答: token是服务端生成的“令牌”，来标识不同身份的    1. 防止表单重复提交    2.判断用户是否登录</code></pre><h2 id="列举-echarts-常用的配置项，说明含义"><a href="#列举-echarts-常用的配置项，说明含义" class="headerlink" title="列举 echarts 常用的配置项，说明含义"></a>列举 echarts 常用的配置项，说明含义</h2><pre><code>答:     图表标题 title        图例  legend        值域 dataRange        提示框 tooltip        区域缩放控制器 dataZoom        网格 grid        类目轴 categoryAxis        值型坐标轴默认参数 valueAxis        柱形图默认参数 bar        折线图默认参数 line        散点图默认参数 scatter        饼图默认参数 pie        默认标志图形类型列表 symbolList        可计算特性配置, 孤岛, 提示颜色 calculable</code></pre><h2 id="git-如何管理一个项目"><a href="#git-如何管理一个项目" class="headerlink" title="git 如何管理一个项目"></a>git 如何管理一个项目</h2><pre><code>答: 1、git init初始化git仓库（新项目才有这一步）    2、git clone将远程仓库的项目资料下载下来    3、git checkout -b dev (dev 为本地分支名）    4、git add .将工作区文件存在暂存区    4、git commit -m  ""从暂存区存到仓储区    5、git checkout master切到master分支    6、git merge dev 合并分支,合并后要将分支删除    7、使用git push将其上传到远程仓库    8、第二上班，先pull一下，更新最新代码</code></pre><h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h2 id="token-问题"><a href="#token-问题" class="headerlink" title="token 问题"></a>token 问题</h2><pre><code>Vue项目中实现token验证大致思路如下：1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token3、前端拿到token，将token存储到localStorage/cookie 和vuex中，并跳转路由页面4、前端每次跳转路由，就判断 localStroage/cookie  中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面5、每次调后端接口，都要在请求头中加token</code></pre><h2 id="token-过期"><a href="#token-过期" class="headerlink" title="token 过期"></a>token 过期</h2><p><img src="https://img-blog.csdnimg.cn/20200615213736501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9maXk=,size_16,color_FFFFFF,t_70"></p><h2 id="Lazyload-图片懒加载"><a href="#Lazyload-图片懒加载" class="headerlink" title="Lazyload 图片懒加载"></a>Lazyload 图片懒加载</h2><pre><code>先将img标签中的src链接设置为空，将真正的图片链接放在自定义属性（data-src），当js监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到src中，达到懒加载的效果。如果滚动的大小和屏幕高度之和大于元素到顶部的距离，设置一个定时器，制造懒加载的延迟加载的效果，也就是说，当我们滑动滚动条，看见图片的时候，就让它加载出来</code></pre><h2 id="less-和-sass-区别"><a href="#less-和-sass-区别" class="headerlink" title="less 和 sass 区别"></a>less 和 sass 区别</h2><pre><code>定义变量的符号不同：less使用@，sass使用$，变量的作用域不同：less在全局定义就作用在全局，在代码块中定义就作用于整个代码块，而sass只作用于全局编译环境不同：less在开发者环境编译，sass在服务器环境下编译</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局1.pc端响应式布局：是指屏幕大小缩放时样式发生相应改变。运用媒体查询@media来设置。2.移动端响应式布局：是指根据移动端不同设备实现页面正常显示的方案。运用以下三种方案布局：a. 百分比布局。b. flex布局。c. rem布局</code></pre><h2 id="visibility-opacity-和-display-none-的区别"><a href="#visibility-opacity-和-display-none-的区别" class="headerlink" title="visibility,opacity 和 display:none 的区别"></a>visibility,opacity 和 display:none 的区别</h2><pre><code> 1. display:none    该方式让元素隐藏时，隐藏的元素不占空间，隐藏后将改变html原有样式。 2. visibility:hidden    该方式让元素隐藏时，隐藏的元素还是占用原有位置，隐藏后不将改变html原有样式。但，如果该元素的子元素使用了visibility:visible的话，改子元素将不被隐藏。3. opacity:0     该方式让元素隐藏时，隐藏的元素还是占用原有位置，隐藏后不将改变html原有样式。但，隐藏的元素所对应的事件，仍然可以触发。</code></pre><h2 id="简单用-node-js-搭建本地服务器"><a href="#简单用-node-js-搭建本地服务器" class="headerlink" title="简单用 node.js 搭建本地服务器"></a>简单用 node.js 搭建本地服务器</h2><pre><code>安装框架之前先把NPM镜像改成淘宝镜像，在文件夹打开命令行窗口执行命令：npm config set registry https://registry.npm.taobao.org&nbsp;然后全局安装express命令安装工具&nbsp; 输入命令： npm install -g express-generator再安装express框架&nbsp; 输入命令： npm install -g express&nbsp;安装成功后就可以使用express框架构建项目了如输入命令： express myStudy -e 创建项目， 再cd 进入该目录，输入命令：npm install 安装组件 ，最后执行命令：npm start 启动项目</code></pre><h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><pre><code>2xx：成功  这类状态代码表明服务器成功地接受了客户端请求。201    已创建。203    非权威性信息。205    重置内容。3xx：重定向 客户端浏览器必须采取更多操作来实现请求。302    对象已移动。307    临时重定向。4xx：客户端错误 发生错误，客户端似乎有问题400    错误的请求。401    访问被拒绝。403    服务器拒绝请求404    服务器找不到请求的网页。5xx：服务器错误 服务器由于遇到错误而不能完成该请求。501    页眉值指定了未实现的配置。503    目前服务器无法使用，一般是因为服务器超载或停止维护。505    HTTP 版本不受支持。</code></pre><h2 id="前端加密的集中方法"><a href="#前端加密的集中方法" class="headerlink" title="前端加密的集中方法"></a>前端加密的集中方法</h2><pre><code>第一种：base64方法第二种：MD5加密方式 非对称加密  不能解密首先引入相关js,对要加密的内容直接加密，直接使用MD5方法对内容进行加密第三种加密RSA用公钥私钥加密解密先引入相关配置文件，前端在向后台发起登录请求之前，先请求后台获取公钥的方法，通过公钥对相关内容加密，接下来就是用加密后的内容请求后台。</code></pre><h2 id="双-token-如何让用户无感刷新权限"><a href="#双-token-如何让用户无感刷新权限" class="headerlink" title="双 token 如何让用户无感刷新权限"></a>双 token 如何让用户无感刷新权限</h2><pre><code>一般后台返回的会有两个token，一个登陆用的taoken，一个用来刷新的taoken，刷新用关灯token过期时间会设置的比较长，通过判断用户活跃度来刷新token，如果一直没登录，就直接让客户登录，如果是登录期间过期了就直接使用刷新taoken后台获取新的token</code></pre><h2 id="树形控件-使用"><a href="#树形控件-使用" class="headerlink" title="树形控件 使用"></a>树形控件 使用</h2><pre><code>引入el-tree 然后发送请求获得数据，如果后台给的数据不是直接可以用的，通过比较一级部门的id和二级部门的pid之类的利用递归来处理数据</code></pre><h2 id="Echarts-如何使用的？"><a href="#Echarts-如何使用的？" class="headerlink" title="Echarts 如何使用的？"></a>Echarts 如何使用的？</h2><pre><code>安装模块，页面上准备具有宽高的放置表的DOM容器，通过echarts.init生成一个实例并利用setOption生成简单图表</code></pre><h2 id="APP-中如何兼容-ios-系统和安卓系统（刘海屏和水滴屏如何适应）"><a href="#APP-中如何兼容-ios-系统和安卓系统（刘海屏和水滴屏如何适应）" class="headerlink" title="APP 中如何兼容 ios 系统和安卓系统（刘海屏和水滴屏如何适应）"></a>APP 中如何兼容 ios 系统和安卓系统（刘海屏和水滴屏如何适应）</h2><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">//CSS3新特性viewport-fit 属性</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1.0,</span> <span class="token attr-name">minimum-scale</span><span class="token attr-value"><span class="token punctuation">=</span>1.0,</span> <span class="token attr-name">maximum-scale</span><span class="token attr-value"><span class="token punctuation">=</span>1.0,</span> <span class="token attr-name">user-scalable</span><span class="token attr-value"><span class="token punctuation">=</span>no,</span> <span class="token attr-name">viewport-fit</span><span class="token attr-value"><span class="token punctuation">=</span>cover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">// 竖屏底下的查询</span>    @media screen and <span class="token punctuation">(</span>orientation<span class="token punctuation">:</span> portrait<span class="token punctuation">)</span> <span class="token punctuation">{</span>        body <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* 防止页面被刘海遮住 */</span>            padding<span class="token operator">-</span>top<span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//以防万一写一个你本身适配其他手机的</span>            padding<span class="token operator">-</span>top<span class="token punctuation">:</span>0px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 横屏底下的查询 */</span>    @media screen and <span class="token punctuation">(</span>orientation<span class="token punctuation">:</span> landscape<span class="token punctuation">)</span> <span class="token punctuation">{</span>        body <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* IOS 11支持*/</span>            padding<span class="token operator">-</span>right<span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            padding<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">constant</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为底下圆弧的高度 34px</span>            <span class="token comment" spellcheck="true">/*IOS 11.2版本版本支持*/</span>            padding<span class="token operator">-</span>right<span class="token punctuation">:</span> <span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            padding<span class="token operator">-</span>left<span class="token punctuation">:</span> <span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span> <span class="token function">env</span><span class="token punctuation">(</span>safe<span class="token operator">-</span>area<span class="token operator">-</span>inset<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//以防万一写一个你本身适配其他手机的</span>            padding<span class="token operator">-</span>right<span class="token punctuation">:</span>0px<span class="token punctuation">;</span>            padding<span class="token operator">-</span>left<span class="token punctuation">:</span>0px<span class="token punctuation">;</span>            padding<span class="token operator">-</span>bottom<span class="token punctuation">:</span>0px<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果用header和footer请单独定义</span></code></pre><h2 id="什么情况下使用箭头函数，什么情况下必须用-function"><a href="#什么情况下使用箭头函数，什么情况下必须用-function" class="headerlink" title="什么情况下使用箭头函数，什么情况下必须用 function"></a>什么情况下使用箭头函数，什么情况下必须用 function</h2><pre><code>在事件处理程序 和作为构造函数时，不能使用箭头函数，箭头函数内没有arguments（实参列表），没有this指向，不需要这些的时候可以直接用箭头函数</code></pre><h2 id="小程序的分享功能如何实现"><a href="#小程序的分享功能如何实现" class="headerlink" title="小程序的分享功能如何实现"></a>小程序的分享功能如何实现</h2><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">//微信小程序分享功能的实现方法有两种：</span><span class="token comment" spellcheck="true">//第一种</span>在page<span class="token punctuation">.</span>js中实现onShareAppMessage，便可在小程序右上角选择分享该页面onShareAppMessage<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>  title<span class="token punctuation">:</span> <span class="token string">'弹出分享时显示的分享标题'</span><span class="token punctuation">,</span>  desc<span class="token punctuation">:</span> <span class="token string">'分享页面的内容'</span><span class="token punctuation">,</span>  path<span class="token punctuation">:</span> <span class="token string">'/page/user?id=123'</span> <span class="token comment" spellcheck="true">// 路径，传递参数到指定页面。</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//第二种</span><span class="token comment" spellcheck="true">//自定义按钮实现分享，在page中添加一个带有open-type='share'的button标签(&amp;lt;button open-type='share'&amp;gt;&amp;lt;\/button>)</span></code></pre><h2 id="如何配置路由"><a href="#如何配置路由" class="headerlink" title="如何配置路由"></a>如何配置路由</h2><pre><code>安装路由，导入路由，注册路由，创建路由规则，创建路由实例并挂载规则，挂载路由实例，并在页面中放置路由出口</code></pre><h2 id="APP-中-1px-的边框如何处理？"><a href="#APP-中-1px-的边框如何处理？" class="headerlink" title="APP 中 1px 的边框如何处理？"></a>APP 中 1px 的边框如何处理？</h2><pre><code>使用border-image实现；使用background-image实现；（优点：可以设置单条、多条表框。缺点：更换颜色和样式麻烦，某些设备上会模糊）使用box-shadow模拟边框（优点：代码少，兼容性好。缺点：边框有阴影，颜色变浅。）</code></pre><h2 id="webpack-如何进行打包的"><a href="#webpack-如何进行打包的" class="headerlink" title="webpack 如何进行打包的"></a>webpack 如何进行打包的</h2><pre class=" language-jsx"><code class="language-jsx"><span class="token number">1</span>、初始化环境yarn init<span class="token number">2</span>、安装依赖包yarn add webpack webpack<span class="token operator">-</span>cli <span class="token operator">-</span>D<span class="token number">3</span>、配置scriptscripts<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"webpack"</span><span class="token punctuation">}</span><span class="token number">4</span>、新建目录src，建立导入导出文件<span class="token number">5</span>、运行打包命令yarn build</code></pre><h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><pre><code>jsonp（只支持get方式的请求）   反向代理（配置proxy节点）   cors</code></pre><h2 id="APP-如何同步-pc-端和移动端的数据"><a href="#APP-如何同步-pc-端和移动端的数据" class="headerlink" title="APP 如何同步 pc 端和移动端的数据"></a>APP 如何同步 pc 端和移动端的数据</h2><pre><code>1、利用import()异步引入组件实现按需引入2、使用CDN引入第三方依赖3、利用SplitChunks插件提取公共js代码和分割js代码</code></pre><h2 id="防抖和节流是什么？"><a href="#防抖和节流是什么？" class="headerlink" title="防抖和节流是什么？"></a>防抖和节流是什么？</h2><p>防抖，就是指触发事件后在 一定时间内只能执行一次，如果在这个时间内又触发了事件，则会重新计算函数执行时间。</p><p>节流，就是指连续触发事件但是在一定时间内最多只执行一次函数</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">//防抖一般用于input框</span><span class="token keyword">let</span>  timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token function">发送请求</span><span class="token punctuation">(</span>业务逻辑代码<span class="token punctuation">)</span><span class="token punctuation">}</span>，<span class="token number">1000</span><span class="token punctuation">)</span><span class="token number">1</span>、定义一个延时任务，在延迟任务之前再清除这个任务，那么只要在这个约定的时间内一直触发这个时间就会重新计算事件，直到我超出事件后没有再次触发该事件，那么就会发出请求<span class="token comment" spellcheck="true">//节流  timer  是定时器的id  是个数字  布尔值是true</span><span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token keyword">return</span>timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    业务逻辑    重置timer<span class="token operator">=</span>fase<span class="token punctuation">}</span>，<span class="token number">50</span><span class="token punctuation">)</span>适合事件触发频率特别高的时候，可以减少代码的执行率</code></pre><h2 id="APP-的发布方式，发布工具"><a href="#APP-的发布方式，发布工具" class="headerlink" title="APP 的发布方式，发布工具"></a>APP 的发布方式，发布工具</h2><p>APICloud 可以同时生成一套 ios 和安卓的原生模块</p><h2 id="轮询技术？"><a href="#轮询技术？" class="headerlink" title="轮询技术？"></a>轮询技术？</h2><p>轮询是在特定的的时间间隔（如每 1 秒），由浏览器对服务器发出 HTTP request，然后由服务器返回最新的数据给客户端的浏览器，轮询最开始出现时为了解决服务端压力过大，当前端一次并发多个请求的时候，可以轮流依次给到不同的服务器（这三台服务器的数据和接口都是一样的）。</p><h2 id="项目打包后图片加载失败，怎么处理？"><a href="#项目打包后图片加载失败，怎么处理？" class="headerlink" title="项目打包后图片加载失败，怎么处理？"></a>项目打包后图片加载失败，怎么处理？</h2><p>检查下基地址，静态资源路径等，找出问题后重新打包。</p><h2 id="RBAC-是什么？"><a href="#RBAC-是什么？" class="headerlink" title="RBAC 是什么？"></a>RBAC 是什么？</h2><p>基于角色的权限控制，通过给不同的用户分配不同的权限，控制其访问的页面，当权限增加时，能访问的页面也对应的增加。</p><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就形成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间一般都是多对多的关系。</p><h2 id="无感注册，无感刷新如何实现？"><a href="#无感注册，无感刷新如何实现？" class="headerlink" title="无感注册，无感刷新如何实现？"></a>无感注册，无感刷新如何实现？</h2><p>无感刷新一般后台返回的会有两个 token，一个登陆用的 token，一个用来刷新的 token，刷新用 token 过期时间会设置的比较长，通过判断用户活跃度来刷新 token，如果一直没登录，就直接让客户登录，如果是登录期间过期了就直接使用刷新 taoken 后台获取新的 token</p><h2 id="如何实现同一旗下的-app-登录其中一个，其他-app-也同时可以访问？"><a href="#如何实现同一旗下的-app-登录其中一个，其他-app-也同时可以访问？" class="headerlink" title="如何实现同一旗下的 app 登录其中一个，其他 app 也同时可以访问？"></a>如何实现同一旗下的 app 登录其中一个，其他 app 也同时可以访问？</h2><p>单点登录 SSO（Single Sign On），解决如何产生和存储的信任，再就是其他系统如何验证这个信任的有效性</p><p>第一种方式：以 Cookie 作为凭证媒介</p><p>最简单的单点登录实现方式，是使用 cookie 作为媒介，存放用户凭证。 用户登录父应用之后，应用返回一个加密的 cookie，当用户访问子应用的时候，携带上这个 cookie，授权应用解密 cookie 并进行校验，校验通过则登录当前用户。（不安全，不能解决跨域实现免登录）</p><p>第二种方式：通过页面重定向的方式</p><p>是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。 父应用提供一个 GET 方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的 Token，并且重定向到子应用提供的验证 Token 的接口，通过解密和校验之后，子应用登录当前用户</p><p>第三种方式：使用独立登录系统</p><p>大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。 用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p><h2 id="Echarts-如何联动两个表？"><a href="#Echarts-如何联动两个表？" class="headerlink" title="Echarts 如何联动两个表？"></a>Echarts 如何联动两个表？</h2><p>图表实现联动的关键代码 echarts.connect([myChart1, myChart2])</p><h2 id="响应式和自适应的区别"><a href="#响应式和自适应的区别" class="headerlink" title="响应式和自适应的区别"></a>响应式和自适应的区别</h2><p>1.自适应布局通过检测视口分辨率，来判断当前访问的设备，响应式布局针对不同客户端在客户端做代码处理。</p><p>2.自适应要开发多套界面，响应式只要开发一套界面。</p><p>3.自适应适配是在一定范围，响应式布局是一套页面全部适应。</p><h2 id="电商网站如何实现订单的唯一性？"><a href="#电商网站如何实现订单的唯一性？" class="headerlink" title="电商网站如何实现订单的唯一性？"></a>电商网站如何实现订单的唯一性？</h2><p>可以使用一个唯一的流水号 ID，用来标识是不是同一个请求或者交易，先将这个 ID 保存到一个流水表里面，并且流水表中将这个 ID 设置为<code>UNIQUE KEY</code>,如果插入出现冲突了，则说明这个创建订单的请求已经处理过了，直接返回之前的操作结果。</p><p>（幂等性）：用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次。 调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。 比如下面这些情况，如果没有实现接口幂等性会有很严重的后果： 支付接口，重复支付会导致多次扣钱 订单接口，同一个订单可能会多次创建</p><h2 id="A-和-B-两个非父子组件，A-中-input-框里的值如何传给-B？"><a href="#A-和-B-两个非父子组件，A-中-input-框里的值如何传给-B？" class="headerlink" title="A 和 B 两个非父子组件，A 中 input 框里的值如何传给 B？"></a>A 和 B 两个非父子组件，A 中 input 框里的值如何传给 B？</h2><p>EventBus 建立一个 js 文件，只做事件发布和监听，A 和 B 组件都需要导入这个 js 文件，A 组件通过$emit发布一个事件，并携带input框的值，B组件通过$on 订阅事件，并接收参数。</p><p>或者直接存到 vuex 中</p><h2 id="过滤器怎么写？"><a href="#过滤器怎么写？" class="headerlink" title="过滤器怎么写？"></a>过滤器怎么写？</h2><p>全局的：</p><pre class=" language-jsx"><code class="language-jsx">Vue<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token string">"capitalize"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>  value <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 参数一 过滤器名字  参数二  函数，value 是使用这个过滤器的dom元素  参数二的函数必须有一个返回值</span></code></pre><p>局部过滤器：</p><pre class=" language-jsx"><code class="language-jsx">filters<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">formatDate</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">moment</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><h2 id="自定义指令？"><a href="#自定义指令？" class="headerlink" title="自定义指令？"></a>自定义指令？</h2><p>全局：</p><pre class=" language-jsx"><code class="language-jsx">Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">"focus"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当被绑定的元素插入到 DOM 中时……</span>  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用这个指令的元素元素</span>    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>局部指令：</p><pre class=" language-jsx"><code class="language-jsx">directives<span class="token punctuation">:</span> <span class="token punctuation">{</span>  color<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指令的定义</span>    inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el，binding<span class="token punctuation">)</span> <span class="token punctuation">{</span>      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color<span class="token operator">=</span>binding<span class="token punctuation">.</span>value    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="手机端如何调出键盘？"><a href="#手机端如何调出键盘？" class="headerlink" title="手机端如何调出键盘？"></a>手机端如何调出键盘？</h2><p>在 Android 上，只要不是用户触发的事件都无法触发。一个 label，两个 input，既然隐藏了搜索组件的 input1。新建另一个隐藏的 input2。点击 label–&gt;input2 聚焦–&gt;键盘起–&gt;input1.focus()</p><p>ios 上，touchstart 事件时，直接 focus 到 input 上。</p><pre class=" language-jsx"><code class="language-jsx">btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'touchstart'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>isIos<span class="token punctuation">)</span><span class="token punctuation">{</span>      evt<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      evt<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      input<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//必须阻止默认行为，也不能冒泡，而且click事件是不行的。click有延迟，用户触摸屏幕，无法及时的focus。preventDefault和stopPropagation也是为了防止焦点到其他的元素上。</span></code></pre><h2 id="vuex-里-modules-使用场景"><a href="#vuex-里-modules-使用场景" class="headerlink" title="vuex 里 modules 使用场景"></a>vuex 里 modules 使用场景</h2><p>在项目开发过程中，随着项目逐渐增大，数据关联复杂度逐渐加大， 多人协同开发，人员变动等。 我们会遇到 vuex 数据更新时，执行某个 action 导致同名/未预测到的关联数据发生了变化。</p><pre><code>  vue 基本思想之一便是数据驱动， vuex 更是专门的数据状态关联库。 导致数据错误结果可想而知......  使用vuex module 命名空间概念则可以很好的解决这个问题！！！</code></pre><h2 id="vuex-流程"><a href="#vuex-流程" class="headerlink" title="vuex 流程"></a>vuex 流程</h2><pre><code>对vuex的简单理解每一个 Vuex 应用的核心就是 store，里面又包括:（1）state（数据）：用来存放数据源，就是公共状态;（2）getters（数据加工）：有的时候需要对数据源进行加工，返回需要的数据；（3）actions（事件）：要执行的操作，可以进行同步或者异步事件（4）mutations（执行）：操作结束之后，actions通过commit更新state数据源（5）modules：使用单一状态树，致使应用的全部状态集中到一个很大的对象，所以把每个模块的局部状态分装使每一个模块拥有本身的 state、mutation、action、getters、甚至是嵌套子模块；vuex的工作流程就是：（1）通过dispatch去提交一个actions，（2）actions接收到这个事件之后，在actions中可以执行一些异步|同步操作，根据不同的情况去分发给不同的mutations，（3）actions通过commit去触发mutations，（4）mutations去更新state数据，state更新之后，就会通知vue进行渲染1.在vue组件里面，通过dispatch来触发actions提交修改数据的操作。2.然后再通过actions的commit来触发mutations来修改数据。3.mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。4.最后由store触发每一个调用它的组件的更新</code></pre><h2 id="Vuex-的严格模式是什么"><a href="#Vuex-的严格模式是什么" class="headerlink" title="Vuex 的严格模式是什么"></a>Vuex 的严格模式是什么</h2><pre><code>在严格模式下，无论何时发生了状态变更且不是由 mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。在Vuex.Store 构造器选项中开启,如下const store = new Vuex.Store({    strict:true,})</code></pre><h2 id="vue-router-命名视图"><a href="#vue-router-命名视图" class="headerlink" title="vue-router 命名视图"></a>vue-router 命名视图</h2><pre><code>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。</code></pre><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>一、双层循环（暴力方法）二、indexOf和includes三、排序去重四、filter五、键值对（key-value）六、ES6(set 和 map)set方法var arr = [1, 2, 1, '1', '2'];function unique(array) {    return [...new Set(array)];}console.log(unique(arr)); // [ 1, 2, '1', '2' ]map方法function unique (arr) {    const newMap = new Map()    return arr.filter((a) =&gt; !newMap.has(a) &amp;&amp; newMap.set(a, 1));}</code></pre><h2 id="事件冒泡和事件委托"><a href="#事件冒泡和事件委托" class="headerlink" title="事件冒泡和事件委托"></a>事件冒泡和事件委托</h2><pre><code>js中事件冒泡我们知道，子元素身上的事件会冒泡到父元素身上。事件代理就是，把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件委托的优点：1.可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒2.可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</code></pre><h2 id="flex-布局是什么，有哪些属性？flex：1-是什么意思？"><a href="#flex-布局是什么，有哪些属性？flex：1-是什么意思？" class="headerlink" title="flex 布局是什么，有哪些属性？flex：1 是什么意思？"></a>flex 布局是什么，有哪些属性？flex：1 是什么意思？</h2><pre><code>- 是什么  Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。  任何一个容器都可以指定为 Flex 布局。  行内元素也可以使用 Flex 布局。  Webkit 内核的浏览器，必须加上-webkit 前缀。  注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。- Flex 的属性以下 6 个属性设置在容器上。- flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）。.box {flex-direction: row | row-reverse | column | column-reverse;}row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿,自上而下。column-reverse：主轴为垂直方向，起点在下沿,自下而上。- flex-wrap默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap 属性定义，如果一条轴线排不下，应该如何换行。.box{flex-wrap: nowrap | wrap | wrap-reverse;}nowrap（默认）：不换行,宽度自动压缩。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。- flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。.box {flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}.box{flex-flow:row||nowrap;}- justify-contentjustify-content 属性定义了项目在主轴上(即横向)的对齐方式。flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，组件之间的间隔都相等。space-around：距边界两侧的间隔相等，元素之间的间隔比项目与边框的间隔大一倍。- align-itemsalign-items 属性定义项目在交叉轴上(即纵向,垂直)如何对齐。.box {align-items: flex-start | flex-end | center | baseline | stretch;}flex-start：交叉轴的起点(顶部)对齐。flex-end：交叉轴的终点(底部)对齐。center：交叉轴的中点(中间)对齐。baseline: 项目的第一行文字的基线(即根据内容对齐,不再根据容器)对齐。stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。- align-contentalign-items 属性定义项目在交叉轴上(即纵向,垂直)如何对齐。.box {align-items: flex-start | flex-end | center | baseline | stretch;}flex-start：交叉轴的起点(顶部)对齐。flex-end：交叉轴的终点(底部)对齐。center：交叉轴的中点(中间)对齐。baseline: 项目的第一行文字的基线(即根据内容对齐,不再根据容器)对齐。stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。- flex：1 是什么意思？flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。</code></pre><h2 id="position-有哪些属性？"><a href="#position-有哪些属性？" class="headerlink" title="position 有哪些属性？"></a>position 有哪些属性？</h2><pre><code>(1)、static可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。(2)、relative相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。(3)、absolutea、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。b、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。(4)、fixed固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。(5)、center与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）(6)、page与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）(7)、sticky对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。</code></pre><h2 id="页面布局，左右固定中间自适应怎么实现？"><a href="#页面布局，左右固定中间自适应怎么实现？" class="headerlink" title="页面布局，左右固定中间自适应怎么实现？"></a>页面布局，左右固定中间自适应怎么实现？</h2><pre><code>1.使用自身浮动法：自身浮动法的原理就是对左右分别使用float:left和float:right，float使左右两个元素脱离文档流，中间元素正常在正常文档流中。对中间文档流使用margin指定左右外边距进行定位。该布局法的不足是三个元素的顺序，middle一定要放在最后，middle占据文档流位置，所以一定要放在最后，左右两个元素位置没有关系。当浏览器窗口很小的时候，右边元素会被挤到下一行。2.使用绝对定位法：绝对定位法原理是将左右两边使用absolute定位，因为绝对定位使其脱离文档流，后面的middle会自然流动到他们上面，然后使用margin属性，留出左右元素的宽度，既可以使中间元素自适应屏幕宽度。该法布局的好处，三个div顺序可以任意改变。但是因为是绝对定位，如果页面上还有其他内容，top的值需要小心处理。3.使用flex布局：设置一个父div，添加样式display：flex。中间div设置flex-grow：1，（等同代码中设置flex：1。flex是grow、shrink、basis的简写）但是盒模型默认紧紧挨着，可以使用margin控制外边距。middle一定在中间，否则需要order属性来调整。通过项目属性flex-grow设置middle的放大比例，将空余的空间用middle来填充，使三个项目排满一整行；默认为0，也就是对剩余空间不做处理。通过项目属性flex-basis 设置left和right的固定宽度。</code></pre><h2 id="不定宽高的-div-水平垂直居中-1"><a href="#不定宽高的-div-水平垂直居中-1" class="headerlink" title="不定宽高的 div 水平垂直居中?"></a>不定宽高的 div 水平垂直居中?</h2><pre><code>方法一：CSS3（实现简单，缺点是兼容性不好）display: flex;justify-content:center; //子元素水平居中align-items:center; //子元素垂直居中方法二：运用margin:auto进行垂直居中margin的值设置为auto，可以让我们对剩余空间进行分配！我们知道，块级元素设置为margin:0 auto；可以左右居中显示！那有没有办法让margin设置为margin:auto之后，上下左右都居中呢？上下左右都居中，就可以实现我们的垂直居中了！答案是有的，只要我们让上下有足够的空间，就可以让margin的auto来分配上下空间。我们可以利用定位的方式，让margin上下左右都有足够的空间！那么就可以用margin:auto来实现垂直居中了！</code></pre><h2 id="key-值有什么作用？不加-key-会有什么影响？会在哪个生命周期会用到-key？"><a href="#key-值有什么作用？不加-key-会有什么影响？会在哪个生命周期会用到-key？" class="headerlink" title="key 值有什么作用？不加 key 会有什么影响？会在哪个生命周期会用到 key？"></a>key 值有什么作用？不加 key 会有什么影响？会在哪个生命周期会用到 key？</h2><pre><code>作用：key属性能够提升性能(主要作用于数据更新时)。不加 key 会有什么影响:可能会导致数据渲染错乱会在哪个生命周期会用到 key:beforeUpdate</code></pre><h2 id="vue-八大生命周期钩子函数"><a href="#vue-八大生命周期钩子函数" class="headerlink" title="vue 八大生命周期钩子函数"></a>vue 八大生命周期钩子函数</h2><pre><code>beforeCreate:    vue实例初始化之前调用(vue实例中的el，data，data中的message都为undefined)created: vue实例初始化之后调用(  el还是undefined，而数据已经与data中的属性进行绑定（放在data中属性当值发生改变的同时，视图也会发生变化），在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取)beforeMount:    挂载到DOM树之前调用(载入前（完成了data和el数据初始化），但是页面中的内容还是vue中的占位符，data中的message信息没有被挂在到Bom节点中，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取)mounted:    挂载到DOM树之后调用(载入后html已经渲染(ajax请求可以放在这个函数中)，把vue实例中的data里的message挂载到BOM节点中去)beforeUpdate:    数据更新之前调用 (更新前状态（view层的数据变化前，不是data中的数据改变前），重新渲染之前触发，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染)updated:数据更新之后调用 (数据已经更改完成，dom也重新render完成)beforeDestroy:    vue实例销毁之前调用(销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等…’)destroyed:vue实例销毁之后调用(销毁后 （Dom元素存在，只是不再受vue控制）,卸载watcher，事件监听，子组件)- 生命周期总结beforecreate : 可以在这加个loading事件created ：在这结束loading，还做一些初始数据的获取，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestroy： 你确认删除XX吗？destroyed ：当前组件已被删除，清空相关内容</code></pre><h2 id="vue-v-model-实现原理？"><a href="#vue-v-model-实现原理？" class="headerlink" title="vue v-model 实现原理？"></a>vue v-model 实现原理？</h2><pre><code>实现原理：1、v-bind绑定响应数据2、触发input事件并传递数据</code></pre><h2 id="vue-created-到-beforeMount-的过程"><a href="#vue-created-到-beforeMount-的过程" class="headerlink" title="vue created 到 beforeMount 的过程?"></a>vue created 到 beforeMount 的过程?</h2><pre><code>首先会判断vue实例中有没有el选项，如果有的话则进行下面的编译，但是如果没有el选项，则停止生命周期，直到vue实例上调用vm.$mount(el)。如果有el，再判断是否有template参数，如果有，则把其当作模板编译成render函数，如果没有，则把外部的html作为模板编译。template中的模板优先级高于outer HTML模板。在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.综合排名优先级：render函数选项 &gt; template选项 &gt; outer HTML.</code></pre><h2 id="vue-父子组件加载顺序？组件通信有哪些？"><a href="#vue-父子组件加载顺序？组件通信有哪些？" class="headerlink" title="vue 父子组件加载顺序？组件通信有哪些？"></a>vue 父子组件加载顺序？组件通信有哪些？</h2><pre><code>- vue 父子组件加载顺序首先加载父组件     ： beforeCreate ，created ，beforeMount， mounted，beforeUpdate（四次）然后是  子组件1    ： beforeCreate ，created ，beforeMount ，然后是  子组件2    ： beforeCreate ，created ，beforeMount ，然后是  子组件1    ： mounted，然后是  子组件2    ： mounted，然后是  父组件      ： updated （四次 ），最后 父组件 再次  加载一次 beforeUpdate，updated- 组件间通信的分类组件间通信的分类可以分成以下父子组件之间的通信兄弟组件之间的通信祖孙与后代组件之间的通信非关系组件间之间的通信- 组件间通信的方案整理vue中8种常规的通信方案通过 props 传递通过 $emit 触发自定义事件使用 refEventBus$parent 或 $rootattrs 与 listenersProvide 与 InjectVuex</code></pre><h2 id="Git-提交代码错误怎么撤回？怎么合并冲突？"><a href="#Git-提交代码错误怎么撤回？怎么合并冲突？" class="headerlink" title="Git 提交代码错误怎么撤回？怎么合并冲突？"></a>Git 提交代码错误怎么撤回？怎么合并冲突？</h2><pre><code>- Git 提交代码错误怎么撤回1.输入git log 查看所有提交的版本,找出对应的版本号码2.回退到指定版本git reset --hard 版本号码3. 推送代码git push origin master -f- 合并冲突1.先通过开发工具找出冲突2.解决冲突3. 推送代码</code></pre><h2 id="vue-v-if-和-v-show-区别？"><a href="#vue-v-if-和-v-show-区别？" class="headerlink" title="vue v-if 和 v-show 区别？"></a>vue v-if 和 v-show 区别？</h2><pre><code>- v-if 和 v-show 区别1.共同点v-if 和 v-show 都可以动态地显示隐藏DOM元素2. 区别（1）手段不同：v-if 是动态的向DOM树内添加或者删除DOM元素；v-show 是通过设置DOM元素的display样式属性控制显隐；（2）性能消耗不同：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗；（3）使用场景不同：v-if 适合运营条件不大可能改变；v-show 适合频繁切换。</code></pre><h2 id="webpack-执行顺序打包流程，从哪里收集参数？依赖关系怎么走？"><a href="#webpack-执行顺序打包流程，从哪里收集参数？依赖关系怎么走？" class="headerlink" title="webpack 执行顺序打包流程，从哪里收集参数？依赖关系怎么走？"></a>webpack 执行顺序打包流程，从哪里收集参数？依赖关系怎么走？</h2><h2 id="promise-有哪些方法？"><a href="#promise-有哪些方法？" class="headerlink" title="promise 有哪些方法？"></a>promise 有哪些方法？</h2><h2 id="宏任务和微任务有哪些？异步操作和同步操作有哪些？"><a href="#宏任务和微任务有哪些？异步操作和同步操作有哪些？" class="headerlink" title="宏任务和微任务有哪些？异步操作和同步操作有哪些？"></a>宏任务和微任务有哪些？异步操作和同步操作有哪些？</h2><pre><code>(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。- 宏任务包含script(整体代码)setTimeoutsetIntervalI/OUI交互事件postMessageMessageChannelsetImmediate(Node.js 环境)微任务microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。微任务包含：Promise.thenObject.observeMutaionObserverprocess.nextTick(Node.js 环境)</code></pre><h2 id="四分之一圆用-css-怎么实现？"><a href="#四分之一圆用-css-怎么实现？" class="headerlink" title="四分之一圆用 css 怎么实现？"></a>四分之一圆用 css 怎么实现？</h2><pre><code>保持宽高和圆角值相同   div {      width: 100px;      height: 100px;      background-color: pink;      border-radius: 100px 0 0 0;      /*四个值分别对应 左上、右上、右下、左下 */    }</code></pre><h2 id="computed-和-watch-的区别是什么-1"><a href="#computed-和-watch-的区别是什么-1" class="headerlink" title="computed 和 watch 的区别是什么?"></a>computed 和 watch 的区别是什么?</h2><pre><code>计算属性computed :1. 支持缓存，只有依赖数据发生改变，才会重新进行计算2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。侦听属性watch：1. 不支持缓存，数据变，直接会触发相应的操作；2.watch支持异步；3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；4. 当一个属性发生变化时，需要执行对应的操作；一对多；5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，　　immediate：组件加载立即触发回调函数执行，　　deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</code></pre><h2 id="判断数据类型的方法有哪些？"><a href="#判断数据类型的方法有哪些？" class="headerlink" title="判断数据类型的方法有哪些？"></a>判断数据类型的方法有哪些？</h2><pre><code>1.typeofconsole.log(    typeof 123, //"number"    typeof 'dsfsf', //"string"    typeof false, //"boolean"    typeof [1,2,3], //"object"    typeof {a:1,b:2,c:3}, //"object"    typeof function(){console.log('aaa');}, //"function"    typeof undefined, //"undefined"    typeof null, //"object"    typeof new Date(), //"object"    typeof /^[a-zA-Z]{5,20}$/, //"object"    typeof new Error() //"object");Array，Object，null，Date，RegExp，Error这几个类型都被typeof判断为object，所以如果想要判断这几种类型，就不能使用typeof了。Number，String，Boolean，Function，undefined，如果想判断这几种类型，那就可以使用typeof。2. instanceofinstanceof运算符需要指定一个构造函数，或者说指定一个特定的类型，它用来判断这个构造函数的原型是否在给定对象的原型链上。console.log(    123 instanceof Number, //false    'dsfsf' instanceof String, //false    false instanceof Boolean, //false    [1,2,3] instanceof Array, //true    {a:1,b:2,c:3} instanceof Object, //true    function(){console.log('aaa');} instanceof Function, //true    undefined instanceof Object, //false    null instanceof Object, //false    new Date() instanceof Date, //true    /^[a-zA-Z]{5,20}$/ instanceof RegExp, //true    new Error() instanceof Error //true)3.constructorconstructor是prototype对象上的属性，指向构造函数。根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。</code></pre><p>typeof 判断类型返回什么？</p><h2 id="less-和-sass-区别？"><a href="#less-和-sass-区别？" class="headerlink" title="less 和 sass 区别？"></a>less 和 sass 区别？</h2><pre><code>一、概念1、Less：是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。2、Sass：是一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。二、less和sass的相同之处Less和Sass在语法上有些共性，比如下面这些：1、混入(Mixins)——class中的class；2、参数混入——可以传递参数的class，就像函数一样；3、嵌套规则——Class中嵌套class，从而减少重复的代码；4、运算——CSS中用上数学；5、颜色功能——可以编辑颜色；6、名字空间(namespace)——分组样式，从而可以被调用；7、作用域——局部修改样式；8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。三、less和sass的区别Less和Sass的主要不同就是他们的实现方式。Less是基于JavaScript，是在客户端处理的。Sass是基于Ruby的，是在服务器端处理的。关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</code></pre><h2 id="闭包？"><a href="#闭包？" class="headerlink" title="闭包？"></a>闭包？</h2><pre><code>闭包函数：声明在一个函数中的函数，叫做闭包函数。闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。2、特点  让外部访问函数内部变量成为可能；  局部变量会常驻在内存中；  可以避免使用全局变量，防止全局变量污染； 过度使用 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</code></pre><h2 id="var，let-和-const-区别？"><a href="#var，let-和-const-区别？" class="headerlink" title="var，let 和 const 区别？"></a>var，let 和 const 区别？</h2><pre><code>一、var声明的变量会挂载在window上，而let和const声明的变量不会二、var声明变量存在变量提升，let和const不存在变量提升三、let和const声明形成块作用域四、同一作用域下let和const不能声明同名变量，而var可以五、暂存死区六、const　　1、一旦声明必须赋值,不能使用null占位。　　2、声明后不能再修改　　3、如果声明的是复合类型数据，可以修改其属性</code></pre><h2 id="vue2-和-vue3-区别？"><a href="#vue2-和-vue3-区别？" class="headerlink" title="vue2 和 vue3 区别？"></a>vue2 和 vue3 区别？</h2><pre><code>1. 数据双向绑定方面vue2 的双向数据绑定是利用ES5 的一个 API ，Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。vue3 中使用了 es6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每一个对象都包一层 Proxy，通过 Proxy 监听属性的变化，从而实现对数据的监控。2. Vue 3 的 Template 支持多个根标签，Vue 2 不支持3. slot具名插槽的使用vue2中的用法:父组件使用slot=插槽名vue3中子组件用法不变，父组件需要使用v-slot:插槽名</code></pre><h2 id="Echarts-？"><a href="#Echarts-？" class="headerlink" title="Echarts ？"></a>Echarts ？</h2><pre><code>Echarts:ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。</code></pre><h2 id="数组去重？"><a href="#数组去重？" class="headerlink" title="数组去重？"></a>数组去重？</h2><pre><code>一、利用ES6 Set去重（ES6中最常用）function unique (arr) {  return Array.from(new Set(arr))}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))&nbsp;//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]二、[...new Set(arr)][...new Set(arr)]//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</code></pre><h2 id="数组方法和遍历方法？"><a href="#数组方法和遍历方法？" class="headerlink" title="数组方法和遍历方法？"></a>数组方法和遍历方法？</h2><pre><code>数组遍历方法1.for循环2.foreach循环3. map循环4.forof遍历5.filter遍历6.every遍历7.some遍历8.reduce求和数组方法1 arr.push()：从后面添加元素，返回值为添加完后的数组的长度2 arr.pop()：从后面删除元素，只能是一个，返回值是删除的元素3 arr.shift()：从前面删除元素，只能删除一个 返回值是删除的元素4 arr.unshift()：从前面添加元素, 返回值是添加完后的数组的长度5 arr.splice(i,n)：删除从i(索引值)开始之后的那个元素。返回值是删除的元素6 arr.concat()：连接两个数组 返回值为连接后的新数组7 str.split()：将字符串转化为数组8 arr.sort()：将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的。9 arr.reverse()：将数组反转,返回值是反转后的数组10 arr.slice(start,end)：切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js-笔记总结&quot;&gt;&lt;a href=&quot;#js-笔记总结&quot; class=&quot;headerlink&quot; title=&quot;js 笔记总结&quot;&gt;&lt;/a&gt;js 笔记总结&lt;/h1&gt;&lt;h2 id=&quot;盒子塌陷的原因？解决方式&quot;&gt;&lt;a href=&quot;#盒子塌陷的原因？解决方式&quot; class=&quot;</summary>
      
    
    
    
    <category term="前端面试" scheme="https://liang996.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端面试" scheme="https://liang996.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
